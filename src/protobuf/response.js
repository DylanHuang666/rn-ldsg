/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const ActivityResult = $root.ActivityResult = (() => {

    /**
     * Namespace ActivityResult.
     * @exports ActivityResult
     * @namespace
     */
    const ActivityResult = {};

    ActivityResult.DailyReset = (function() {

        /**
         * Properties of a DailyReset.
         * @memberof ActivityResult
         * @interface IDailyReset
         */

        /**
         * Constructs a new DailyReset.
         * @memberof ActivityResult
         * @classdesc Represents a DailyReset.
         * @implements IDailyReset
         * @constructor
         * @param {ActivityResult.IDailyReset=} [properties] Properties to set
         */
        function DailyReset(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Decodes a DailyReset message from the specified reader or buffer.
         * @function decode
         * @memberof ActivityResult.DailyReset
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ActivityResult.DailyReset} DailyReset
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyReset.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ActivityResult.DailyReset();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DailyReset message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ActivityResult.DailyReset
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ActivityResult.DailyReset} DailyReset
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyReset.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return DailyReset;
    })();

    ActivityResult.TaskList = (function() {

        /**
         * Properties of a TaskList.
         * @memberof ActivityResult
         * @interface ITaskList
         * @property {Array.<ActivityResult.ITaskVo>|null} [tasks] TaskList tasks
         */

        /**
         * Constructs a new TaskList.
         * @memberof ActivityResult
         * @classdesc Represents a TaskList.
         * @implements ITaskList
         * @constructor
         * @param {ActivityResult.ITaskList=} [properties] Properties to set
         */
        function TaskList(properties) {
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskList tasks.
         * @member {Array.<ActivityResult.ITaskVo>} tasks
         * @memberof ActivityResult.TaskList
         * @instance
         */
        TaskList.prototype.tasks = $util.emptyArray;

        /**
         * Decodes a TaskList message from the specified reader or buffer.
         * @function decode
         * @memberof ActivityResult.TaskList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ActivityResult.TaskList} TaskList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ActivityResult.TaskList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tasks && message.tasks.length))
                        message.tasks = [];
                    message.tasks.push($root.ActivityResult.TaskVo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ActivityResult.TaskList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ActivityResult.TaskList} TaskList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return TaskList;
    })();

    ActivityResult.TaskVo = (function() {

        /**
         * Properties of a TaskVo.
         * @memberof ActivityResult
         * @interface ITaskVo
         * @property {string} taskId TaskVo taskId
         * @property {number} reachNum TaskVo reachNum
         * @property {number|null} [drawDays] TaskVo drawDays
         * @property {string|null} [tips] TaskVo tips
         * @property {string|null} [preposition] TaskVo preposition
         */

        /**
         * Constructs a new TaskVo.
         * @memberof ActivityResult
         * @classdesc Represents a TaskVo.
         * @implements ITaskVo
         * @constructor
         * @param {ActivityResult.ITaskVo=} [properties] Properties to set
         */
        function TaskVo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskVo taskId.
         * @member {string} taskId
         * @memberof ActivityResult.TaskVo
         * @instance
         */
        TaskVo.prototype.taskId = "";

        /**
         * TaskVo reachNum.
         * @member {number} reachNum
         * @memberof ActivityResult.TaskVo
         * @instance
         */
        TaskVo.prototype.reachNum = 0;

        /**
         * TaskVo drawDays.
         * @member {number} drawDays
         * @memberof ActivityResult.TaskVo
         * @instance
         */
        TaskVo.prototype.drawDays = 0;

        /**
         * TaskVo tips.
         * @member {string} tips
         * @memberof ActivityResult.TaskVo
         * @instance
         */
        TaskVo.prototype.tips = "";

        /**
         * TaskVo preposition.
         * @member {string} preposition
         * @memberof ActivityResult.TaskVo
         * @instance
         */
        TaskVo.prototype.preposition = "";

        /**
         * Decodes a TaskVo message from the specified reader or buffer.
         * @function decode
         * @memberof ActivityResult.TaskVo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ActivityResult.TaskVo} TaskVo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskVo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ActivityResult.TaskVo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskId = reader.string();
                    break;
                case 2:
                    message.reachNum = reader.int32();
                    break;
                case 3:
                    message.drawDays = reader.int32();
                    break;
                case 4:
                    message.tips = reader.string();
                    break;
                case 5:
                    message.preposition = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("taskId"))
                throw $util.ProtocolError("missing required 'taskId'", { instance: message });
            if (!message.hasOwnProperty("reachNum"))
                throw $util.ProtocolError("missing required 'reachNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a TaskVo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ActivityResult.TaskVo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ActivityResult.TaskVo} TaskVo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskVo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return TaskVo;
    })();

    ActivityResult.BroadcastTaskAward = (function() {

        /**
         * Properties of a BroadcastTaskAward.
         * @memberof ActivityResult
         * @interface IBroadcastTaskAward
         * @property {string} taskId BroadcastTaskAward taskId
         */

        /**
         * Constructs a new BroadcastTaskAward.
         * @memberof ActivityResult
         * @classdesc Represents a BroadcastTaskAward.
         * @implements IBroadcastTaskAward
         * @constructor
         * @param {ActivityResult.IBroadcastTaskAward=} [properties] Properties to set
         */
        function BroadcastTaskAward(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BroadcastTaskAward taskId.
         * @member {string} taskId
         * @memberof ActivityResult.BroadcastTaskAward
         * @instance
         */
        BroadcastTaskAward.prototype.taskId = "";

        /**
         * Decodes a BroadcastTaskAward message from the specified reader or buffer.
         * @function decode
         * @memberof ActivityResult.BroadcastTaskAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ActivityResult.BroadcastTaskAward} BroadcastTaskAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BroadcastTaskAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ActivityResult.BroadcastTaskAward();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("taskId"))
                throw $util.ProtocolError("missing required 'taskId'", { instance: message });
            return message;
        };

        /**
         * Decodes a BroadcastTaskAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ActivityResult.BroadcastTaskAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ActivityResult.BroadcastTaskAward} BroadcastTaskAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BroadcastTaskAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return BroadcastTaskAward;
    })();

    ActivityResult.NewHandPkgData = (function() {

        /**
         * Properties of a NewHandPkgData.
         * @memberof ActivityResult
         * @interface INewHandPkgData
         * @property {Array.<number>|null} [pkgStatus] NewHandPkgData pkgStatus
         */

        /**
         * Constructs a new NewHandPkgData.
         * @memberof ActivityResult
         * @classdesc Represents a NewHandPkgData.
         * @implements INewHandPkgData
         * @constructor
         * @param {ActivityResult.INewHandPkgData=} [properties] Properties to set
         */
        function NewHandPkgData(properties) {
            this.pkgStatus = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewHandPkgData pkgStatus.
         * @member {Array.<number>} pkgStatus
         * @memberof ActivityResult.NewHandPkgData
         * @instance
         */
        NewHandPkgData.prototype.pkgStatus = $util.emptyArray;

        /**
         * Decodes a NewHandPkgData message from the specified reader or buffer.
         * @function decode
         * @memberof ActivityResult.NewHandPkgData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ActivityResult.NewHandPkgData} NewHandPkgData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewHandPkgData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ActivityResult.NewHandPkgData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.pkgStatus && message.pkgStatus.length))
                        message.pkgStatus = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.pkgStatus.push(reader.int32());
                    } else
                        message.pkgStatus.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewHandPkgData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ActivityResult.NewHandPkgData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ActivityResult.NewHandPkgData} NewHandPkgData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewHandPkgData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return NewHandPkgData;
    })();

    ActivityResult.SignData = (function() {

        /**
         * Properties of a SignData.
         * @memberof ActivityResult
         * @interface ISignData
         * @property {number} conSignDays SignData conSignDays
         * @property {boolean} signed SignData signed
         * @property {string|null} [giftId] SignData giftId
         * @property {Array.<ActivityResult.ISignAward>|null} [list] SignData list
         */

        /**
         * Constructs a new SignData.
         * @memberof ActivityResult
         * @classdesc Represents a SignData.
         * @implements ISignData
         * @constructor
         * @param {ActivityResult.ISignData=} [properties] Properties to set
         */
        function SignData(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignData conSignDays.
         * @member {number} conSignDays
         * @memberof ActivityResult.SignData
         * @instance
         */
        SignData.prototype.conSignDays = 0;

        /**
         * SignData signed.
         * @member {boolean} signed
         * @memberof ActivityResult.SignData
         * @instance
         */
        SignData.prototype.signed = false;

        /**
         * SignData giftId.
         * @member {string} giftId
         * @memberof ActivityResult.SignData
         * @instance
         */
        SignData.prototype.giftId = "";

        /**
         * SignData list.
         * @member {Array.<ActivityResult.ISignAward>} list
         * @memberof ActivityResult.SignData
         * @instance
         */
        SignData.prototype.list = $util.emptyArray;

        /**
         * Decodes a SignData message from the specified reader or buffer.
         * @function decode
         * @memberof ActivityResult.SignData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ActivityResult.SignData} SignData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ActivityResult.SignData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.conSignDays = reader.int32();
                    break;
                case 2:
                    message.signed = reader.bool();
                    break;
                case 3:
                    message.giftId = reader.string();
                    break;
                case 4:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.ActivityResult.SignAward.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("conSignDays"))
                throw $util.ProtocolError("missing required 'conSignDays'", { instance: message });
            if (!message.hasOwnProperty("signed"))
                throw $util.ProtocolError("missing required 'signed'", { instance: message });
            return message;
        };

        /**
         * Decodes a SignData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ActivityResult.SignData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ActivityResult.SignData} SignData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SignData;
    })();

    ActivityResult.SignAward = (function() {

        /**
         * Properties of a SignAward.
         * @memberof ActivityResult
         * @interface ISignAward
         * @property {number|null} [conSignDays] SignAward conSignDays
         * @property {number|null} [award] SignAward award
         * @property {string|null} [awardItemId] SignAward awardItemId
         */

        /**
         * Constructs a new SignAward.
         * @memberof ActivityResult
         * @classdesc Represents a SignAward.
         * @implements ISignAward
         * @constructor
         * @param {ActivityResult.ISignAward=} [properties] Properties to set
         */
        function SignAward(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignAward conSignDays.
         * @member {number} conSignDays
         * @memberof ActivityResult.SignAward
         * @instance
         */
        SignAward.prototype.conSignDays = 0;

        /**
         * SignAward award.
         * @member {number} award
         * @memberof ActivityResult.SignAward
         * @instance
         */
        SignAward.prototype.award = 0;

        /**
         * SignAward awardItemId.
         * @member {string} awardItemId
         * @memberof ActivityResult.SignAward
         * @instance
         */
        SignAward.prototype.awardItemId = "";

        /**
         * Decodes a SignAward message from the specified reader or buffer.
         * @function decode
         * @memberof ActivityResult.SignAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ActivityResult.SignAward} SignAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ActivityResult.SignAward();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.conSignDays = reader.int32();
                    break;
                case 2:
                    message.award = reader.int32();
                    break;
                case 3:
                    message.awardItemId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ActivityResult.SignAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ActivityResult.SignAward} SignAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SignAward;
    })();

    return ActivityResult;
})();

export const AdviseResult = $root.AdviseResult = (() => {

    /**
     * Namespace AdviseResult.
     * @exports AdviseResult
     * @namespace
     */
    const AdviseResult = {};

    AdviseResult.AdviseList = (function() {

        /**
         * Properties of an AdviseList.
         * @memberof AdviseResult
         * @interface IAdviseList
         * @property {Array.<AdviseResult.IAdvise>|null} [list] AdviseList list
         */

        /**
         * Constructs a new AdviseList.
         * @memberof AdviseResult
         * @classdesc Represents an AdviseList.
         * @implements IAdviseList
         * @constructor
         * @param {AdviseResult.IAdviseList=} [properties] Properties to set
         */
        function AdviseList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdviseList list.
         * @member {Array.<AdviseResult.IAdvise>} list
         * @memberof AdviseResult.AdviseList
         * @instance
         */
        AdviseList.prototype.list = $util.emptyArray;

        /**
         * Decodes an AdviseList message from the specified reader or buffer.
         * @function decode
         * @memberof AdviseResult.AdviseList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AdviseResult.AdviseList} AdviseList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdviseList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AdviseResult.AdviseList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.AdviseResult.Advise.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdviseList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AdviseResult.AdviseList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AdviseResult.AdviseList} AdviseList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdviseList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return AdviseList;
    })();

    AdviseResult.AdviseReplyList = (function() {

        /**
         * Properties of an AdviseReplyList.
         * @memberof AdviseResult
         * @interface IAdviseReplyList
         * @property {Array.<AdviseResult.IAdviseReply>|null} [list] AdviseReplyList list
         */

        /**
         * Constructs a new AdviseReplyList.
         * @memberof AdviseResult
         * @classdesc Represents an AdviseReplyList.
         * @implements IAdviseReplyList
         * @constructor
         * @param {AdviseResult.IAdviseReplyList=} [properties] Properties to set
         */
        function AdviseReplyList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdviseReplyList list.
         * @member {Array.<AdviseResult.IAdviseReply>} list
         * @memberof AdviseResult.AdviseReplyList
         * @instance
         */
        AdviseReplyList.prototype.list = $util.emptyArray;

        /**
         * Decodes an AdviseReplyList message from the specified reader or buffer.
         * @function decode
         * @memberof AdviseResult.AdviseReplyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AdviseResult.AdviseReplyList} AdviseReplyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdviseReplyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AdviseResult.AdviseReplyList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.AdviseResult.AdviseReply.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdviseReplyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AdviseResult.AdviseReplyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AdviseResult.AdviseReplyList} AdviseReplyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdviseReplyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return AdviseReplyList;
    })();

    AdviseResult.Advise = (function() {

        /**
         * Properties of an Advise.
         * @memberof AdviseResult
         * @interface IAdvise
         * @property {string} id Advise id
         * @property {number} type Advise type
         * @property {string} content Advise content
         * @property {string|null} [imgs] Advise imgs
         * @property {string|null} [tel] Advise tel
         * @property {string} date Advise date
         * @property {number} status Advise status
         */

        /**
         * Constructs a new Advise.
         * @memberof AdviseResult
         * @classdesc Represents an Advise.
         * @implements IAdvise
         * @constructor
         * @param {AdviseResult.IAdvise=} [properties] Properties to set
         */
        function Advise(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Advise id.
         * @member {string} id
         * @memberof AdviseResult.Advise
         * @instance
         */
        Advise.prototype.id = "";

        /**
         * Advise type.
         * @member {number} type
         * @memberof AdviseResult.Advise
         * @instance
         */
        Advise.prototype.type = 0;

        /**
         * Advise content.
         * @member {string} content
         * @memberof AdviseResult.Advise
         * @instance
         */
        Advise.prototype.content = "";

        /**
         * Advise imgs.
         * @member {string} imgs
         * @memberof AdviseResult.Advise
         * @instance
         */
        Advise.prototype.imgs = "";

        /**
         * Advise tel.
         * @member {string} tel
         * @memberof AdviseResult.Advise
         * @instance
         */
        Advise.prototype.tel = "";

        /**
         * Advise date.
         * @member {string} date
         * @memberof AdviseResult.Advise
         * @instance
         */
        Advise.prototype.date = "";

        /**
         * Advise status.
         * @member {number} status
         * @memberof AdviseResult.Advise
         * @instance
         */
        Advise.prototype.status = 0;

        /**
         * Decodes an Advise message from the specified reader or buffer.
         * @function decode
         * @memberof AdviseResult.Advise
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AdviseResult.Advise} Advise
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Advise.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AdviseResult.Advise();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.content = reader.string();
                    break;
                case 4:
                    message.imgs = reader.string();
                    break;
                case 5:
                    message.tel = reader.string();
                    break;
                case 6:
                    message.date = reader.string();
                    break;
                case 7:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("content"))
                throw $util.ProtocolError("missing required 'content'", { instance: message });
            if (!message.hasOwnProperty("date"))
                throw $util.ProtocolError("missing required 'date'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes an Advise message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AdviseResult.Advise
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AdviseResult.Advise} Advise
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Advise.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Advise;
    })();

    AdviseResult.AdviseReply = (function() {

        /**
         * Properties of an AdviseReply.
         * @memberof AdviseResult
         * @interface IAdviseReply
         * @property {string} id AdviseReply id
         * @property {string} reply AdviseReply reply
         * @property {string} date AdviseReply date
         */

        /**
         * Constructs a new AdviseReply.
         * @memberof AdviseResult
         * @classdesc Represents an AdviseReply.
         * @implements IAdviseReply
         * @constructor
         * @param {AdviseResult.IAdviseReply=} [properties] Properties to set
         */
        function AdviseReply(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdviseReply id.
         * @member {string} id
         * @memberof AdviseResult.AdviseReply
         * @instance
         */
        AdviseReply.prototype.id = "";

        /**
         * AdviseReply reply.
         * @member {string} reply
         * @memberof AdviseResult.AdviseReply
         * @instance
         */
        AdviseReply.prototype.reply = "";

        /**
         * AdviseReply date.
         * @member {string} date
         * @memberof AdviseResult.AdviseReply
         * @instance
         */
        AdviseReply.prototype.date = "";

        /**
         * Decodes an AdviseReply message from the specified reader or buffer.
         * @function decode
         * @memberof AdviseResult.AdviseReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AdviseResult.AdviseReply} AdviseReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdviseReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AdviseResult.AdviseReply();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.reply = reader.string();
                    break;
                case 3:
                    message.date = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("reply"))
                throw $util.ProtocolError("missing required 'reply'", { instance: message });
            if (!message.hasOwnProperty("date"))
                throw $util.ProtocolError("missing required 'date'", { instance: message });
            return message;
        };

        /**
         * Decodes an AdviseReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AdviseResult.AdviseReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AdviseResult.AdviseReply} AdviseReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdviseReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return AdviseReply;
    })();

    return AdviseResult;
})();

export const AlbumResult = $root.AlbumResult = (() => {

    /**
     * Namespace AlbumResult.
     * @exports AlbumResult
     * @namespace
     */
    const AlbumResult = {};

    AlbumResult.Albums = (function() {

        /**
         * Properties of an Albums.
         * @memberof AlbumResult
         * @interface IAlbums
         * @property {Array.<AlbumResult.IAlbum>|null} [list] Albums list
         * @property {number|Long} total Albums total
         */

        /**
         * Constructs a new Albums.
         * @memberof AlbumResult
         * @classdesc Represents an Albums.
         * @implements IAlbums
         * @constructor
         * @param {AlbumResult.IAlbums=} [properties] Properties to set
         */
        function Albums(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Albums list.
         * @member {Array.<AlbumResult.IAlbum>} list
         * @memberof AlbumResult.Albums
         * @instance
         */
        Albums.prototype.list = $util.emptyArray;

        /**
         * Albums total.
         * @member {number|Long} total
         * @memberof AlbumResult.Albums
         * @instance
         */
        Albums.prototype.total = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes an Albums message from the specified reader or buffer.
         * @function decode
         * @memberof AlbumResult.Albums
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AlbumResult.Albums} Albums
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Albums.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AlbumResult.Albums();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.AlbumResult.Album.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.total = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("total"))
                throw $util.ProtocolError("missing required 'total'", { instance: message });
            return message;
        };

        /**
         * Decodes an Albums message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AlbumResult.Albums
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AlbumResult.Albums} Albums
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Albums.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Albums;
    })();

    AlbumResult.Album = (function() {

        /**
         * Properties of an Album.
         * @memberof AlbumResult
         * @interface IAlbum
         * @property {string} id Album id
         * @property {string} albumData Album albumData
         * @property {Array.<string>|null} [photos] Album photos
         */

        /**
         * Constructs a new Album.
         * @memberof AlbumResult
         * @classdesc Represents an Album.
         * @implements IAlbum
         * @constructor
         * @param {AlbumResult.IAlbum=} [properties] Properties to set
         */
        function Album(properties) {
            this.photos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Album id.
         * @member {string} id
         * @memberof AlbumResult.Album
         * @instance
         */
        Album.prototype.id = "";

        /**
         * Album albumData.
         * @member {string} albumData
         * @memberof AlbumResult.Album
         * @instance
         */
        Album.prototype.albumData = "";

        /**
         * Album photos.
         * @member {Array.<string>} photos
         * @memberof AlbumResult.Album
         * @instance
         */
        Album.prototype.photos = $util.emptyArray;

        /**
         * Decodes an Album message from the specified reader or buffer.
         * @function decode
         * @memberof AlbumResult.Album
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AlbumResult.Album} Album
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Album.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AlbumResult.Album();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.albumData = reader.string();
                    break;
                case 3:
                    if (!(message.photos && message.photos.length))
                        message.photos = [];
                    message.photos.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("albumData"))
                throw $util.ProtocolError("missing required 'albumData'", { instance: message });
            return message;
        };

        /**
         * Decodes an Album message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AlbumResult.Album
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AlbumResult.Album} Album
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Album.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Album;
    })();

    return AlbumResult;
})();

export const BagResult = $root.BagResult = (() => {

    /**
     * Namespace BagResult.
     * @exports BagResult
     * @namespace
     */
    const BagResult = {};

    BagResult.Wallet = (function() {

        /**
         * Properties of a Wallet.
         * @memberof BagResult
         * @interface IWallet
         * @property {number|null} [goldShell] Wallet goldShell
         * @property {number|null} [rabbitCoin] Wallet rabbitCoin
         */

        /**
         * Constructs a new Wallet.
         * @memberof BagResult
         * @classdesc Represents a Wallet.
         * @implements IWallet
         * @constructor
         * @param {BagResult.IWallet=} [properties] Properties to set
         */
        function Wallet(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Wallet goldShell.
         * @member {number} goldShell
         * @memberof BagResult.Wallet
         * @instance
         */
        Wallet.prototype.goldShell = 0;

        /**
         * Wallet rabbitCoin.
         * @member {number} rabbitCoin
         * @memberof BagResult.Wallet
         * @instance
         */
        Wallet.prototype.rabbitCoin = 0;

        /**
         * Decodes a Wallet message from the specified reader or buffer.
         * @function decode
         * @memberof BagResult.Wallet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BagResult.Wallet} Wallet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wallet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BagResult.Wallet();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.goldShell = reader.int32();
                    break;
                case 2:
                    message.rabbitCoin = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Wallet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BagResult.Wallet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BagResult.Wallet} Wallet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wallet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Wallet;
    })();

    BagResult.GoodsList = (function() {

        /**
         * Properties of a GoodsList.
         * @memberof BagResult
         * @interface IGoodsList
         * @property {Array.<BagResult.IGoodsInfo>|null} [goods] GoodsList goods
         * @property {string|null} [useCarId] GoodsList useCarId
         * @property {string|null} [useHeadFrameId] GoodsList useHeadFrameId
         * @property {string|null} [useDialogFrameId] GoodsList useDialogFrameId
         * @property {Array.<string>|null} [useMedals] GoodsList useMedals
         */

        /**
         * Constructs a new GoodsList.
         * @memberof BagResult
         * @classdesc Represents a GoodsList.
         * @implements IGoodsList
         * @constructor
         * @param {BagResult.IGoodsList=} [properties] Properties to set
         */
        function GoodsList(properties) {
            this.goods = [];
            this.useMedals = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GoodsList goods.
         * @member {Array.<BagResult.IGoodsInfo>} goods
         * @memberof BagResult.GoodsList
         * @instance
         */
        GoodsList.prototype.goods = $util.emptyArray;

        /**
         * GoodsList useCarId.
         * @member {string} useCarId
         * @memberof BagResult.GoodsList
         * @instance
         */
        GoodsList.prototype.useCarId = "";

        /**
         * GoodsList useHeadFrameId.
         * @member {string} useHeadFrameId
         * @memberof BagResult.GoodsList
         * @instance
         */
        GoodsList.prototype.useHeadFrameId = "";

        /**
         * GoodsList useDialogFrameId.
         * @member {string} useDialogFrameId
         * @memberof BagResult.GoodsList
         * @instance
         */
        GoodsList.prototype.useDialogFrameId = "";

        /**
         * GoodsList useMedals.
         * @member {Array.<string>} useMedals
         * @memberof BagResult.GoodsList
         * @instance
         */
        GoodsList.prototype.useMedals = $util.emptyArray;

        /**
         * Decodes a GoodsList message from the specified reader or buffer.
         * @function decode
         * @memberof BagResult.GoodsList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BagResult.GoodsList} GoodsList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GoodsList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BagResult.GoodsList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.goods && message.goods.length))
                        message.goods = [];
                    message.goods.push($root.BagResult.GoodsInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.useCarId = reader.string();
                    break;
                case 3:
                    message.useHeadFrameId = reader.string();
                    break;
                case 4:
                    message.useDialogFrameId = reader.string();
                    break;
                case 5:
                    if (!(message.useMedals && message.useMedals.length))
                        message.useMedals = [];
                    message.useMedals.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GoodsList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BagResult.GoodsList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BagResult.GoodsList} GoodsList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GoodsList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return GoodsList;
    })();

    BagResult.GoodsInfo = (function() {

        /**
         * Properties of a GoodsInfo.
         * @memberof BagResult
         * @interface IGoodsInfo
         * @property {string|null} [goodsId] GoodsInfo goodsId
         * @property {number|null} [num] GoodsInfo num
         * @property {number|null} [remainTime] GoodsInfo remainTime
         * @property {number|null} [updateTime] GoodsInfo updateTime
         * @property {boolean|null} [isNew] GoodsInfo isNew
         */

        /**
         * Constructs a new GoodsInfo.
         * @memberof BagResult
         * @classdesc Represents a GoodsInfo.
         * @implements IGoodsInfo
         * @constructor
         * @param {BagResult.IGoodsInfo=} [properties] Properties to set
         */
        function GoodsInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GoodsInfo goodsId.
         * @member {string} goodsId
         * @memberof BagResult.GoodsInfo
         * @instance
         */
        GoodsInfo.prototype.goodsId = "";

        /**
         * GoodsInfo num.
         * @member {number} num
         * @memberof BagResult.GoodsInfo
         * @instance
         */
        GoodsInfo.prototype.num = 0;

        /**
         * GoodsInfo remainTime.
         * @member {number} remainTime
         * @memberof BagResult.GoodsInfo
         * @instance
         */
        GoodsInfo.prototype.remainTime = 0;

        /**
         * GoodsInfo updateTime.
         * @member {number} updateTime
         * @memberof BagResult.GoodsInfo
         * @instance
         */
        GoodsInfo.prototype.updateTime = 0;

        /**
         * GoodsInfo isNew.
         * @member {boolean} isNew
         * @memberof BagResult.GoodsInfo
         * @instance
         */
        GoodsInfo.prototype.isNew = false;

        /**
         * Decodes a GoodsInfo message from the specified reader or buffer.
         * @function decode
         * @memberof BagResult.GoodsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BagResult.GoodsInfo} GoodsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GoodsInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BagResult.GoodsInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.goodsId = reader.string();
                    break;
                case 2:
                    message.num = reader.int32();
                    break;
                case 3:
                    message.remainTime = reader.int32();
                    break;
                case 4:
                    message.updateTime = reader.int32();
                    break;
                case 5:
                    message.isNew = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GoodsInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BagResult.GoodsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BagResult.GoodsInfo} GoodsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GoodsInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return GoodsInfo;
    })();

    BagResult.ReceiveGifts = (function() {

        /**
         * Properties of a ReceiveGifts.
         * @memberof BagResult
         * @interface IReceiveGifts
         * @property {Array.<BagResult.IReceiveGiftInfo>|null} [list] ReceiveGifts list
         */

        /**
         * Constructs a new ReceiveGifts.
         * @memberof BagResult
         * @classdesc Represents a ReceiveGifts.
         * @implements IReceiveGifts
         * @constructor
         * @param {BagResult.IReceiveGifts=} [properties] Properties to set
         */
        function ReceiveGifts(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReceiveGifts list.
         * @member {Array.<BagResult.IReceiveGiftInfo>} list
         * @memberof BagResult.ReceiveGifts
         * @instance
         */
        ReceiveGifts.prototype.list = $util.emptyArray;

        /**
         * Decodes a ReceiveGifts message from the specified reader or buffer.
         * @function decode
         * @memberof BagResult.ReceiveGifts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BagResult.ReceiveGifts} ReceiveGifts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiveGifts.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BagResult.ReceiveGifts();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.BagResult.ReceiveGiftInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReceiveGifts message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BagResult.ReceiveGifts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BagResult.ReceiveGifts} ReceiveGifts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiveGifts.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ReceiveGifts;
    })();

    BagResult.ReceiveGiftInfo = (function() {

        /**
         * Properties of a ReceiveGiftInfo.
         * @memberof BagResult
         * @interface IReceiveGiftInfo
         * @property {string} giftId ReceiveGiftInfo giftId
         * @property {number|Long} num ReceiveGiftInfo num
         * @property {number} price ReceiveGiftInfo price
         * @property {string|null} [name] ReceiveGiftInfo name
         */

        /**
         * Constructs a new ReceiveGiftInfo.
         * @memberof BagResult
         * @classdesc Represents a ReceiveGiftInfo.
         * @implements IReceiveGiftInfo
         * @constructor
         * @param {BagResult.IReceiveGiftInfo=} [properties] Properties to set
         */
        function ReceiveGiftInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReceiveGiftInfo giftId.
         * @member {string} giftId
         * @memberof BagResult.ReceiveGiftInfo
         * @instance
         */
        ReceiveGiftInfo.prototype.giftId = "";

        /**
         * ReceiveGiftInfo num.
         * @member {number|Long} num
         * @memberof BagResult.ReceiveGiftInfo
         * @instance
         */
        ReceiveGiftInfo.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReceiveGiftInfo price.
         * @member {number} price
         * @memberof BagResult.ReceiveGiftInfo
         * @instance
         */
        ReceiveGiftInfo.prototype.price = 0;

        /**
         * ReceiveGiftInfo name.
         * @member {string} name
         * @memberof BagResult.ReceiveGiftInfo
         * @instance
         */
        ReceiveGiftInfo.prototype.name = "";

        /**
         * Decodes a ReceiveGiftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof BagResult.ReceiveGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BagResult.ReceiveGiftInfo} ReceiveGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiveGiftInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BagResult.ReceiveGiftInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.giftId = reader.string();
                    break;
                case 2:
                    message.num = reader.int64();
                    break;
                case 3:
                    message.price = reader.int32();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("giftId"))
                throw $util.ProtocolError("missing required 'giftId'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            return message;
        };

        /**
         * Decodes a ReceiveGiftInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BagResult.ReceiveGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BagResult.ReceiveGiftInfo} ReceiveGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiveGiftInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ReceiveGiftInfo;
    })();

    BagResult.ReceiveGiftLogs = (function() {

        /**
         * Properties of a ReceiveGiftLogs.
         * @memberof BagResult
         * @interface IReceiveGiftLogs
         * @property {Array.<BagResult.IReceiveGiftLog>|null} [list] ReceiveGiftLogs list
         */

        /**
         * Constructs a new ReceiveGiftLogs.
         * @memberof BagResult
         * @classdesc Represents a ReceiveGiftLogs.
         * @implements IReceiveGiftLogs
         * @constructor
         * @param {BagResult.IReceiveGiftLogs=} [properties] Properties to set
         */
        function ReceiveGiftLogs(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReceiveGiftLogs list.
         * @member {Array.<BagResult.IReceiveGiftLog>} list
         * @memberof BagResult.ReceiveGiftLogs
         * @instance
         */
        ReceiveGiftLogs.prototype.list = $util.emptyArray;

        /**
         * Decodes a ReceiveGiftLogs message from the specified reader or buffer.
         * @function decode
         * @memberof BagResult.ReceiveGiftLogs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BagResult.ReceiveGiftLogs} ReceiveGiftLogs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiveGiftLogs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BagResult.ReceiveGiftLogs();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.BagResult.ReceiveGiftLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReceiveGiftLogs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BagResult.ReceiveGiftLogs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BagResult.ReceiveGiftLogs} ReceiveGiftLogs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiveGiftLogs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ReceiveGiftLogs;
    })();

    BagResult.ReceiveGiftLog = (function() {

        /**
         * Properties of a ReceiveGiftLog.
         * @memberof BagResult
         * @interface IReceiveGiftLog
         * @property {number|Long} logDate ReceiveGiftLog logDate
         * @property {UserResult.IUserBase} sendUserBase ReceiveGiftLog sendUserBase
         * @property {string} giftId ReceiveGiftLog giftId
         * @property {number} num ReceiveGiftLog num
         * @property {string|null} [id] ReceiveGiftLog id
         */

        /**
         * Constructs a new ReceiveGiftLog.
         * @memberof BagResult
         * @classdesc Represents a ReceiveGiftLog.
         * @implements IReceiveGiftLog
         * @constructor
         * @param {BagResult.IReceiveGiftLog=} [properties] Properties to set
         */
        function ReceiveGiftLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReceiveGiftLog logDate.
         * @member {number|Long} logDate
         * @memberof BagResult.ReceiveGiftLog
         * @instance
         */
        ReceiveGiftLog.prototype.logDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReceiveGiftLog sendUserBase.
         * @member {UserResult.IUserBase} sendUserBase
         * @memberof BagResult.ReceiveGiftLog
         * @instance
         */
        ReceiveGiftLog.prototype.sendUserBase = null;

        /**
         * ReceiveGiftLog giftId.
         * @member {string} giftId
         * @memberof BagResult.ReceiveGiftLog
         * @instance
         */
        ReceiveGiftLog.prototype.giftId = "";

        /**
         * ReceiveGiftLog num.
         * @member {number} num
         * @memberof BagResult.ReceiveGiftLog
         * @instance
         */
        ReceiveGiftLog.prototype.num = 0;

        /**
         * ReceiveGiftLog id.
         * @member {string} id
         * @memberof BagResult.ReceiveGiftLog
         * @instance
         */
        ReceiveGiftLog.prototype.id = "";

        /**
         * Decodes a ReceiveGiftLog message from the specified reader or buffer.
         * @function decode
         * @memberof BagResult.ReceiveGiftLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BagResult.ReceiveGiftLog} ReceiveGiftLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiveGiftLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BagResult.ReceiveGiftLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logDate = reader.int64();
                    break;
                case 2:
                    message.sendUserBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.giftId = reader.string();
                    break;
                case 4:
                    message.num = reader.int32();
                    break;
                case 5:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("logDate"))
                throw $util.ProtocolError("missing required 'logDate'", { instance: message });
            if (!message.hasOwnProperty("sendUserBase"))
                throw $util.ProtocolError("missing required 'sendUserBase'", { instance: message });
            if (!message.hasOwnProperty("giftId"))
                throw $util.ProtocolError("missing required 'giftId'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            return message;
        };

        /**
         * Decodes a ReceiveGiftLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BagResult.ReceiveGiftLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BagResult.ReceiveGiftLog} ReceiveGiftLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiveGiftLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ReceiveGiftLog;
    })();

    BagResult.SmashEggResultBroadcast = (function() {

        /**
         * Properties of a SmashEggResultBroadcast.
         * @memberof BagResult
         * @interface ISmashEggResultBroadcast
         * @property {UserResult.IUserBase|null} [smashUserBase] SmashEggResultBroadcast smashUserBase
         * @property {Array.<BagResult.IReceiveGiftInfo>|null} [giftList] SmashEggResultBroadcast giftList
         * @property {number|null} [broadcastType] SmashEggResultBroadcast broadcastType
         * @property {number|null} [action] SmashEggResultBroadcast action
         * @property {string|null} [eggType] SmashEggResultBroadcast eggType
         * @property {string|null} [roomId] SmashEggResultBroadcast roomId
         * @property {string|null} [roomName] SmashEggResultBroadcast roomName
         */

        /**
         * Constructs a new SmashEggResultBroadcast.
         * @memberof BagResult
         * @classdesc Represents a SmashEggResultBroadcast.
         * @implements ISmashEggResultBroadcast
         * @constructor
         * @param {BagResult.ISmashEggResultBroadcast=} [properties] Properties to set
         */
        function SmashEggResultBroadcast(properties) {
            this.giftList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmashEggResultBroadcast smashUserBase.
         * @member {UserResult.IUserBase|null|undefined} smashUserBase
         * @memberof BagResult.SmashEggResultBroadcast
         * @instance
         */
        SmashEggResultBroadcast.prototype.smashUserBase = null;

        /**
         * SmashEggResultBroadcast giftList.
         * @member {Array.<BagResult.IReceiveGiftInfo>} giftList
         * @memberof BagResult.SmashEggResultBroadcast
         * @instance
         */
        SmashEggResultBroadcast.prototype.giftList = $util.emptyArray;

        /**
         * SmashEggResultBroadcast broadcastType.
         * @member {number} broadcastType
         * @memberof BagResult.SmashEggResultBroadcast
         * @instance
         */
        SmashEggResultBroadcast.prototype.broadcastType = 0;

        /**
         * SmashEggResultBroadcast action.
         * @member {number} action
         * @memberof BagResult.SmashEggResultBroadcast
         * @instance
         */
        SmashEggResultBroadcast.prototype.action = 0;

        /**
         * SmashEggResultBroadcast eggType.
         * @member {string} eggType
         * @memberof BagResult.SmashEggResultBroadcast
         * @instance
         */
        SmashEggResultBroadcast.prototype.eggType = "";

        /**
         * SmashEggResultBroadcast roomId.
         * @member {string} roomId
         * @memberof BagResult.SmashEggResultBroadcast
         * @instance
         */
        SmashEggResultBroadcast.prototype.roomId = "";

        /**
         * SmashEggResultBroadcast roomName.
         * @member {string} roomName
         * @memberof BagResult.SmashEggResultBroadcast
         * @instance
         */
        SmashEggResultBroadcast.prototype.roomName = "";

        /**
         * Decodes a SmashEggResultBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BagResult.SmashEggResultBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BagResult.SmashEggResultBroadcast} SmashEggResultBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashEggResultBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BagResult.SmashEggResultBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.smashUserBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.giftList && message.giftList.length))
                        message.giftList = [];
                    message.giftList.push($root.BagResult.ReceiveGiftInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.broadcastType = reader.int32();
                    break;
                case 4:
                    message.action = reader.int32();
                    break;
                case 5:
                    message.eggType = reader.string();
                    break;
                case 6:
                    message.roomId = reader.string();
                    break;
                case 7:
                    message.roomName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SmashEggResultBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BagResult.SmashEggResultBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BagResult.SmashEggResultBroadcast} SmashEggResultBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashEggResultBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SmashEggResultBroadcast;
    })();

    BagResult.MythAnmlBroadcast = (function() {

        /**
         * Properties of a MythAnmlBroadcast.
         * @memberof BagResult
         * @interface IMythAnmlBroadcast
         * @property {UserResult.IUserBase} userBase MythAnmlBroadcast userBase
         * @property {BagResult.IReceiveGiftInfo|null} [gift] MythAnmlBroadcast gift
         * @property {number|null} [broadcastType] MythAnmlBroadcast broadcastType
         * @property {number|null} [wpnId] MythAnmlBroadcast wpnId
         * @property {boolean|null} [isCrit] MythAnmlBroadcast isCrit
         * @property {boolean|null} [isKill] MythAnmlBroadcast isKill
         * @property {string|null} [roomId] MythAnmlBroadcast roomId
         * @property {string|null} [roomName] MythAnmlBroadcast roomName
         * @property {number|null} [hurtValue] MythAnmlBroadcast hurtValue
         * @property {number|Long|null} [nowLife] MythAnmlBroadcast nowLife
         */

        /**
         * Constructs a new MythAnmlBroadcast.
         * @memberof BagResult
         * @classdesc Represents a MythAnmlBroadcast.
         * @implements IMythAnmlBroadcast
         * @constructor
         * @param {BagResult.IMythAnmlBroadcast=} [properties] Properties to set
         */
        function MythAnmlBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MythAnmlBroadcast userBase.
         * @member {UserResult.IUserBase} userBase
         * @memberof BagResult.MythAnmlBroadcast
         * @instance
         */
        MythAnmlBroadcast.prototype.userBase = null;

        /**
         * MythAnmlBroadcast gift.
         * @member {BagResult.IReceiveGiftInfo|null|undefined} gift
         * @memberof BagResult.MythAnmlBroadcast
         * @instance
         */
        MythAnmlBroadcast.prototype.gift = null;

        /**
         * MythAnmlBroadcast broadcastType.
         * @member {number} broadcastType
         * @memberof BagResult.MythAnmlBroadcast
         * @instance
         */
        MythAnmlBroadcast.prototype.broadcastType = 0;

        /**
         * MythAnmlBroadcast wpnId.
         * @member {number} wpnId
         * @memberof BagResult.MythAnmlBroadcast
         * @instance
         */
        MythAnmlBroadcast.prototype.wpnId = 0;

        /**
         * MythAnmlBroadcast isCrit.
         * @member {boolean} isCrit
         * @memberof BagResult.MythAnmlBroadcast
         * @instance
         */
        MythAnmlBroadcast.prototype.isCrit = false;

        /**
         * MythAnmlBroadcast isKill.
         * @member {boolean} isKill
         * @memberof BagResult.MythAnmlBroadcast
         * @instance
         */
        MythAnmlBroadcast.prototype.isKill = false;

        /**
         * MythAnmlBroadcast roomId.
         * @member {string} roomId
         * @memberof BagResult.MythAnmlBroadcast
         * @instance
         */
        MythAnmlBroadcast.prototype.roomId = "";

        /**
         * MythAnmlBroadcast roomName.
         * @member {string} roomName
         * @memberof BagResult.MythAnmlBroadcast
         * @instance
         */
        MythAnmlBroadcast.prototype.roomName = "";

        /**
         * MythAnmlBroadcast hurtValue.
         * @member {number} hurtValue
         * @memberof BagResult.MythAnmlBroadcast
         * @instance
         */
        MythAnmlBroadcast.prototype.hurtValue = 0;

        /**
         * MythAnmlBroadcast nowLife.
         * @member {number|Long} nowLife
         * @memberof BagResult.MythAnmlBroadcast
         * @instance
         */
        MythAnmlBroadcast.prototype.nowLife = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a MythAnmlBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BagResult.MythAnmlBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BagResult.MythAnmlBroadcast} MythAnmlBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MythAnmlBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BagResult.MythAnmlBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.gift = $root.BagResult.ReceiveGiftInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.broadcastType = reader.int32();
                    break;
                case 4:
                    message.wpnId = reader.int32();
                    break;
                case 5:
                    message.isCrit = reader.bool();
                    break;
                case 6:
                    message.isKill = reader.bool();
                    break;
                case 7:
                    message.roomId = reader.string();
                    break;
                case 8:
                    message.roomName = reader.string();
                    break;
                case 9:
                    message.hurtValue = reader.int32();
                    break;
                case 10:
                    message.nowLife = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userBase"))
                throw $util.ProtocolError("missing required 'userBase'", { instance: message });
            return message;
        };

        /**
         * Decodes a MythAnmlBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BagResult.MythAnmlBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BagResult.MythAnmlBroadcast} MythAnmlBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MythAnmlBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MythAnmlBroadcast;
    })();

    BagResult.SmashEggActivityResultBroadcast = (function() {

        /**
         * Properties of a SmashEggActivityResultBroadcast.
         * @memberof BagResult
         * @interface ISmashEggActivityResultBroadcast
         * @property {UserResult.IUserBase|null} [smashUserBase] SmashEggActivityResultBroadcast smashUserBase
         * @property {Array.<BagResult.IReceiveGiftInfo>|null} [giftList] SmashEggActivityResultBroadcast giftList
         * @property {number|null} [broadcastType] SmashEggActivityResultBroadcast broadcastType
         * @property {number|null} [action] SmashEggActivityResultBroadcast action
         * @property {string|null} [eggType] SmashEggActivityResultBroadcast eggType
         * @property {string|null} [roomId] SmashEggActivityResultBroadcast roomId
         * @property {string|null} [roomName] SmashEggActivityResultBroadcast roomName
         * @property {number|null} [activityType] SmashEggActivityResultBroadcast activityType
         * @property {number|null} [activityValue] SmashEggActivityResultBroadcast activityValue
         */

        /**
         * Constructs a new SmashEggActivityResultBroadcast.
         * @memberof BagResult
         * @classdesc Represents a SmashEggActivityResultBroadcast.
         * @implements ISmashEggActivityResultBroadcast
         * @constructor
         * @param {BagResult.ISmashEggActivityResultBroadcast=} [properties] Properties to set
         */
        function SmashEggActivityResultBroadcast(properties) {
            this.giftList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmashEggActivityResultBroadcast smashUserBase.
         * @member {UserResult.IUserBase|null|undefined} smashUserBase
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @instance
         */
        SmashEggActivityResultBroadcast.prototype.smashUserBase = null;

        /**
         * SmashEggActivityResultBroadcast giftList.
         * @member {Array.<BagResult.IReceiveGiftInfo>} giftList
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @instance
         */
        SmashEggActivityResultBroadcast.prototype.giftList = $util.emptyArray;

        /**
         * SmashEggActivityResultBroadcast broadcastType.
         * @member {number} broadcastType
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @instance
         */
        SmashEggActivityResultBroadcast.prototype.broadcastType = 0;

        /**
         * SmashEggActivityResultBroadcast action.
         * @member {number} action
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @instance
         */
        SmashEggActivityResultBroadcast.prototype.action = 0;

        /**
         * SmashEggActivityResultBroadcast eggType.
         * @member {string} eggType
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @instance
         */
        SmashEggActivityResultBroadcast.prototype.eggType = "";

        /**
         * SmashEggActivityResultBroadcast roomId.
         * @member {string} roomId
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @instance
         */
        SmashEggActivityResultBroadcast.prototype.roomId = "";

        /**
         * SmashEggActivityResultBroadcast roomName.
         * @member {string} roomName
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @instance
         */
        SmashEggActivityResultBroadcast.prototype.roomName = "";

        /**
         * SmashEggActivityResultBroadcast activityType.
         * @member {number} activityType
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @instance
         */
        SmashEggActivityResultBroadcast.prototype.activityType = 0;

        /**
         * SmashEggActivityResultBroadcast activityValue.
         * @member {number} activityValue
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @instance
         */
        SmashEggActivityResultBroadcast.prototype.activityValue = 0;

        /**
         * Decodes a SmashEggActivityResultBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BagResult.SmashEggActivityResultBroadcast} SmashEggActivityResultBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashEggActivityResultBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BagResult.SmashEggActivityResultBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.smashUserBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.giftList && message.giftList.length))
                        message.giftList = [];
                    message.giftList.push($root.BagResult.ReceiveGiftInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.broadcastType = reader.int32();
                    break;
                case 4:
                    message.action = reader.int32();
                    break;
                case 5:
                    message.eggType = reader.string();
                    break;
                case 6:
                    message.roomId = reader.string();
                    break;
                case 7:
                    message.roomName = reader.string();
                    break;
                case 8:
                    message.activityType = reader.int32();
                    break;
                case 10:
                    message.activityValue = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SmashEggActivityResultBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BagResult.SmashEggActivityResultBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BagResult.SmashEggActivityResultBroadcast} SmashEggActivityResultBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashEggActivityResultBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SmashEggActivityResultBroadcast;
    })();

    return BagResult;
})();

export const UserResult = $root.UserResult = (() => {

    /**
     * Namespace UserResult.
     * @exports UserResult
     * @namespace
     */
    const UserResult = {};

    UserResult.Login = (function() {

        /**
         * Properties of a Login.
         * @memberof UserResult
         * @interface ILogin
         * @property {string} userId Login userId
         * @property {string} tickToken Login tickToken
         * @property {boolean} addSysGMember Login addSysGMember
         * @property {string|null} [phoneNumber] Login phoneNumber
         * @property {string|null} [userName] Login userName
         * @property {string|null} [password] Login password
         * @property {number|Long|null} [deviceSeq] Login deviceSeq
         * @property {number|null} [authType] Login authType
         * @property {number|null} [youngType] Login youngType
         * @property {boolean|null} [youngOpen] Login youngOpen
         * @property {boolean|null} [isRegister] Login isRegister
         */

        /**
         * Constructs a new Login.
         * @memberof UserResult
         * @classdesc Represents a Login.
         * @implements ILogin
         * @constructor
         * @param {UserResult.ILogin=} [properties] Properties to set
         */
        function Login(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Login userId.
         * @member {string} userId
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.userId = "";

        /**
         * Login tickToken.
         * @member {string} tickToken
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.tickToken = "";

        /**
         * Login addSysGMember.
         * @member {boolean} addSysGMember
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.addSysGMember = false;

        /**
         * Login phoneNumber.
         * @member {string} phoneNumber
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.phoneNumber = "";

        /**
         * Login userName.
         * @member {string} userName
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.userName = "";

        /**
         * Login password.
         * @member {string} password
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.password = "";

        /**
         * Login deviceSeq.
         * @member {number|Long} deviceSeq
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.deviceSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Login authType.
         * @member {number} authType
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.authType = 0;

        /**
         * Login youngType.
         * @member {number} youngType
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.youngType = 0;

        /**
         * Login youngOpen.
         * @member {boolean} youngOpen
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.youngOpen = false;

        /**
         * Login isRegister.
         * @member {boolean} isRegister
         * @memberof UserResult.Login
         * @instance
         */
        Login.prototype.isRegister = false;

        /**
         * Decodes a Login message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.Login} Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.Login();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.tickToken = reader.string();
                    break;
                case 3:
                    message.addSysGMember = reader.bool();
                    break;
                case 4:
                    message.phoneNumber = reader.string();
                    break;
                case 5:
                    message.userName = reader.string();
                    break;
                case 6:
                    message.password = reader.string();
                    break;
                case 7:
                    message.deviceSeq = reader.int64();
                    break;
                case 10:
                    message.authType = reader.int32();
                    break;
                case 11:
                    message.youngType = reader.int32();
                    break;
                case 12:
                    message.youngOpen = reader.bool();
                    break;
                case 13:
                    message.isRegister = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("tickToken"))
                throw $util.ProtocolError("missing required 'tickToken'", { instance: message });
            if (!message.hasOwnProperty("addSysGMember"))
                throw $util.ProtocolError("missing required 'addSysGMember'", { instance: message });
            return message;
        };

        /**
         * Decodes a Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.Login} Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Login;
    })();

    UserResult.Logon = (function() {

        /**
         * Properties of a Logon.
         * @memberof UserResult
         * @interface ILogon
         * @property {string} serverId Logon serverId
         * @property {string} tlsSig Logon tlsSig
         * @property {string} roomId Logon roomId
         * @property {Array.<number>|null} [dataVersions] Logon dataVersions
         * @property {string|null} [host] Logon host
         * @property {number|null} [port] Logon port
         * @property {boolean|null} [setpassword] Logon setpassword
         * @property {string|null} [sessionId] Logon sessionId
         * @property {boolean|null} [needSetPersonData] Logon needSetPersonData
         * @property {string|null} [headUrl] Logon headUrl
         * @property {string|null} [version] Logon version
         * @property {UserResult.IUserInitData|null} [initData] Logon initData
         * @property {number|null} [forceUpdate] Logon forceUpdate
         * @property {number|null} [iosPayType] Logon iosPayType
         * @property {boolean|null} [isSanBox] Logon isSanBox
         * @property {boolean|null} [isBlack] Logon isBlack
         * @property {string|null} [userId] Logon userId
         * @property {string|null} [tickToken] Logon tickToken
         * @property {boolean|null} [addSysGMember] Logon addSysGMember
         * @property {string|null} [phoneNumber] Logon phoneNumber
         * @property {string|null} [userName] Logon userName
         * @property {string|null} [password] Logon password
         * @property {number|null} [authType] Logon authType
         * @property {number|null} [youngType] Logon youngType
         * @property {boolean|null} [youngOpen] Logon youngOpen
         * @property {number|Long|null} [deviceSeq] Logon deviceSeq
         * @property {string|null} [channelRoom] Logon channelRoom
         * @property {string|null} [channelRoomTips] Logon channelRoomTips
         * @property {boolean|null} [isRegister] Logon isRegister
         * @property {boolean|null} [setPayPassword] Logon setPayPassword
         */

        /**
         * Constructs a new Logon.
         * @memberof UserResult
         * @classdesc Represents a Logon.
         * @implements ILogon
         * @constructor
         * @param {UserResult.ILogon=} [properties] Properties to set
         */
        function Logon(properties) {
            this.dataVersions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Logon serverId.
         * @member {string} serverId
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.serverId = "";

        /**
         * Logon tlsSig.
         * @member {string} tlsSig
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.tlsSig = "";

        /**
         * Logon roomId.
         * @member {string} roomId
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.roomId = "";

        /**
         * Logon dataVersions.
         * @member {Array.<number>} dataVersions
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.dataVersions = $util.emptyArray;

        /**
         * Logon host.
         * @member {string} host
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.host = "";

        /**
         * Logon port.
         * @member {number} port
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.port = 0;

        /**
         * Logon setpassword.
         * @member {boolean} setpassword
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.setpassword = false;

        /**
         * Logon sessionId.
         * @member {string} sessionId
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.sessionId = "";

        /**
         * Logon needSetPersonData.
         * @member {boolean} needSetPersonData
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.needSetPersonData = false;

        /**
         * Logon headUrl.
         * @member {string} headUrl
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.headUrl = "";

        /**
         * Logon version.
         * @member {string} version
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.version = "";

        /**
         * Logon initData.
         * @member {UserResult.IUserInitData|null|undefined} initData
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.initData = null;

        /**
         * Logon forceUpdate.
         * @member {number} forceUpdate
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.forceUpdate = 0;

        /**
         * Logon iosPayType.
         * @member {number} iosPayType
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.iosPayType = 0;

        /**
         * Logon isSanBox.
         * @member {boolean} isSanBox
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.isSanBox = false;

        /**
         * Logon isBlack.
         * @member {boolean} isBlack
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.isBlack = false;

        /**
         * Logon userId.
         * @member {string} userId
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.userId = "";

        /**
         * Logon tickToken.
         * @member {string} tickToken
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.tickToken = "";

        /**
         * Logon addSysGMember.
         * @member {boolean} addSysGMember
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.addSysGMember = false;

        /**
         * Logon phoneNumber.
         * @member {string} phoneNumber
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.phoneNumber = "";

        /**
         * Logon userName.
         * @member {string} userName
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.userName = "";

        /**
         * Logon password.
         * @member {string} password
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.password = "";

        /**
         * Logon authType.
         * @member {number} authType
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.authType = 0;

        /**
         * Logon youngType.
         * @member {number} youngType
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.youngType = 0;

        /**
         * Logon youngOpen.
         * @member {boolean} youngOpen
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.youngOpen = false;

        /**
         * Logon deviceSeq.
         * @member {number|Long} deviceSeq
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.deviceSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Logon channelRoom.
         * @member {string} channelRoom
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.channelRoom = "";

        /**
         * Logon channelRoomTips.
         * @member {string} channelRoomTips
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.channelRoomTips = "";

        /**
         * Logon isRegister.
         * @member {boolean} isRegister
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.isRegister = false;

        /**
         * Logon setPayPassword.
         * @member {boolean} setPayPassword
         * @memberof UserResult.Logon
         * @instance
         */
        Logon.prototype.setPayPassword = false;

        /**
         * Decodes a Logon message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.Logon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.Logon} Logon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Logon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.Logon();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.string();
                    break;
                case 2:
                    message.tlsSig = reader.string();
                    break;
                case 3:
                    message.roomId = reader.string();
                    break;
                case 4:
                    if (!(message.dataVersions && message.dataVersions.length))
                        message.dataVersions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.dataVersions.push(reader.int32());
                    } else
                        message.dataVersions.push(reader.int32());
                    break;
                case 5:
                    message.host = reader.string();
                    break;
                case 6:
                    message.port = reader.int32();
                    break;
                case 7:
                    message.setpassword = reader.bool();
                    break;
                case 8:
                    message.sessionId = reader.string();
                    break;
                case 15:
                    message.needSetPersonData = reader.bool();
                    break;
                case 16:
                    message.headUrl = reader.string();
                    break;
                case 17:
                    message.version = reader.string();
                    break;
                case 18:
                    message.initData = $root.UserResult.UserInitData.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.forceUpdate = reader.int32();
                    break;
                case 20:
                    message.iosPayType = reader.int32();
                    break;
                case 21:
                    message.isSanBox = reader.bool();
                    break;
                case 22:
                    message.isBlack = reader.bool();
                    break;
                case 9:
                    message.userId = reader.string();
                    break;
                case 10:
                    message.tickToken = reader.string();
                    break;
                case 11:
                    message.addSysGMember = reader.bool();
                    break;
                case 12:
                    message.phoneNumber = reader.string();
                    break;
                case 13:
                    message.userName = reader.string();
                    break;
                case 14:
                    message.password = reader.string();
                    break;
                case 23:
                    message.authType = reader.int32();
                    break;
                case 24:
                    message.youngType = reader.int32();
                    break;
                case 25:
                    message.youngOpen = reader.bool();
                    break;
                case 26:
                    message.deviceSeq = reader.int64();
                    break;
                case 27:
                    message.channelRoom = reader.string();
                    break;
                case 28:
                    message.channelRoomTips = reader.string();
                    break;
                case 29:
                    message.isRegister = reader.bool();
                    break;
                case 30:
                    message.setPayPassword = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("serverId"))
                throw $util.ProtocolError("missing required 'serverId'", { instance: message });
            if (!message.hasOwnProperty("tlsSig"))
                throw $util.ProtocolError("missing required 'tlsSig'", { instance: message });
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            return message;
        };

        /**
         * Decodes a Logon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.Logon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.Logon} Logon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Logon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Logon;
    })();

    UserResult.UserInitData = (function() {

        /**
         * Properties of a UserInitData.
         * @memberof UserResult
         * @interface IUserInitData
         * @property {boolean|null} [newNote] UserInitData newNote
         * @property {ActivityResult.INewHandPkgData|null} [newHandData] UserInitData newHandData
         * @property {ActivityResult.ISignData|null} [signData] UserInitData signData
         * @property {boolean|null} [newPkgGift] UserInitData newPkgGift
         * @property {boolean|null} [newRedPkg] UserInitData newRedPkg
         * @property {boolean|null} [canGetLoginPkg] UserInitData canGetLoginPkg
         * @property {Array.<boolean>|null} [redPoints] UserInitData redPoints
         * @property {boolean|null} [showCharacterTest] UserInitData showCharacterTest
         * @property {boolean|null} [loveRingToast] UserInitData loveRingToast
         * @property {string|null} [officialGroupId] UserInitData officialGroupId
         */

        /**
         * Constructs a new UserInitData.
         * @memberof UserResult
         * @classdesc Represents a UserInitData.
         * @implements IUserInitData
         * @constructor
         * @param {UserResult.IUserInitData=} [properties] Properties to set
         */
        function UserInitData(properties) {
            this.redPoints = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInitData newNote.
         * @member {boolean} newNote
         * @memberof UserResult.UserInitData
         * @instance
         */
        UserInitData.prototype.newNote = false;

        /**
         * UserInitData newHandData.
         * @member {ActivityResult.INewHandPkgData|null|undefined} newHandData
         * @memberof UserResult.UserInitData
         * @instance
         */
        UserInitData.prototype.newHandData = null;

        /**
         * UserInitData signData.
         * @member {ActivityResult.ISignData|null|undefined} signData
         * @memberof UserResult.UserInitData
         * @instance
         */
        UserInitData.prototype.signData = null;

        /**
         * UserInitData newPkgGift.
         * @member {boolean} newPkgGift
         * @memberof UserResult.UserInitData
         * @instance
         */
        UserInitData.prototype.newPkgGift = false;

        /**
         * UserInitData newRedPkg.
         * @member {boolean} newRedPkg
         * @memberof UserResult.UserInitData
         * @instance
         */
        UserInitData.prototype.newRedPkg = false;

        /**
         * UserInitData canGetLoginPkg.
         * @member {boolean} canGetLoginPkg
         * @memberof UserResult.UserInitData
         * @instance
         */
        UserInitData.prototype.canGetLoginPkg = false;

        /**
         * UserInitData redPoints.
         * @member {Array.<boolean>} redPoints
         * @memberof UserResult.UserInitData
         * @instance
         */
        UserInitData.prototype.redPoints = $util.emptyArray;

        /**
         * UserInitData showCharacterTest.
         * @member {boolean} showCharacterTest
         * @memberof UserResult.UserInitData
         * @instance
         */
        UserInitData.prototype.showCharacterTest = false;

        /**
         * UserInitData loveRingToast.
         * @member {boolean} loveRingToast
         * @memberof UserResult.UserInitData
         * @instance
         */
        UserInitData.prototype.loveRingToast = false;

        /**
         * UserInitData officialGroupId.
         * @member {string} officialGroupId
         * @memberof UserResult.UserInitData
         * @instance
         */
        UserInitData.prototype.officialGroupId = "";

        /**
         * Decodes a UserInitData message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.UserInitData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.UserInitData} UserInitData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInitData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.UserInitData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.newNote = reader.bool();
                    break;
                case 2:
                    message.newHandData = $root.ActivityResult.NewHandPkgData.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signData = $root.ActivityResult.SignData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.newPkgGift = reader.bool();
                    break;
                case 5:
                    message.newRedPkg = reader.bool();
                    break;
                case 6:
                    message.canGetLoginPkg = reader.bool();
                    break;
                case 7:
                    if (!(message.redPoints && message.redPoints.length))
                        message.redPoints = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.redPoints.push(reader.bool());
                    } else
                        message.redPoints.push(reader.bool());
                    break;
                case 8:
                    message.showCharacterTest = reader.bool();
                    break;
                case 9:
                    message.loveRingToast = reader.bool();
                    break;
                case 10:
                    message.officialGroupId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserInitData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.UserInitData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.UserInitData} UserInitData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInitData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserInitData;
    })();

    UserResult.UserBaseList = (function() {

        /**
         * Properties of a UserBaseList.
         * @memberof UserResult
         * @interface IUserBaseList
         * @property {Array.<UserResult.IUserBase>|null} [list] UserBaseList list
         */

        /**
         * Constructs a new UserBaseList.
         * @memberof UserResult
         * @classdesc Represents a UserBaseList.
         * @implements IUserBaseList
         * @constructor
         * @param {UserResult.IUserBaseList=} [properties] Properties to set
         */
        function UserBaseList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserBaseList list.
         * @member {Array.<UserResult.IUserBase>} list
         * @memberof UserResult.UserBaseList
         * @instance
         */
        UserBaseList.prototype.list = $util.emptyArray;

        /**
         * Decodes a UserBaseList message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.UserBaseList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.UserBaseList} UserBaseList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBaseList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.UserBaseList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.UserResult.UserBase.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserBaseList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.UserBaseList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.UserBaseList} UserBaseList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBaseList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserBaseList;
    })();

    UserResult.UserBase = (function() {

        /**
         * Properties of a UserBase.
         * @memberof UserResult
         * @interface IUserBase
         * @property {string} userId UserBase userId
         * @property {string|null} [nickName] UserBase nickName
         * @property {number|null} [logoTime] UserBase logoTime
         * @property {string|null} [thirdIconurl] UserBase thirdIconurl
         * @property {string|null} [headFrameId] UserBase headFrameId
         * @property {number|null} [sex] UserBase sex
         * @property {number|null} [age] UserBase age
         * @property {number|null} [vipLv] UserBase vipLv
         * @property {string|null} [slogan] UserBase slogan
         * @property {number|null} [contributeLv] UserBase contributeLv
         * @property {string|null} [position] UserBase position
         * @property {string|null} [channelId] UserBase channelId
         * @property {number|null} [friendStatus] UserBase friendStatus
         * @property {number|null} [charmLv] UserBase charmLv
         */

        /**
         * Constructs a new UserBase.
         * @memberof UserResult
         * @classdesc Represents a UserBase.
         * @implements IUserBase
         * @constructor
         * @param {UserResult.IUserBase=} [properties] Properties to set
         */
        function UserBase(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserBase userId.
         * @member {string} userId
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.userId = "";

        /**
         * UserBase nickName.
         * @member {string} nickName
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.nickName = "";

        /**
         * UserBase logoTime.
         * @member {number} logoTime
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.logoTime = 0;

        /**
         * UserBase thirdIconurl.
         * @member {string} thirdIconurl
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.thirdIconurl = "";

        /**
         * UserBase headFrameId.
         * @member {string} headFrameId
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.headFrameId = "";

        /**
         * UserBase sex.
         * @member {number} sex
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.sex = 0;

        /**
         * UserBase age.
         * @member {number} age
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.age = 0;

        /**
         * UserBase vipLv.
         * @member {number} vipLv
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.vipLv = 0;

        /**
         * UserBase slogan.
         * @member {string} slogan
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.slogan = "";

        /**
         * UserBase contributeLv.
         * @member {number} contributeLv
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.contributeLv = 0;

        /**
         * UserBase position.
         * @member {string} position
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.position = "";

        /**
         * UserBase channelId.
         * @member {string} channelId
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.channelId = "";

        /**
         * UserBase friendStatus.
         * @member {number} friendStatus
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.friendStatus = 0;

        /**
         * UserBase charmLv.
         * @member {number} charmLv
         * @memberof UserResult.UserBase
         * @instance
         */
        UserBase.prototype.charmLv = 0;

        /**
         * Decodes a UserBase message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.UserBase
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.UserBase} UserBase
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBase.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.UserBase();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.nickName = reader.string();
                    break;
                case 3:
                    message.logoTime = reader.int32();
                    break;
                case 4:
                    message.thirdIconurl = reader.string();
                    break;
                case 5:
                    message.headFrameId = reader.string();
                    break;
                case 6:
                    message.sex = reader.int32();
                    break;
                case 7:
                    message.age = reader.int32();
                    break;
                case 8:
                    message.vipLv = reader.int32();
                    break;
                case 9:
                    message.slogan = reader.string();
                    break;
                case 10:
                    message.contributeLv = reader.int32();
                    break;
                case 11:
                    message.position = reader.string();
                    break;
                case 12:
                    message.channelId = reader.string();
                    break;
                case 13:
                    message.friendStatus = reader.int32();
                    break;
                case 14:
                    message.charmLv = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            return message;
        };

        /**
         * Decodes a UserBase message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.UserBase
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.UserBase} UserBase
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBase.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserBase;
    })();

    UserResult.UserInfoList = (function() {

        /**
         * Properties of a UserInfoList.
         * @memberof UserResult
         * @interface IUserInfoList
         * @property {Array.<UserResult.IUserInfo>|null} [list] UserInfoList list
         */

        /**
         * Constructs a new UserInfoList.
         * @memberof UserResult
         * @classdesc Represents a UserInfoList.
         * @implements IUserInfoList
         * @constructor
         * @param {UserResult.IUserInfoList=} [properties] Properties to set
         */
        function UserInfoList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInfoList list.
         * @member {Array.<UserResult.IUserInfo>} list
         * @memberof UserResult.UserInfoList
         * @instance
         */
        UserInfoList.prototype.list = $util.emptyArray;

        /**
         * Decodes a UserInfoList message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.UserInfoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.UserInfoList} UserInfoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfoList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.UserInfoList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.UserResult.UserInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserInfoList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.UserInfoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.UserInfoList} UserInfoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfoList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserInfoList;
    })();

    UserResult.UserInfo = (function() {

        /**
         * Properties of a UserInfo.
         * @memberof UserResult
         * @interface IUserInfo
         * @property {string} userId UserInfo userId
         * @property {string|null} [nickName] UserInfo nickName
         * @property {number|null} [logoTime] UserInfo logoTime
         * @property {string|null} [thirdIconurl] UserInfo thirdIconurl
         * @property {string|null} [headFrameId] UserInfo headFrameId
         * @property {number|null} [sex] UserInfo sex
         * @property {number|null} [level] UserInfo level
         * @property {string|null} [phoneNum] UserInfo phoneNum
         * @property {number|null} [age] UserInfo age
         * @property {string|null} [slogan] UserInfo slogan
         * @property {string|null} [position] UserInfo position
         * @property {string|null} [constellation] UserInfo constellation
         * @property {string|null} [birthday] UserInfo birthday
         * @property {string|null} [banners] UserInfo banners
         * @property {number|null} [vipLv] UserInfo vipLv
         * @property {number|null} [charmLv] UserInfo charmLv
         * @property {number|Long|null} [charm] UserInfo charm
         * @property {number|null} [contributeLv] UserInfo contributeLv
         * @property {number|Long|null} [contribute] UserInfo contribute
         * @property {number|null} [goldShell] UserInfo goldShell
         * @property {number|null} [bindGoldShell] UserInfo bindGoldShell
         * @property {number|null} [myLoves] UserInfo myLoves
         * @property {number|null} [friends] UserInfo friends
         * @property {number|null} [friendStatus] UserInfo friendStatus
         * @property {string|null} [friendRemark] UserInfo friendRemark
         * @property {boolean|null} [hasCar] UserInfo hasCar
         * @property {boolean|null} [hasGift] UserInfo hasGift
         * @property {number|null} [momentNum] UserInfo momentNum
         * @property {boolean|null} [modifyTips] UserInfo modifyTips
         * @property {string|null} [roomId] UserInfo roomId
         * @property {string|null} [roomName] UserInfo roomName
         * @property {number|null} [roomType] UserInfo roomType
         * @property {number|null} [roomStatus] UserInfo roomStatus
         * @property {boolean|null} [followEnterRoom] UserInfo followEnterRoom
         * @property {boolean|null} [openTips] UserInfo openTips
         * @property {boolean|null} [shakeMicUp] UserInfo shakeMicUp
         * @property {boolean|null} [online] UserInfo online
         * @property {number|null} [lastLogoutTime] UserInfo lastLogoutTime
         * @property {boolean|null} [official] UserInfo official
         * @property {boolean|null} [invisible] UserInfo invisible
         * @property {number|Long|null} [totalLiveEarn] UserInfo totalLiveEarn
         * @property {number|Long|null} [dayLiveEarn] UserInfo dayLiveEarn
         * @property {number|Long|null} [balance] UserInfo balance
         * @property {number|null} [rabbitCoin] UserInfo rabbitCoin
         * @property {string|null} [carId] UserInfo carId
         * @property {string|null} [dialogFrameId] UserInfo dialogFrameId
         * @property {boolean|null} [isCertification] UserInfo isCertification
         * @property {boolean|null} [isNew] UserInfo isNew
         * @property {string|null} [familyId] UserInfo familyId
         * @property {number|null} [pullBlackStatus] UserInfo pullBlackStatus
         * @property {boolean|null} [updatedSex] UserInfo updatedSex
         * @property {number|null} [guardians] UserInfo guardians
         * @property {Array.<string>|null} [useMedals] UserInfo useMedals
         * @property {number|null} [roomLogoTime] UserInfo roomLogoTime
         * @property {UserResult.ICoordinate|null} [coordinate] UserInfo coordinate
         * @property {boolean|null} [isOpenLoveRing] UserInfo isOpenLoveRing
         * @property {boolean|null} [isGuardian] UserInfo isGuardian
         * @property {boolean|null} [isAcptMicInvt] UserInfo isAcptMicInvt
         * @property {number|null} [roomSubType] UserInfo roomSubType
         * @property {number|null} [matchmakerStatus] UserInfo matchmakerStatus
         * @property {boolean|null} [notFriendNeedAgree] UserInfo notFriendNeedAgree
         * @property {UserResult.IUserCpInfo|null} [cpInfo] UserInfo cpInfo
         * @property {boolean|null} [setPayPassword] UserInfo setPayPassword
         * @property {number|null} [beLikedNum] UserInfo beLikedNum
         */

        /**
         * Constructs a new UserInfo.
         * @memberof UserResult
         * @classdesc Represents a UserInfo.
         * @implements IUserInfo
         * @constructor
         * @param {UserResult.IUserInfo=} [properties] Properties to set
         */
        function UserInfo(properties) {
            this.useMedals = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInfo userId.
         * @member {string} userId
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.userId = "";

        /**
         * UserInfo nickName.
         * @member {string} nickName
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.nickName = "";

        /**
         * UserInfo logoTime.
         * @member {number} logoTime
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.logoTime = 0;

        /**
         * UserInfo thirdIconurl.
         * @member {string} thirdIconurl
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.thirdIconurl = "";

        /**
         * UserInfo headFrameId.
         * @member {string} headFrameId
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.headFrameId = "";

        /**
         * UserInfo sex.
         * @member {number} sex
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.sex = 0;

        /**
         * UserInfo level.
         * @member {number} level
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.level = 0;

        /**
         * UserInfo phoneNum.
         * @member {string} phoneNum
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.phoneNum = "";

        /**
         * UserInfo age.
         * @member {number} age
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.age = 0;

        /**
         * UserInfo slogan.
         * @member {string} slogan
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.slogan = "";

        /**
         * UserInfo position.
         * @member {string} position
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.position = "";

        /**
         * UserInfo constellation.
         * @member {string} constellation
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.constellation = "";

        /**
         * UserInfo birthday.
         * @member {string} birthday
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.birthday = "";

        /**
         * UserInfo banners.
         * @member {string} banners
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.banners = "";

        /**
         * UserInfo vipLv.
         * @member {number} vipLv
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.vipLv = 0;

        /**
         * UserInfo charmLv.
         * @member {number} charmLv
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.charmLv = 0;

        /**
         * UserInfo charm.
         * @member {number|Long} charm
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.charm = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserInfo contributeLv.
         * @member {number} contributeLv
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.contributeLv = 0;

        /**
         * UserInfo contribute.
         * @member {number|Long} contribute
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.contribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserInfo goldShell.
         * @member {number} goldShell
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.goldShell = 0;

        /**
         * UserInfo bindGoldShell.
         * @member {number} bindGoldShell
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.bindGoldShell = 0;

        /**
         * UserInfo myLoves.
         * @member {number} myLoves
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.myLoves = 0;

        /**
         * UserInfo friends.
         * @member {number} friends
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.friends = 0;

        /**
         * UserInfo friendStatus.
         * @member {number} friendStatus
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.friendStatus = 0;

        /**
         * UserInfo friendRemark.
         * @member {string} friendRemark
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.friendRemark = "";

        /**
         * UserInfo hasCar.
         * @member {boolean} hasCar
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.hasCar = false;

        /**
         * UserInfo hasGift.
         * @member {boolean} hasGift
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.hasGift = false;

        /**
         * UserInfo momentNum.
         * @member {number} momentNum
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.momentNum = 0;

        /**
         * UserInfo modifyTips.
         * @member {boolean} modifyTips
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.modifyTips = false;

        /**
         * UserInfo roomId.
         * @member {string} roomId
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.roomId = "";

        /**
         * UserInfo roomName.
         * @member {string} roomName
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.roomName = "";

        /**
         * UserInfo roomType.
         * @member {number} roomType
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.roomType = 0;

        /**
         * UserInfo roomStatus.
         * @member {number} roomStatus
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.roomStatus = 0;

        /**
         * UserInfo followEnterRoom.
         * @member {boolean} followEnterRoom
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.followEnterRoom = false;

        /**
         * UserInfo openTips.
         * @member {boolean} openTips
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.openTips = false;

        /**
         * UserInfo shakeMicUp.
         * @member {boolean} shakeMicUp
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.shakeMicUp = false;

        /**
         * UserInfo online.
         * @member {boolean} online
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.online = false;

        /**
         * UserInfo lastLogoutTime.
         * @member {number} lastLogoutTime
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.lastLogoutTime = 0;

        /**
         * UserInfo official.
         * @member {boolean} official
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.official = false;

        /**
         * UserInfo invisible.
         * @member {boolean} invisible
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.invisible = false;

        /**
         * UserInfo totalLiveEarn.
         * @member {number|Long} totalLiveEarn
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.totalLiveEarn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserInfo dayLiveEarn.
         * @member {number|Long} dayLiveEarn
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.dayLiveEarn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserInfo balance.
         * @member {number|Long} balance
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserInfo rabbitCoin.
         * @member {number} rabbitCoin
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.rabbitCoin = 0;

        /**
         * UserInfo carId.
         * @member {string} carId
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.carId = "";

        /**
         * UserInfo dialogFrameId.
         * @member {string} dialogFrameId
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.dialogFrameId = "";

        /**
         * UserInfo isCertification.
         * @member {boolean} isCertification
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.isCertification = false;

        /**
         * UserInfo isNew.
         * @member {boolean} isNew
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.isNew = false;

        /**
         * UserInfo familyId.
         * @member {string} familyId
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.familyId = "";

        /**
         * UserInfo pullBlackStatus.
         * @member {number} pullBlackStatus
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.pullBlackStatus = 0;

        /**
         * UserInfo updatedSex.
         * @member {boolean} updatedSex
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.updatedSex = false;

        /**
         * UserInfo guardians.
         * @member {number} guardians
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.guardians = 0;

        /**
         * UserInfo useMedals.
         * @member {Array.<string>} useMedals
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.useMedals = $util.emptyArray;

        /**
         * UserInfo roomLogoTime.
         * @member {number} roomLogoTime
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.roomLogoTime = 0;

        /**
         * UserInfo coordinate.
         * @member {UserResult.ICoordinate|null|undefined} coordinate
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.coordinate = null;

        /**
         * UserInfo isOpenLoveRing.
         * @member {boolean} isOpenLoveRing
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.isOpenLoveRing = false;

        /**
         * UserInfo isGuardian.
         * @member {boolean} isGuardian
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.isGuardian = false;

        /**
         * UserInfo isAcptMicInvt.
         * @member {boolean} isAcptMicInvt
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.isAcptMicInvt = false;

        /**
         * UserInfo roomSubType.
         * @member {number} roomSubType
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.roomSubType = 0;

        /**
         * UserInfo matchmakerStatus.
         * @member {number} matchmakerStatus
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.matchmakerStatus = 0;

        /**
         * UserInfo notFriendNeedAgree.
         * @member {boolean} notFriendNeedAgree
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.notFriendNeedAgree = false;

        /**
         * UserInfo cpInfo.
         * @member {UserResult.IUserCpInfo|null|undefined} cpInfo
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.cpInfo = null;

        /**
         * UserInfo setPayPassword.
         * @member {boolean} setPayPassword
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.setPayPassword = false;

        /**
         * UserInfo beLikedNum.
         * @member {number} beLikedNum
         * @memberof UserResult.UserInfo
         * @instance
         */
        UserInfo.prototype.beLikedNum = 0;

        /**
         * Decodes a UserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.UserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.nickName = reader.string();
                    break;
                case 3:
                    message.logoTime = reader.int32();
                    break;
                case 4:
                    message.thirdIconurl = reader.string();
                    break;
                case 5:
                    message.headFrameId = reader.string();
                    break;
                case 6:
                    message.sex = reader.int32();
                    break;
                case 7:
                    message.level = reader.int32();
                    break;
                case 8:
                    message.phoneNum = reader.string();
                    break;
                case 9:
                    message.age = reader.int32();
                    break;
                case 10:
                    message.slogan = reader.string();
                    break;
                case 11:
                    message.position = reader.string();
                    break;
                case 12:
                    message.constellation = reader.string();
                    break;
                case 13:
                    message.birthday = reader.string();
                    break;
                case 14:
                    message.banners = reader.string();
                    break;
                case 15:
                    message.vipLv = reader.int32();
                    break;
                case 16:
                    message.charmLv = reader.int32();
                    break;
                case 17:
                    message.charm = reader.int64();
                    break;
                case 18:
                    message.contributeLv = reader.int32();
                    break;
                case 19:
                    message.contribute = reader.int64();
                    break;
                case 20:
                    message.goldShell = reader.int32();
                    break;
                case 21:
                    message.bindGoldShell = reader.int32();
                    break;
                case 22:
                    message.myLoves = reader.int32();
                    break;
                case 23:
                    message.friends = reader.int32();
                    break;
                case 24:
                    message.friendStatus = reader.int32();
                    break;
                case 25:
                    message.friendRemark = reader.string();
                    break;
                case 26:
                    message.hasCar = reader.bool();
                    break;
                case 27:
                    message.hasGift = reader.bool();
                    break;
                case 28:
                    message.momentNum = reader.int32();
                    break;
                case 29:
                    message.modifyTips = reader.bool();
                    break;
                case 30:
                    message.roomId = reader.string();
                    break;
                case 31:
                    message.roomName = reader.string();
                    break;
                case 32:
                    message.roomType = reader.int32();
                    break;
                case 33:
                    message.roomStatus = reader.int32();
                    break;
                case 34:
                    message.followEnterRoom = reader.bool();
                    break;
                case 35:
                    message.openTips = reader.bool();
                    break;
                case 36:
                    message.shakeMicUp = reader.bool();
                    break;
                case 37:
                    message.online = reader.bool();
                    break;
                case 38:
                    message.lastLogoutTime = reader.int32();
                    break;
                case 39:
                    message.official = reader.bool();
                    break;
                case 40:
                    message.invisible = reader.bool();
                    break;
                case 41:
                    message.totalLiveEarn = reader.int64();
                    break;
                case 42:
                    message.dayLiveEarn = reader.int64();
                    break;
                case 43:
                    message.balance = reader.int64();
                    break;
                case 44:
                    message.rabbitCoin = reader.int32();
                    break;
                case 45:
                    message.carId = reader.string();
                    break;
                case 46:
                    message.dialogFrameId = reader.string();
                    break;
                case 47:
                    message.isCertification = reader.bool();
                    break;
                case 48:
                    message.isNew = reader.bool();
                    break;
                case 49:
                    message.familyId = reader.string();
                    break;
                case 50:
                    message.pullBlackStatus = reader.int32();
                    break;
                case 51:
                    message.updatedSex = reader.bool();
                    break;
                case 52:
                    message.guardians = reader.int32();
                    break;
                case 53:
                    if (!(message.useMedals && message.useMedals.length))
                        message.useMedals = [];
                    message.useMedals.push(reader.string());
                    break;
                case 54:
                    message.roomLogoTime = reader.int32();
                    break;
                case 55:
                    message.coordinate = $root.UserResult.Coordinate.decode(reader, reader.uint32());
                    break;
                case 56:
                    message.isOpenLoveRing = reader.bool();
                    break;
                case 57:
                    message.isGuardian = reader.bool();
                    break;
                case 58:
                    message.isAcptMicInvt = reader.bool();
                    break;
                case 59:
                    message.roomSubType = reader.int32();
                    break;
                case 60:
                    message.matchmakerStatus = reader.int32();
                    break;
                case 61:
                    message.notFriendNeedAgree = reader.bool();
                    break;
                case 62:
                    message.cpInfo = $root.UserResult.UserCpInfo.decode(reader, reader.uint32());
                    break;
                case 63:
                    message.setPayPassword = reader.bool();
                    break;
                case 64:
                    message.beLikedNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            return message;
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserInfo;
    })();

    UserResult.PersonPage = (function() {

        /**
         * Properties of a PersonPage.
         * @memberof UserResult
         * @interface IPersonPage
         * @property {UserResult.IUserInfo} info PersonPage info
         */

        /**
         * Constructs a new PersonPage.
         * @memberof UserResult
         * @classdesc Represents a PersonPage.
         * @implements IPersonPage
         * @constructor
         * @param {UserResult.IPersonPage=} [properties] Properties to set
         */
        function PersonPage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PersonPage info.
         * @member {UserResult.IUserInfo} info
         * @memberof UserResult.PersonPage
         * @instance
         */
        PersonPage.prototype.info = null;

        /**
         * Decodes a PersonPage message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.PersonPage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.PersonPage} PersonPage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PersonPage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.PersonPage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.info = $root.UserResult.UserInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("info"))
                throw $util.ProtocolError("missing required 'info'", { instance: message });
            return message;
        };

        /**
         * Decodes a PersonPage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.PersonPage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.PersonPage} PersonPage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PersonPage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return PersonPage;
    })();

    UserResult.FriendList = (function() {

        /**
         * Properties of a FriendList.
         * @memberof UserResult
         * @interface IFriendList
         * @property {Array.<string>|null} [userIds] FriendList userIds
         */

        /**
         * Constructs a new FriendList.
         * @memberof UserResult
         * @classdesc Represents a FriendList.
         * @implements IFriendList
         * @constructor
         * @param {UserResult.IFriendList=} [properties] Properties to set
         */
        function FriendList(properties) {
            this.userIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendList userIds.
         * @member {Array.<string>} userIds
         * @memberof UserResult.FriendList
         * @instance
         */
        FriendList.prototype.userIds = $util.emptyArray;

        /**
         * Decodes a FriendList message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.FriendList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.FriendList} FriendList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.FriendList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.userIds && message.userIds.length))
                        message.userIds = [];
                    message.userIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.FriendList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.FriendList} FriendList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FriendList;
    })();

    UserResult.LookMeList = (function() {

        /**
         * Properties of a LookMeList.
         * @memberof UserResult
         * @interface ILookMeList
         * @property {Array.<UserResult.ILookMeInfo>|null} [lookMeInfo] LookMeList lookMeInfo
         * @property {number|null} [lookNum] LookMeList lookNum
         */

        /**
         * Constructs a new LookMeList.
         * @memberof UserResult
         * @classdesc Represents a LookMeList.
         * @implements ILookMeList
         * @constructor
         * @param {UserResult.ILookMeList=} [properties] Properties to set
         */
        function LookMeList(properties) {
            this.lookMeInfo = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LookMeList lookMeInfo.
         * @member {Array.<UserResult.ILookMeInfo>} lookMeInfo
         * @memberof UserResult.LookMeList
         * @instance
         */
        LookMeList.prototype.lookMeInfo = $util.emptyArray;

        /**
         * LookMeList lookNum.
         * @member {number} lookNum
         * @memberof UserResult.LookMeList
         * @instance
         */
        LookMeList.prototype.lookNum = 0;

        /**
         * Decodes a LookMeList message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.LookMeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.LookMeList} LookMeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LookMeList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.LookMeList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.lookMeInfo && message.lookMeInfo.length))
                        message.lookMeInfo = [];
                    message.lookMeInfo.push($root.UserResult.LookMeInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.lookNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LookMeList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.LookMeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.LookMeList} LookMeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LookMeList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LookMeList;
    })();

    UserResult.LookMeInfo = (function() {

        /**
         * Properties of a LookMeInfo.
         * @memberof UserResult
         * @interface ILookMeInfo
         * @property {UserResult.IUserBase|null} [base] LookMeInfo base
         * @property {number|Long|null} [logTime] LookMeInfo logTime
         */

        /**
         * Constructs a new LookMeInfo.
         * @memberof UserResult
         * @classdesc Represents a LookMeInfo.
         * @implements ILookMeInfo
         * @constructor
         * @param {UserResult.ILookMeInfo=} [properties] Properties to set
         */
        function LookMeInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LookMeInfo base.
         * @member {UserResult.IUserBase|null|undefined} base
         * @memberof UserResult.LookMeInfo
         * @instance
         */
        LookMeInfo.prototype.base = null;

        /**
         * LookMeInfo logTime.
         * @member {number|Long} logTime
         * @memberof UserResult.LookMeInfo
         * @instance
         */
        LookMeInfo.prototype.logTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a LookMeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.LookMeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.LookMeInfo} LookMeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LookMeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.LookMeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.logTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LookMeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.LookMeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.LookMeInfo} LookMeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LookMeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LookMeInfo;
    })();

    UserResult.NewLookMe = (function() {

        /**
         * Properties of a NewLookMe.
         * @memberof UserResult
         * @interface INewLookMe
         * @property {number|null} [newLookNum] NewLookMe newLookNum
         * @property {string|null} [lastLookName] NewLookMe lastLookName
         * @property {number|Long|null} [logTime] NewLookMe logTime
         */

        /**
         * Constructs a new NewLookMe.
         * @memberof UserResult
         * @classdesc Represents a NewLookMe.
         * @implements INewLookMe
         * @constructor
         * @param {UserResult.INewLookMe=} [properties] Properties to set
         */
        function NewLookMe(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewLookMe newLookNum.
         * @member {number} newLookNum
         * @memberof UserResult.NewLookMe
         * @instance
         */
        NewLookMe.prototype.newLookNum = 0;

        /**
         * NewLookMe lastLookName.
         * @member {string} lastLookName
         * @memberof UserResult.NewLookMe
         * @instance
         */
        NewLookMe.prototype.lastLookName = "";

        /**
         * NewLookMe logTime.
         * @member {number|Long} logTime
         * @memberof UserResult.NewLookMe
         * @instance
         */
        NewLookMe.prototype.logTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a NewLookMe message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.NewLookMe
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.NewLookMe} NewLookMe
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewLookMe.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.NewLookMe();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.newLookNum = reader.int32();
                    break;
                case 2:
                    message.lastLookName = reader.string();
                    break;
                case 3:
                    message.logTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewLookMe message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.NewLookMe
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.NewLookMe} NewLookMe
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewLookMe.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return NewLookMe;
    })();

    UserResult.UserLevel = (function() {

        /**
         * Properties of a UserLevel.
         * @memberof UserResult
         * @interface IUserLevel
         * @property {string} userId UserLevel userId
         * @property {number|null} [level] UserLevel level
         * @property {number|null} [exp] UserLevel exp
         * @property {number|null} [iconLevel] UserLevel iconLevel
         * @property {number|null} [vipLv] UserLevel vipLv
         * @property {number|null} [charmLv] UserLevel charmLv
         * @property {number|Long|null} [charm] UserLevel charm
         * @property {number|null} [contributeLv] UserLevel contributeLv
         * @property {number|Long|null} [contribute] UserLevel contribute
         */

        /**
         * Constructs a new UserLevel.
         * @memberof UserResult
         * @classdesc Represents a UserLevel.
         * @implements IUserLevel
         * @constructor
         * @param {UserResult.IUserLevel=} [properties] Properties to set
         */
        function UserLevel(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserLevel userId.
         * @member {string} userId
         * @memberof UserResult.UserLevel
         * @instance
         */
        UserLevel.prototype.userId = "";

        /**
         * UserLevel level.
         * @member {number} level
         * @memberof UserResult.UserLevel
         * @instance
         */
        UserLevel.prototype.level = 0;

        /**
         * UserLevel exp.
         * @member {number} exp
         * @memberof UserResult.UserLevel
         * @instance
         */
        UserLevel.prototype.exp = 0;

        /**
         * UserLevel iconLevel.
         * @member {number} iconLevel
         * @memberof UserResult.UserLevel
         * @instance
         */
        UserLevel.prototype.iconLevel = 0;

        /**
         * UserLevel vipLv.
         * @member {number} vipLv
         * @memberof UserResult.UserLevel
         * @instance
         */
        UserLevel.prototype.vipLv = 0;

        /**
         * UserLevel charmLv.
         * @member {number} charmLv
         * @memberof UserResult.UserLevel
         * @instance
         */
        UserLevel.prototype.charmLv = 0;

        /**
         * UserLevel charm.
         * @member {number|Long} charm
         * @memberof UserResult.UserLevel
         * @instance
         */
        UserLevel.prototype.charm = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserLevel contributeLv.
         * @member {number} contributeLv
         * @memberof UserResult.UserLevel
         * @instance
         */
        UserLevel.prototype.contributeLv = 0;

        /**
         * UserLevel contribute.
         * @member {number|Long} contribute
         * @memberof UserResult.UserLevel
         * @instance
         */
        UserLevel.prototype.contribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a UserLevel message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.UserLevel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.UserLevel} UserLevel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserLevel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.UserLevel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.level = reader.int32();
                    break;
                case 3:
                    message.exp = reader.int32();
                    break;
                case 4:
                    message.iconLevel = reader.int32();
                    break;
                case 5:
                    message.vipLv = reader.int32();
                    break;
                case 6:
                    message.charmLv = reader.int32();
                    break;
                case 7:
                    message.charm = reader.int64();
                    break;
                case 8:
                    message.contributeLv = reader.int32();
                    break;
                case 9:
                    message.contribute = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            return message;
        };

        /**
         * Decodes a UserLevel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.UserLevel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.UserLevel} UserLevel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserLevel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserLevel;
    })();

    UserResult.UpdateAttributes = (function() {

        /**
         * Properties of an UpdateAttributes.
         * @memberof UserResult
         * @interface IUpdateAttributes
         * @property {Array.<number>|null} [attrIds] UpdateAttributes attrIds
         * @property {Array.<number|Long>|null} [attrValues] UpdateAttributes attrValues
         */

        /**
         * Constructs a new UpdateAttributes.
         * @memberof UserResult
         * @classdesc Represents an UpdateAttributes.
         * @implements IUpdateAttributes
         * @constructor
         * @param {UserResult.IUpdateAttributes=} [properties] Properties to set
         */
        function UpdateAttributes(properties) {
            this.attrIds = [];
            this.attrValues = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateAttributes attrIds.
         * @member {Array.<number>} attrIds
         * @memberof UserResult.UpdateAttributes
         * @instance
         */
        UpdateAttributes.prototype.attrIds = $util.emptyArray;

        /**
         * UpdateAttributes attrValues.
         * @member {Array.<number|Long>} attrValues
         * @memberof UserResult.UpdateAttributes
         * @instance
         */
        UpdateAttributes.prototype.attrValues = $util.emptyArray;

        /**
         * Decodes an UpdateAttributes message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.UpdateAttributes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.UpdateAttributes} UpdateAttributes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAttributes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.UpdateAttributes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.attrIds && message.attrIds.length))
                        message.attrIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.attrIds.push(reader.int32());
                    } else
                        message.attrIds.push(reader.int32());
                    break;
                case 2:
                    if (!(message.attrValues && message.attrValues.length))
                        message.attrValues = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.attrValues.push(reader.int64());
                    } else
                        message.attrValues.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateAttributes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.UpdateAttributes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.UpdateAttributes} UpdateAttributes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAttributes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UpdateAttributes;
    })();

    UserResult.UserServiceBroadcast = (function() {

        /**
         * Properties of a UserServiceBroadcast.
         * @memberof UserResult
         * @interface IUserServiceBroadcast
         * @property {number} serviceType UserServiceBroadcast serviceType
         * @property {string} data UserServiceBroadcast data
         */

        /**
         * Constructs a new UserServiceBroadcast.
         * @memberof UserResult
         * @classdesc Represents a UserServiceBroadcast.
         * @implements IUserServiceBroadcast
         * @constructor
         * @param {UserResult.IUserServiceBroadcast=} [properties] Properties to set
         */
        function UserServiceBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserServiceBroadcast serviceType.
         * @member {number} serviceType
         * @memberof UserResult.UserServiceBroadcast
         * @instance
         */
        UserServiceBroadcast.prototype.serviceType = 0;

        /**
         * UserServiceBroadcast data.
         * @member {string} data
         * @memberof UserResult.UserServiceBroadcast
         * @instance
         */
        UserServiceBroadcast.prototype.data = "";

        /**
         * Decodes a UserServiceBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.UserServiceBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.UserServiceBroadcast} UserServiceBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserServiceBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.UserServiceBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serviceType = reader.int32();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("serviceType"))
                throw $util.ProtocolError("missing required 'serviceType'", { instance: message });
            if (!message.hasOwnProperty("data"))
                throw $util.ProtocolError("missing required 'data'", { instance: message });
            return message;
        };

        /**
         * Decodes a UserServiceBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.UserServiceBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.UserServiceBroadcast} UserServiceBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserServiceBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserServiceBroadcast;
    })();

    UserResult.OnlineUserList = (function() {

        /**
         * Properties of an OnlineUserList.
         * @memberof UserResult
         * @interface IOnlineUserList
         * @property {Array.<UserResult.IOnlineuserInfo>|null} [list] OnlineUserList list
         */

        /**
         * Constructs a new OnlineUserList.
         * @memberof UserResult
         * @classdesc Represents an OnlineUserList.
         * @implements IOnlineUserList
         * @constructor
         * @param {UserResult.IOnlineUserList=} [properties] Properties to set
         */
        function OnlineUserList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OnlineUserList list.
         * @member {Array.<UserResult.IOnlineuserInfo>} list
         * @memberof UserResult.OnlineUserList
         * @instance
         */
        OnlineUserList.prototype.list = $util.emptyArray;

        /**
         * Decodes an OnlineUserList message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.OnlineUserList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.OnlineUserList} OnlineUserList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlineUserList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.OnlineUserList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.UserResult.OnlineuserInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OnlineUserList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.OnlineUserList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.OnlineUserList} OnlineUserList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlineUserList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return OnlineUserList;
    })();

    UserResult.OnlineuserInfo = (function() {

        /**
         * Properties of an OnlineuserInfo.
         * @memberof UserResult
         * @interface IOnlineuserInfo
         * @property {UserResult.IUserBase} base OnlineuserInfo base
         * @property {number|Long} loginTime OnlineuserInfo loginTime
         * @property {string|null} [position] OnlineuserInfo position
         * @property {string|null} [slogan] OnlineuserInfo slogan
         * @property {string|null} [roomId] OnlineuserInfo roomId
         * @property {number|null} [roomStatus] OnlineuserInfo roomStatus
         * @property {string|null} [constellation] OnlineuserInfo constellation
         * @property {number|null} [onlineType] OnlineuserInfo onlineType
         * @property {number|null} [roomType] OnlineuserInfo roomType
         * @property {string|null} [roomName] OnlineuserInfo roomName
         * @property {number|null} [friendStatus] OnlineuserInfo friendStatus
         */

        /**
         * Constructs a new OnlineuserInfo.
         * @memberof UserResult
         * @classdesc Represents an OnlineuserInfo.
         * @implements IOnlineuserInfo
         * @constructor
         * @param {UserResult.IOnlineuserInfo=} [properties] Properties to set
         */
        function OnlineuserInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OnlineuserInfo base.
         * @member {UserResult.IUserBase} base
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.base = null;

        /**
         * OnlineuserInfo loginTime.
         * @member {number|Long} loginTime
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.loginTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OnlineuserInfo position.
         * @member {string} position
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.position = "";

        /**
         * OnlineuserInfo slogan.
         * @member {string} slogan
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.slogan = "";

        /**
         * OnlineuserInfo roomId.
         * @member {string} roomId
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.roomId = "";

        /**
         * OnlineuserInfo roomStatus.
         * @member {number} roomStatus
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.roomStatus = 0;

        /**
         * OnlineuserInfo constellation.
         * @member {string} constellation
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.constellation = "";

        /**
         * OnlineuserInfo onlineType.
         * @member {number} onlineType
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.onlineType = 0;

        /**
         * OnlineuserInfo roomType.
         * @member {number} roomType
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.roomType = 0;

        /**
         * OnlineuserInfo roomName.
         * @member {string} roomName
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.roomName = "";

        /**
         * OnlineuserInfo friendStatus.
         * @member {number} friendStatus
         * @memberof UserResult.OnlineuserInfo
         * @instance
         */
        OnlineuserInfo.prototype.friendStatus = 0;

        /**
         * Decodes an OnlineuserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.OnlineuserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.OnlineuserInfo} OnlineuserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlineuserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.OnlineuserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.loginTime = reader.int64();
                    break;
                case 3:
                    message.position = reader.string();
                    break;
                case 4:
                    message.slogan = reader.string();
                    break;
                case 5:
                    message.roomId = reader.string();
                    break;
                case 6:
                    message.roomStatus = reader.int32();
                    break;
                case 7:
                    message.constellation = reader.string();
                    break;
                case 8:
                    message.onlineType = reader.int32();
                    break;
                case 9:
                    message.roomType = reader.int32();
                    break;
                case 10:
                    message.roomName = reader.string();
                    break;
                case 11:
                    message.friendStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("base"))
                throw $util.ProtocolError("missing required 'base'", { instance: message });
            if (!message.hasOwnProperty("loginTime"))
                throw $util.ProtocolError("missing required 'loginTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an OnlineuserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.OnlineuserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.OnlineuserInfo} OnlineuserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlineuserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return OnlineuserInfo;
    })();

    UserResult.StrangerMsg = (function() {

        /**
         * Properties of a StrangerMsg.
         * @memberof UserResult
         * @interface IStrangerMsg
         * @property {boolean} canSendMsg StrangerMsg canSendMsg
         * @property {number} strangerCount StrangerMsg strangerCount
         */

        /**
         * Constructs a new StrangerMsg.
         * @memberof UserResult
         * @classdesc Represents a StrangerMsg.
         * @implements IStrangerMsg
         * @constructor
         * @param {UserResult.IStrangerMsg=} [properties] Properties to set
         */
        function StrangerMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StrangerMsg canSendMsg.
         * @member {boolean} canSendMsg
         * @memberof UserResult.StrangerMsg
         * @instance
         */
        StrangerMsg.prototype.canSendMsg = false;

        /**
         * StrangerMsg strangerCount.
         * @member {number} strangerCount
         * @memberof UserResult.StrangerMsg
         * @instance
         */
        StrangerMsg.prototype.strangerCount = 0;

        /**
         * Decodes a StrangerMsg message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.StrangerMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.StrangerMsg} StrangerMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StrangerMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.StrangerMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.canSendMsg = reader.bool();
                    break;
                case 2:
                    message.strangerCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("canSendMsg"))
                throw $util.ProtocolError("missing required 'canSendMsg'", { instance: message });
            if (!message.hasOwnProperty("strangerCount"))
                throw $util.ProtocolError("missing required 'strangerCount'", { instance: message });
            return message;
        };

        /**
         * Decodes a StrangerMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.StrangerMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.StrangerMsg} StrangerMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StrangerMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return StrangerMsg;
    })();

    UserResult.StrangerInfo = (function() {

        /**
         * Properties of a StrangerInfo.
         * @memberof UserResult
         * @interface IStrangerInfo
         * @property {Array.<UserResult.IStrangerBase>|null} [base] StrangerInfo base
         */

        /**
         * Constructs a new StrangerInfo.
         * @memberof UserResult
         * @classdesc Represents a StrangerInfo.
         * @implements IStrangerInfo
         * @constructor
         * @param {UserResult.IStrangerInfo=} [properties] Properties to set
         */
        function StrangerInfo(properties) {
            this.base = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StrangerInfo base.
         * @member {Array.<UserResult.IStrangerBase>} base
         * @memberof UserResult.StrangerInfo
         * @instance
         */
        StrangerInfo.prototype.base = $util.emptyArray;

        /**
         * Decodes a StrangerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.StrangerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.StrangerInfo} StrangerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StrangerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.StrangerInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.base && message.base.length))
                        message.base = [];
                    message.base.push($root.UserResult.StrangerBase.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StrangerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.StrangerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.StrangerInfo} StrangerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StrangerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return StrangerInfo;
    })();

    UserResult.StrangerBase = (function() {

        /**
         * Properties of a StrangerBase.
         * @memberof UserResult
         * @interface IStrangerBase
         * @property {string} userId StrangerBase userId
         * @property {string|null} [nickName] StrangerBase nickName
         * @property {number|null} [logoTime] StrangerBase logoTime
         * @property {string|null} [thirdIconurl] StrangerBase thirdIconurl
         * @property {number|Long|null} [charm] StrangerBase charm
         * @property {number|Long|null} [contribute] StrangerBase contribute
         * @property {number|null} [count] StrangerBase count
         * @property {string|null} [headFrameId] StrangerBase headFrameId
         * @property {number|null} [sex] StrangerBase sex
         */

        /**
         * Constructs a new StrangerBase.
         * @memberof UserResult
         * @classdesc Represents a StrangerBase.
         * @implements IStrangerBase
         * @constructor
         * @param {UserResult.IStrangerBase=} [properties] Properties to set
         */
        function StrangerBase(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StrangerBase userId.
         * @member {string} userId
         * @memberof UserResult.StrangerBase
         * @instance
         */
        StrangerBase.prototype.userId = "";

        /**
         * StrangerBase nickName.
         * @member {string} nickName
         * @memberof UserResult.StrangerBase
         * @instance
         */
        StrangerBase.prototype.nickName = "";

        /**
         * StrangerBase logoTime.
         * @member {number} logoTime
         * @memberof UserResult.StrangerBase
         * @instance
         */
        StrangerBase.prototype.logoTime = 0;

        /**
         * StrangerBase thirdIconurl.
         * @member {string} thirdIconurl
         * @memberof UserResult.StrangerBase
         * @instance
         */
        StrangerBase.prototype.thirdIconurl = "";

        /**
         * StrangerBase charm.
         * @member {number|Long} charm
         * @memberof UserResult.StrangerBase
         * @instance
         */
        StrangerBase.prototype.charm = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StrangerBase contribute.
         * @member {number|Long} contribute
         * @memberof UserResult.StrangerBase
         * @instance
         */
        StrangerBase.prototype.contribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StrangerBase count.
         * @member {number} count
         * @memberof UserResult.StrangerBase
         * @instance
         */
        StrangerBase.prototype.count = 0;

        /**
         * StrangerBase headFrameId.
         * @member {string} headFrameId
         * @memberof UserResult.StrangerBase
         * @instance
         */
        StrangerBase.prototype.headFrameId = "";

        /**
         * StrangerBase sex.
         * @member {number} sex
         * @memberof UserResult.StrangerBase
         * @instance
         */
        StrangerBase.prototype.sex = 0;

        /**
         * Decodes a StrangerBase message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.StrangerBase
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.StrangerBase} StrangerBase
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StrangerBase.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.StrangerBase();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.nickName = reader.string();
                    break;
                case 3:
                    message.logoTime = reader.int32();
                    break;
                case 4:
                    message.thirdIconurl = reader.string();
                    break;
                case 5:
                    message.charm = reader.int64();
                    break;
                case 6:
                    message.contribute = reader.int64();
                    break;
                case 7:
                    message.count = reader.int32();
                    break;
                case 8:
                    message.headFrameId = reader.string();
                    break;
                case 9:
                    message.sex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            return message;
        };

        /**
         * Decodes a StrangerBase message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.StrangerBase
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.StrangerBase} StrangerBase
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StrangerBase.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return StrangerBase;
    })();

    UserResult.DeviceConfigInfo = (function() {

        /**
         * Properties of a DeviceConfigInfo.
         * @memberof UserResult
         * @interface IDeviceConfigInfo
         * @property {boolean|null} [liveSuspend] DeviceConfigInfo liveSuspend
         * @property {number|null} [voiceSuspend] DeviceConfigInfo voiceSuspend
         * @property {boolean|null} [openLocation] DeviceConfigInfo openLocation
         * @property {boolean|null} [newMsgNotic] DeviceConfigInfo newMsgNotic
         * @property {boolean|null} [strangerNews] DeviceConfigInfo strangerNews
         */

        /**
         * Constructs a new DeviceConfigInfo.
         * @memberof UserResult
         * @classdesc Represents a DeviceConfigInfo.
         * @implements IDeviceConfigInfo
         * @constructor
         * @param {UserResult.IDeviceConfigInfo=} [properties] Properties to set
         */
        function DeviceConfigInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceConfigInfo liveSuspend.
         * @member {boolean} liveSuspend
         * @memberof UserResult.DeviceConfigInfo
         * @instance
         */
        DeviceConfigInfo.prototype.liveSuspend = false;

        /**
         * DeviceConfigInfo voiceSuspend.
         * @member {number} voiceSuspend
         * @memberof UserResult.DeviceConfigInfo
         * @instance
         */
        DeviceConfigInfo.prototype.voiceSuspend = 0;

        /**
         * DeviceConfigInfo openLocation.
         * @member {boolean} openLocation
         * @memberof UserResult.DeviceConfigInfo
         * @instance
         */
        DeviceConfigInfo.prototype.openLocation = false;

        /**
         * DeviceConfigInfo newMsgNotic.
         * @member {boolean} newMsgNotic
         * @memberof UserResult.DeviceConfigInfo
         * @instance
         */
        DeviceConfigInfo.prototype.newMsgNotic = false;

        /**
         * DeviceConfigInfo strangerNews.
         * @member {boolean} strangerNews
         * @memberof UserResult.DeviceConfigInfo
         * @instance
         */
        DeviceConfigInfo.prototype.strangerNews = false;

        /**
         * Decodes a DeviceConfigInfo message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.DeviceConfigInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.DeviceConfigInfo} DeviceConfigInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceConfigInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.DeviceConfigInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.liveSuspend = reader.bool();
                    break;
                case 2:
                    message.voiceSuspend = reader.int32();
                    break;
                case 3:
                    message.openLocation = reader.bool();
                    break;
                case 4:
                    message.newMsgNotic = reader.bool();
                    break;
                case 5:
                    message.strangerNews = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceConfigInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.DeviceConfigInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.DeviceConfigInfo} DeviceConfigInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceConfigInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return DeviceConfigInfo;
    })();

    UserResult.BlackInfoList = (function() {

        /**
         * Properties of a BlackInfoList.
         * @memberof UserResult
         * @interface IBlackInfoList
         * @property {Array.<UserResult.IUserBase>|null} [list] BlackInfoList list
         */

        /**
         * Constructs a new BlackInfoList.
         * @memberof UserResult
         * @classdesc Represents a BlackInfoList.
         * @implements IBlackInfoList
         * @constructor
         * @param {UserResult.IBlackInfoList=} [properties] Properties to set
         */
        function BlackInfoList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlackInfoList list.
         * @member {Array.<UserResult.IUserBase>} list
         * @memberof UserResult.BlackInfoList
         * @instance
         */
        BlackInfoList.prototype.list = $util.emptyArray;

        /**
         * Decodes a BlackInfoList message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.BlackInfoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.BlackInfoList} BlackInfoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlackInfoList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.BlackInfoList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.UserResult.UserBase.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlackInfoList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.BlackInfoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.BlackInfoList} BlackInfoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlackInfoList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return BlackInfoList;
    })();

    UserResult.Coordinate = (function() {

        /**
         * Properties of a Coordinate.
         * @memberof UserResult
         * @interface ICoordinate
         * @property {number} lng Coordinate lng
         * @property {number} lat Coordinate lat
         * @property {string} cityCode Coordinate cityCode
         */

        /**
         * Constructs a new Coordinate.
         * @memberof UserResult
         * @classdesc Represents a Coordinate.
         * @implements ICoordinate
         * @constructor
         * @param {UserResult.ICoordinate=} [properties] Properties to set
         */
        function Coordinate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Coordinate lng.
         * @member {number} lng
         * @memberof UserResult.Coordinate
         * @instance
         */
        Coordinate.prototype.lng = 0;

        /**
         * Coordinate lat.
         * @member {number} lat
         * @memberof UserResult.Coordinate
         * @instance
         */
        Coordinate.prototype.lat = 0;

        /**
         * Coordinate cityCode.
         * @member {string} cityCode
         * @memberof UserResult.Coordinate
         * @instance
         */
        Coordinate.prototype.cityCode = "";

        /**
         * Decodes a Coordinate message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.Coordinate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.Coordinate} Coordinate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coordinate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.Coordinate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lng = reader.double();
                    break;
                case 2:
                    message.lat = reader.double();
                    break;
                case 3:
                    message.cityCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("lng"))
                throw $util.ProtocolError("missing required 'lng'", { instance: message });
            if (!message.hasOwnProperty("lat"))
                throw $util.ProtocolError("missing required 'lat'", { instance: message });
            if (!message.hasOwnProperty("cityCode"))
                throw $util.ProtocolError("missing required 'cityCode'", { instance: message });
            return message;
        };

        /**
         * Decodes a Coordinate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.Coordinate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.Coordinate} Coordinate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coordinate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Coordinate;
    })();

    UserResult.VideoDateLogList = (function() {

        /**
         * Properties of a VideoDateLogList.
         * @memberof UserResult
         * @interface IVideoDateLogList
         * @property {Array.<UserResult.IVideoDateLog>|null} [logInfo] VideoDateLogList logInfo
         */

        /**
         * Constructs a new VideoDateLogList.
         * @memberof UserResult
         * @classdesc Represents a VideoDateLogList.
         * @implements IVideoDateLogList
         * @constructor
         * @param {UserResult.IVideoDateLogList=} [properties] Properties to set
         */
        function VideoDateLogList(properties) {
            this.logInfo = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoDateLogList logInfo.
         * @member {Array.<UserResult.IVideoDateLog>} logInfo
         * @memberof UserResult.VideoDateLogList
         * @instance
         */
        VideoDateLogList.prototype.logInfo = $util.emptyArray;

        /**
         * Decodes a VideoDateLogList message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.VideoDateLogList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.VideoDateLogList} VideoDateLogList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoDateLogList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.VideoDateLogList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logInfo && message.logInfo.length))
                        message.logInfo = [];
                    message.logInfo.push($root.UserResult.VideoDateLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoDateLogList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.VideoDateLogList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.VideoDateLogList} VideoDateLogList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoDateLogList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return VideoDateLogList;
    })();

    UserResult.VideoDateLog = (function() {

        /**
         * Properties of a VideoDateLog.
         * @memberof UserResult
         * @interface IVideoDateLog
         * @property {string} id VideoDateLog id
         * @property {UserResult.IUserBase|null} [anchorInfo] VideoDateLog anchorInfo
         * @property {UserResult.IUserBase|null} [dateUserInfo] VideoDateLog dateUserInfo
         * @property {string|null} [logTime] VideoDateLog logTime
         */

        /**
         * Constructs a new VideoDateLog.
         * @memberof UserResult
         * @classdesc Represents a VideoDateLog.
         * @implements IVideoDateLog
         * @constructor
         * @param {UserResult.IVideoDateLog=} [properties] Properties to set
         */
        function VideoDateLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoDateLog id.
         * @member {string} id
         * @memberof UserResult.VideoDateLog
         * @instance
         */
        VideoDateLog.prototype.id = "";

        /**
         * VideoDateLog anchorInfo.
         * @member {UserResult.IUserBase|null|undefined} anchorInfo
         * @memberof UserResult.VideoDateLog
         * @instance
         */
        VideoDateLog.prototype.anchorInfo = null;

        /**
         * VideoDateLog dateUserInfo.
         * @member {UserResult.IUserBase|null|undefined} dateUserInfo
         * @memberof UserResult.VideoDateLog
         * @instance
         */
        VideoDateLog.prototype.dateUserInfo = null;

        /**
         * VideoDateLog logTime.
         * @member {string} logTime
         * @memberof UserResult.VideoDateLog
         * @instance
         */
        VideoDateLog.prototype.logTime = "";

        /**
         * Decodes a VideoDateLog message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.VideoDateLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.VideoDateLog} VideoDateLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoDateLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.VideoDateLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.anchorInfo = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.dateUserInfo = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.logTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a VideoDateLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.VideoDateLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.VideoDateLog} VideoDateLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoDateLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return VideoDateLog;
    })();

    UserResult.UserDetail = (function() {

        /**
         * Properties of a UserDetail.
         * @memberof UserResult
         * @interface IUserDetail
         * @property {string} userId UserDetail userId
         * @property {string|null} [location] UserDetail location
         * @property {string|null} [height] UserDetail height
         * @property {string|null} [education] UserDetail education
         * @property {string|null} [career] UserDetail career
         * @property {string|null} [livewith] UserDetail livewith
         * @property {string|null} [cohabit] UserDetail cohabit
         * @property {string|null} [tlocation] UserDetail tlocation
         * @property {string|null} [tage] UserDetail tage
         * @property {string|null} [theight] UserDetail theight
         * @property {string|null} [teducation] UserDetail teducation
         * @property {string|null} [tsalary] UserDetail tsalary
         * @property {UserResult.IUserCpInfo|null} [cpInfo] UserDetail cpInfo
         */

        /**
         * Constructs a new UserDetail.
         * @memberof UserResult
         * @classdesc Represents a UserDetail.
         * @implements IUserDetail
         * @constructor
         * @param {UserResult.IUserDetail=} [properties] Properties to set
         */
        function UserDetail(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserDetail userId.
         * @member {string} userId
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.userId = "";

        /**
         * UserDetail location.
         * @member {string} location
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.location = "";

        /**
         * UserDetail height.
         * @member {string} height
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.height = "";

        /**
         * UserDetail education.
         * @member {string} education
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.education = "";

        /**
         * UserDetail career.
         * @member {string} career
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.career = "";

        /**
         * UserDetail livewith.
         * @member {string} livewith
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.livewith = "";

        /**
         * UserDetail cohabit.
         * @member {string} cohabit
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.cohabit = "";

        /**
         * UserDetail tlocation.
         * @member {string} tlocation
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.tlocation = "";

        /**
         * UserDetail tage.
         * @member {string} tage
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.tage = "";

        /**
         * UserDetail theight.
         * @member {string} theight
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.theight = "";

        /**
         * UserDetail teducation.
         * @member {string} teducation
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.teducation = "";

        /**
         * UserDetail tsalary.
         * @member {string} tsalary
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.tsalary = "";

        /**
         * UserDetail cpInfo.
         * @member {UserResult.IUserCpInfo|null|undefined} cpInfo
         * @memberof UserResult.UserDetail
         * @instance
         */
        UserDetail.prototype.cpInfo = null;

        /**
         * Decodes a UserDetail message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.UserDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.UserDetail} UserDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserDetail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.UserDetail();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.location = reader.string();
                    break;
                case 3:
                    message.height = reader.string();
                    break;
                case 4:
                    message.education = reader.string();
                    break;
                case 5:
                    message.career = reader.string();
                    break;
                case 6:
                    message.livewith = reader.string();
                    break;
                case 7:
                    message.cohabit = reader.string();
                    break;
                case 8:
                    message.tlocation = reader.string();
                    break;
                case 9:
                    message.tage = reader.string();
                    break;
                case 10:
                    message.theight = reader.string();
                    break;
                case 11:
                    message.teducation = reader.string();
                    break;
                case 12:
                    message.tsalary = reader.string();
                    break;
                case 13:
                    message.cpInfo = $root.UserResult.UserCpInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            return message;
        };

        /**
         * Decodes a UserDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.UserDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.UserDetail} UserDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserDetail;
    })();

    UserResult.UserCpInfo = (function() {

        /**
         * Properties of a UserCpInfo.
         * @memberof UserResult
         * @interface IUserCpInfo
         * @property {UserResult.IUserBase} base UserCpInfo base
         * @property {number|Long} cpValue UserCpInfo cpValue
         */

        /**
         * Constructs a new UserCpInfo.
         * @memberof UserResult
         * @classdesc Represents a UserCpInfo.
         * @implements IUserCpInfo
         * @constructor
         * @param {UserResult.IUserCpInfo=} [properties] Properties to set
         */
        function UserCpInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserCpInfo base.
         * @member {UserResult.IUserBase} base
         * @memberof UserResult.UserCpInfo
         * @instance
         */
        UserCpInfo.prototype.base = null;

        /**
         * UserCpInfo cpValue.
         * @member {number|Long} cpValue
         * @memberof UserResult.UserCpInfo
         * @instance
         */
        UserCpInfo.prototype.cpValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a UserCpInfo message from the specified reader or buffer.
         * @function decode
         * @memberof UserResult.UserCpInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserResult.UserCpInfo} UserCpInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCpInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserResult.UserCpInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.cpValue = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("base"))
                throw $util.ProtocolError("missing required 'base'", { instance: message });
            if (!message.hasOwnProperty("cpValue"))
                throw $util.ProtocolError("missing required 'cpValue'", { instance: message });
            return message;
        };

        /**
         * Decodes a UserCpInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserResult.UserCpInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserResult.UserCpInfo} UserCpInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCpInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserCpInfo;
    })();

    return UserResult;
})();

export const BroadcastResult = $root.BroadcastResult = (() => {

    /**
     * Namespace BroadcastResult.
     * @exports BroadcastResult
     * @namespace
     */
    const BroadcastResult = {};

    BroadcastResult.UpdateDataVersion = (function() {

        /**
         * Properties of an UpdateDataVersion.
         * @memberof BroadcastResult
         * @interface IUpdateDataVersion
         * @property {string} tableName UpdateDataVersion tableName
         * @property {number} version UpdateDataVersion version
         */

        /**
         * Constructs a new UpdateDataVersion.
         * @memberof BroadcastResult
         * @classdesc Represents an UpdateDataVersion.
         * @implements IUpdateDataVersion
         * @constructor
         * @param {BroadcastResult.IUpdateDataVersion=} [properties] Properties to set
         */
        function UpdateDataVersion(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateDataVersion tableName.
         * @member {string} tableName
         * @memberof BroadcastResult.UpdateDataVersion
         * @instance
         */
        UpdateDataVersion.prototype.tableName = "";

        /**
         * UpdateDataVersion version.
         * @member {number} version
         * @memberof BroadcastResult.UpdateDataVersion
         * @instance
         */
        UpdateDataVersion.prototype.version = 0;

        /**
         * Decodes an UpdateDataVersion message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.UpdateDataVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.UpdateDataVersion} UpdateDataVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateDataVersion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.UpdateDataVersion();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tableName = reader.string();
                    break;
                case 2:
                    message.version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("tableName"))
                throw $util.ProtocolError("missing required 'tableName'", { instance: message });
            if (!message.hasOwnProperty("version"))
                throw $util.ProtocolError("missing required 'version'", { instance: message });
            return message;
        };

        /**
         * Decodes an UpdateDataVersion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.UpdateDataVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.UpdateDataVersion} UpdateDataVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateDataVersion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UpdateDataVersion;
    })();

    BroadcastResult.UpdateUserInfo = (function() {

        /**
         * Properties of an UpdateUserInfo.
         * @memberof BroadcastResult
         * @interface IUpdateUserInfo
         * @property {string} userId UpdateUserInfo userId
         * @property {string} dataType UpdateUserInfo dataType
         * @property {string} value UpdateUserInfo value
         */

        /**
         * Constructs a new UpdateUserInfo.
         * @memberof BroadcastResult
         * @classdesc Represents an UpdateUserInfo.
         * @implements IUpdateUserInfo
         * @constructor
         * @param {BroadcastResult.IUpdateUserInfo=} [properties] Properties to set
         */
        function UpdateUserInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateUserInfo userId.
         * @member {string} userId
         * @memberof BroadcastResult.UpdateUserInfo
         * @instance
         */
        UpdateUserInfo.prototype.userId = "";

        /**
         * UpdateUserInfo dataType.
         * @member {string} dataType
         * @memberof BroadcastResult.UpdateUserInfo
         * @instance
         */
        UpdateUserInfo.prototype.dataType = "";

        /**
         * UpdateUserInfo value.
         * @member {string} value
         * @memberof BroadcastResult.UpdateUserInfo
         * @instance
         */
        UpdateUserInfo.prototype.value = "";

        /**
         * Decodes an UpdateUserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.UpdateUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.UpdateUserInfo} UpdateUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateUserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.UpdateUserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.dataType = reader.string();
                    break;
                case 3:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("dataType"))
                throw $util.ProtocolError("missing required 'dataType'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes an UpdateUserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.UpdateUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.UpdateUserInfo} UpdateUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateUserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UpdateUserInfo;
    })();

    BroadcastResult.SystemAction = (function() {

        /**
         * Properties of a SystemAction.
         * @memberof BroadcastResult
         * @interface ISystemAction
         * @property {number} state SystemAction state
         */

        /**
         * Constructs a new SystemAction.
         * @memberof BroadcastResult
         * @classdesc Represents a SystemAction.
         * @implements ISystemAction
         * @constructor
         * @param {BroadcastResult.ISystemAction=} [properties] Properties to set
         */
        function SystemAction(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SystemAction state.
         * @member {number} state
         * @memberof BroadcastResult.SystemAction
         * @instance
         */
        SystemAction.prototype.state = 0;

        /**
         * Decodes a SystemAction message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.SystemAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.SystemAction} SystemAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SystemAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.SystemAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("state"))
                throw $util.ProtocolError("missing required 'state'", { instance: message });
            return message;
        };

        /**
         * Decodes a SystemAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.SystemAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.SystemAction} SystemAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SystemAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SystemAction;
    })();

    BroadcastResult.UpdateFriends = (function() {

        /**
         * Properties of an UpdateFriends.
         * @memberof BroadcastResult
         * @interface IUpdateFriends
         * @property {number} friendsCount UpdateFriends friendsCount
         */

        /**
         * Constructs a new UpdateFriends.
         * @memberof BroadcastResult
         * @classdesc Represents an UpdateFriends.
         * @implements IUpdateFriends
         * @constructor
         * @param {BroadcastResult.IUpdateFriends=} [properties] Properties to set
         */
        function UpdateFriends(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateFriends friendsCount.
         * @member {number} friendsCount
         * @memberof BroadcastResult.UpdateFriends
         * @instance
         */
        UpdateFriends.prototype.friendsCount = 0;

        /**
         * Decodes an UpdateFriends message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.UpdateFriends
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.UpdateFriends} UpdateFriends
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateFriends.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.UpdateFriends();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.friendsCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("friendsCount"))
                throw $util.ProtocolError("missing required 'friendsCount'", { instance: message });
            return message;
        };

        /**
         * Decodes an UpdateFriends message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.UpdateFriends
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.UpdateFriends} UpdateFriends
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateFriends.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UpdateFriends;
    })();

    BroadcastResult.ResetDayData = (function() {

        /**
         * Properties of a ResetDayData.
         * @memberof BroadcastResult
         * @interface IResetDayData
         * @property {boolean} day ResetDayData day
         * @property {boolean} week ResetDayData week
         * @property {boolean} month ResetDayData month
         * @property {boolean|null} [hour] ResetDayData hour
         */

        /**
         * Constructs a new ResetDayData.
         * @memberof BroadcastResult
         * @classdesc Represents a ResetDayData.
         * @implements IResetDayData
         * @constructor
         * @param {BroadcastResult.IResetDayData=} [properties] Properties to set
         */
        function ResetDayData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResetDayData day.
         * @member {boolean} day
         * @memberof BroadcastResult.ResetDayData
         * @instance
         */
        ResetDayData.prototype.day = false;

        /**
         * ResetDayData week.
         * @member {boolean} week
         * @memberof BroadcastResult.ResetDayData
         * @instance
         */
        ResetDayData.prototype.week = false;

        /**
         * ResetDayData month.
         * @member {boolean} month
         * @memberof BroadcastResult.ResetDayData
         * @instance
         */
        ResetDayData.prototype.month = false;

        /**
         * ResetDayData hour.
         * @member {boolean} hour
         * @memberof BroadcastResult.ResetDayData
         * @instance
         */
        ResetDayData.prototype.hour = false;

        /**
         * Decodes a ResetDayData message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.ResetDayData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.ResetDayData} ResetDayData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetDayData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.ResetDayData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.day = reader.bool();
                    break;
                case 2:
                    message.week = reader.bool();
                    break;
                case 3:
                    message.month = reader.bool();
                    break;
                case 4:
                    message.hour = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("day"))
                throw $util.ProtocolError("missing required 'day'", { instance: message });
            if (!message.hasOwnProperty("week"))
                throw $util.ProtocolError("missing required 'week'", { instance: message });
            if (!message.hasOwnProperty("month"))
                throw $util.ProtocolError("missing required 'month'", { instance: message });
            return message;
        };

        /**
         * Decodes a ResetDayData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.ResetDayData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.ResetDayData} ResetDayData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetDayData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ResetDayData;
    })();

    BroadcastResult.ChangeContributeKing = (function() {

        /**
         * Properties of a ChangeContributeKing.
         * @memberof BroadcastResult
         * @interface IChangeContributeKing
         * @property {UserResult.IUserBase} base ChangeContributeKing base
         * @property {boolean} room ChangeContributeKing room
         */

        /**
         * Constructs a new ChangeContributeKing.
         * @memberof BroadcastResult
         * @classdesc Represents a ChangeContributeKing.
         * @implements IChangeContributeKing
         * @constructor
         * @param {BroadcastResult.IChangeContributeKing=} [properties] Properties to set
         */
        function ChangeContributeKing(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeContributeKing base.
         * @member {UserResult.IUserBase} base
         * @memberof BroadcastResult.ChangeContributeKing
         * @instance
         */
        ChangeContributeKing.prototype.base = null;

        /**
         * ChangeContributeKing room.
         * @member {boolean} room
         * @memberof BroadcastResult.ChangeContributeKing
         * @instance
         */
        ChangeContributeKing.prototype.room = false;

        /**
         * Decodes a ChangeContributeKing message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.ChangeContributeKing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.ChangeContributeKing} ChangeContributeKing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeContributeKing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.ChangeContributeKing();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.room = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("base"))
                throw $util.ProtocolError("missing required 'base'", { instance: message });
            if (!message.hasOwnProperty("room"))
                throw $util.ProtocolError("missing required 'room'", { instance: message });
            return message;
        };

        /**
         * Decodes a ChangeContributeKing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.ChangeContributeKing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.ChangeContributeKing} ChangeContributeKing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeContributeKing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ChangeContributeKing;
    })();

    BroadcastResult.ChangeCharmKing = (function() {

        /**
         * Properties of a ChangeCharmKing.
         * @memberof BroadcastResult
         * @interface IChangeCharmKing
         * @property {UserResult.IUserBase} base ChangeCharmKing base
         * @property {boolean} room ChangeCharmKing room
         */

        /**
         * Constructs a new ChangeCharmKing.
         * @memberof BroadcastResult
         * @classdesc Represents a ChangeCharmKing.
         * @implements IChangeCharmKing
         * @constructor
         * @param {BroadcastResult.IChangeCharmKing=} [properties] Properties to set
         */
        function ChangeCharmKing(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeCharmKing base.
         * @member {UserResult.IUserBase} base
         * @memberof BroadcastResult.ChangeCharmKing
         * @instance
         */
        ChangeCharmKing.prototype.base = null;

        /**
         * ChangeCharmKing room.
         * @member {boolean} room
         * @memberof BroadcastResult.ChangeCharmKing
         * @instance
         */
        ChangeCharmKing.prototype.room = false;

        /**
         * Decodes a ChangeCharmKing message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.ChangeCharmKing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.ChangeCharmKing} ChangeCharmKing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeCharmKing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.ChangeCharmKing();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.room = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("base"))
                throw $util.ProtocolError("missing required 'base'", { instance: message });
            if (!message.hasOwnProperty("room"))
                throw $util.ProtocolError("missing required 'room'", { instance: message });
            return message;
        };

        /**
         * Decodes a ChangeCharmKing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.ChangeCharmKing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.ChangeCharmKing} ChangeCharmKing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeCharmKing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ChangeCharmKing;
    })();

    BroadcastResult.PullBlackBroadcast = (function() {

        /**
         * Properties of a PullBlackBroadcast.
         * @memberof BroadcastResult
         * @interface IPullBlackBroadcast
         * @property {string} userId PullBlackBroadcast userId
         * @property {string} targetId PullBlackBroadcast targetId
         * @property {boolean} action PullBlackBroadcast action
         * @property {number} blackStatus PullBlackBroadcast blackStatus
         */

        /**
         * Constructs a new PullBlackBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a PullBlackBroadcast.
         * @implements IPullBlackBroadcast
         * @constructor
         * @param {BroadcastResult.IPullBlackBroadcast=} [properties] Properties to set
         */
        function PullBlackBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PullBlackBroadcast userId.
         * @member {string} userId
         * @memberof BroadcastResult.PullBlackBroadcast
         * @instance
         */
        PullBlackBroadcast.prototype.userId = "";

        /**
         * PullBlackBroadcast targetId.
         * @member {string} targetId
         * @memberof BroadcastResult.PullBlackBroadcast
         * @instance
         */
        PullBlackBroadcast.prototype.targetId = "";

        /**
         * PullBlackBroadcast action.
         * @member {boolean} action
         * @memberof BroadcastResult.PullBlackBroadcast
         * @instance
         */
        PullBlackBroadcast.prototype.action = false;

        /**
         * PullBlackBroadcast blackStatus.
         * @member {number} blackStatus
         * @memberof BroadcastResult.PullBlackBroadcast
         * @instance
         */
        PullBlackBroadcast.prototype.blackStatus = 0;

        /**
         * Decodes a PullBlackBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.PullBlackBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.PullBlackBroadcast} PullBlackBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PullBlackBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.PullBlackBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.action = reader.bool();
                    break;
                case 4:
                    message.blackStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            if (!message.hasOwnProperty("action"))
                throw $util.ProtocolError("missing required 'action'", { instance: message });
            if (!message.hasOwnProperty("blackStatus"))
                throw $util.ProtocolError("missing required 'blackStatus'", { instance: message });
            return message;
        };

        /**
         * Decodes a PullBlackBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.PullBlackBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.PullBlackBroadcast} PullBlackBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PullBlackBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return PullBlackBroadcast;
    })();

    BroadcastResult.UpdateFriend = (function() {

        /**
         * Properties of an UpdateFriend.
         * @memberof BroadcastResult
         * @interface IUpdateFriend
         * @property {string} userId UpdateFriend userId
         * @property {string} friendId UpdateFriend friendId
         * @property {boolean} action UpdateFriend action
         */

        /**
         * Constructs a new UpdateFriend.
         * @memberof BroadcastResult
         * @classdesc Represents an UpdateFriend.
         * @implements IUpdateFriend
         * @constructor
         * @param {BroadcastResult.IUpdateFriend=} [properties] Properties to set
         */
        function UpdateFriend(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateFriend userId.
         * @member {string} userId
         * @memberof BroadcastResult.UpdateFriend
         * @instance
         */
        UpdateFriend.prototype.userId = "";

        /**
         * UpdateFriend friendId.
         * @member {string} friendId
         * @memberof BroadcastResult.UpdateFriend
         * @instance
         */
        UpdateFriend.prototype.friendId = "";

        /**
         * UpdateFriend action.
         * @member {boolean} action
         * @memberof BroadcastResult.UpdateFriend
         * @instance
         */
        UpdateFriend.prototype.action = false;

        /**
         * Decodes an UpdateFriend message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.UpdateFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.UpdateFriend} UpdateFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateFriend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.UpdateFriend();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.friendId = reader.string();
                    break;
                case 3:
                    message.action = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("friendId"))
                throw $util.ProtocolError("missing required 'friendId'", { instance: message });
            if (!message.hasOwnProperty("action"))
                throw $util.ProtocolError("missing required 'action'", { instance: message });
            return message;
        };

        /**
         * Decodes an UpdateFriend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.UpdateFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.UpdateFriend} UpdateFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateFriend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UpdateFriend;
    })();

    BroadcastResult.RedPoint = (function() {

        /**
         * Properties of a RedPoint.
         * @memberof BroadcastResult
         * @interface IRedPoint
         * @property {number} type RedPoint type
         */

        /**
         * Constructs a new RedPoint.
         * @memberof BroadcastResult
         * @classdesc Represents a RedPoint.
         * @implements IRedPoint
         * @constructor
         * @param {BroadcastResult.IRedPoint=} [properties] Properties to set
         */
        function RedPoint(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedPoint type.
         * @member {number} type
         * @memberof BroadcastResult.RedPoint
         * @instance
         */
        RedPoint.prototype.type = 0;

        /**
         * Decodes a RedPoint message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.RedPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.RedPoint} RedPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.RedPoint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a RedPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.RedPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.RedPoint} RedPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RedPoint;
    })();

    BroadcastResult.ChangeToBlack = (function() {

        /**
         * Properties of a ChangeToBlack.
         * @memberof BroadcastResult
         * @interface IChangeToBlack
         */

        /**
         * Constructs a new ChangeToBlack.
         * @memberof BroadcastResult
         * @classdesc Represents a ChangeToBlack.
         * @implements IChangeToBlack
         * @constructor
         * @param {BroadcastResult.IChangeToBlack=} [properties] Properties to set
         */
        function ChangeToBlack(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Decodes a ChangeToBlack message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.ChangeToBlack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.ChangeToBlack} ChangeToBlack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToBlack.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.ChangeToBlack();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeToBlack message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.ChangeToBlack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.ChangeToBlack} ChangeToBlack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToBlack.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ChangeToBlack;
    })();

    BroadcastResult.RefreshRoomBanner = (function() {

        /**
         * Properties of a RefreshRoomBanner.
         * @memberof BroadcastResult
         * @interface IRefreshRoomBanner
         */

        /**
         * Constructs a new RefreshRoomBanner.
         * @memberof BroadcastResult
         * @classdesc Represents a RefreshRoomBanner.
         * @implements IRefreshRoomBanner
         * @constructor
         * @param {BroadcastResult.IRefreshRoomBanner=} [properties] Properties to set
         */
        function RefreshRoomBanner(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Decodes a RefreshRoomBanner message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.RefreshRoomBanner
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.RefreshRoomBanner} RefreshRoomBanner
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshRoomBanner.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.RefreshRoomBanner();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefreshRoomBanner message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.RefreshRoomBanner
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.RefreshRoomBanner} RefreshRoomBanner
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshRoomBanner.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RefreshRoomBanner;
    })();

    BroadcastResult.YoungState = (function() {

        /**
         * Properties of a YoungState.
         * @memberof BroadcastResult
         * @interface IYoungState
         * @property {boolean} state YoungState state
         */

        /**
         * Constructs a new YoungState.
         * @memberof BroadcastResult
         * @classdesc Represents a YoungState.
         * @implements IYoungState
         * @constructor
         * @param {BroadcastResult.IYoungState=} [properties] Properties to set
         */
        function YoungState(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * YoungState state.
         * @member {boolean} state
         * @memberof BroadcastResult.YoungState
         * @instance
         */
        YoungState.prototype.state = false;

        /**
         * Decodes a YoungState message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.YoungState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.YoungState} YoungState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        YoungState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.YoungState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("state"))
                throw $util.ProtocolError("missing required 'state'", { instance: message });
            return message;
        };

        /**
         * Decodes a YoungState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.YoungState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.YoungState} YoungState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        YoungState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return YoungState;
    })();

    BroadcastResult.MessageBroadcast = (function() {

        /**
         * Properties of a MessageBroadcast.
         * @memberof BroadcastResult
         * @interface IMessageBroadcast
         * @property {number} msgId MessageBroadcast msgId
         * @property {number|null} [broadcastType] MessageBroadcast broadcastType
         * @property {Array.<string>|null} [params] MessageBroadcast params
         */

        /**
         * Constructs a new MessageBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a MessageBroadcast.
         * @implements IMessageBroadcast
         * @constructor
         * @param {BroadcastResult.IMessageBroadcast=} [properties] Properties to set
         */
        function MessageBroadcast(properties) {
            this.params = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageBroadcast msgId.
         * @member {number} msgId
         * @memberof BroadcastResult.MessageBroadcast
         * @instance
         */
        MessageBroadcast.prototype.msgId = 0;

        /**
         * MessageBroadcast broadcastType.
         * @member {number} broadcastType
         * @memberof BroadcastResult.MessageBroadcast
         * @instance
         */
        MessageBroadcast.prototype.broadcastType = 0;

        /**
         * MessageBroadcast params.
         * @member {Array.<string>} params
         * @memberof BroadcastResult.MessageBroadcast
         * @instance
         */
        MessageBroadcast.prototype.params = $util.emptyArray;

        /**
         * Decodes a MessageBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.MessageBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.MessageBroadcast} MessageBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.MessageBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msgId = reader.int32();
                    break;
                case 2:
                    message.broadcastType = reader.int32();
                    break;
                case 3:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("msgId"))
                throw $util.ProtocolError("missing required 'msgId'", { instance: message });
            return message;
        };

        /**
         * Decodes a MessageBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.MessageBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.MessageBroadcast} MessageBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MessageBroadcast;
    })();

    BroadcastResult.LoveRingBroadcast = (function() {

        /**
         * Properties of a LoveRingBroadcast.
         * @memberof BroadcastResult
         * @interface ILoveRingBroadcast
         * @property {number} status LoveRingBroadcast status
         * @property {UserResult.IUserBase|null} [user1] LoveRingBroadcast user1
         * @property {UserResult.IUserBase|null} [user2] LoveRingBroadcast user2
         * @property {string|null} [opUserId] LoveRingBroadcast opUserId
         * @property {string|null} [cpRoomId] LoveRingBroadcast cpRoomId
         */

        /**
         * Constructs a new LoveRingBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a LoveRingBroadcast.
         * @implements ILoveRingBroadcast
         * @constructor
         * @param {BroadcastResult.ILoveRingBroadcast=} [properties] Properties to set
         */
        function LoveRingBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoveRingBroadcast status.
         * @member {number} status
         * @memberof BroadcastResult.LoveRingBroadcast
         * @instance
         */
        LoveRingBroadcast.prototype.status = 0;

        /**
         * LoveRingBroadcast user1.
         * @member {UserResult.IUserBase|null|undefined} user1
         * @memberof BroadcastResult.LoveRingBroadcast
         * @instance
         */
        LoveRingBroadcast.prototype.user1 = null;

        /**
         * LoveRingBroadcast user2.
         * @member {UserResult.IUserBase|null|undefined} user2
         * @memberof BroadcastResult.LoveRingBroadcast
         * @instance
         */
        LoveRingBroadcast.prototype.user2 = null;

        /**
         * LoveRingBroadcast opUserId.
         * @member {string} opUserId
         * @memberof BroadcastResult.LoveRingBroadcast
         * @instance
         */
        LoveRingBroadcast.prototype.opUserId = "";

        /**
         * LoveRingBroadcast cpRoomId.
         * @member {string} cpRoomId
         * @memberof BroadcastResult.LoveRingBroadcast
         * @instance
         */
        LoveRingBroadcast.prototype.cpRoomId = "";

        /**
         * Decodes a LoveRingBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.LoveRingBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.LoveRingBroadcast} LoveRingBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoveRingBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.LoveRingBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.user1 = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.user2 = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.opUserId = reader.string();
                    break;
                case 5:
                    message.cpRoomId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes a LoveRingBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.LoveRingBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.LoveRingBroadcast} LoveRingBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoveRingBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LoveRingBroadcast;
    })();

    BroadcastResult.SyncStateToast = (function() {

        /**
         * Properties of a SyncStateToast.
         * @memberof BroadcastResult
         * @interface ISyncStateToast
         * @property {number} state SyncStateToast state
         */

        /**
         * Constructs a new SyncStateToast.
         * @memberof BroadcastResult
         * @classdesc Represents a SyncStateToast.
         * @implements ISyncStateToast
         * @constructor
         * @param {BroadcastResult.ISyncStateToast=} [properties] Properties to set
         */
        function SyncStateToast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncStateToast state.
         * @member {number} state
         * @memberof BroadcastResult.SyncStateToast
         * @instance
         */
        SyncStateToast.prototype.state = 0;

        /**
         * Decodes a SyncStateToast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.SyncStateToast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.SyncStateToast} SyncStateToast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncStateToast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.SyncStateToast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("state"))
                throw $util.ProtocolError("missing required 'state'", { instance: message });
            return message;
        };

        /**
         * Decodes a SyncStateToast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.SyncStateToast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.SyncStateToast} SyncStateToast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncStateToast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SyncStateToast;
    })();

    BroadcastResult.MatchmakerStatusBroadcast = (function() {

        /**
         * Properties of a MatchmakerStatusBroadcast.
         * @memberof BroadcastResult
         * @interface IMatchmakerStatusBroadcast
         * @property {string} userId MatchmakerStatusBroadcast userId
         * @property {number} status MatchmakerStatusBroadcast status
         */

        /**
         * Constructs a new MatchmakerStatusBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a MatchmakerStatusBroadcast.
         * @implements IMatchmakerStatusBroadcast
         * @constructor
         * @param {BroadcastResult.IMatchmakerStatusBroadcast=} [properties] Properties to set
         */
        function MatchmakerStatusBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MatchmakerStatusBroadcast userId.
         * @member {string} userId
         * @memberof BroadcastResult.MatchmakerStatusBroadcast
         * @instance
         */
        MatchmakerStatusBroadcast.prototype.userId = "";

        /**
         * MatchmakerStatusBroadcast status.
         * @member {number} status
         * @memberof BroadcastResult.MatchmakerStatusBroadcast
         * @instance
         */
        MatchmakerStatusBroadcast.prototype.status = 0;

        /**
         * Decodes a MatchmakerStatusBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.MatchmakerStatusBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.MatchmakerStatusBroadcast} MatchmakerStatusBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchmakerStatusBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.MatchmakerStatusBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes a MatchmakerStatusBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.MatchmakerStatusBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.MatchmakerStatusBroadcast} MatchmakerStatusBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchmakerStatusBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MatchmakerStatusBroadcast;
    })();

    BroadcastResult.UserCertificationBroadcast = (function() {

        /**
         * Properties of a UserCertificationBroadcast.
         * @memberof BroadcastResult
         * @interface IUserCertificationBroadcast
         * @property {string} userId UserCertificationBroadcast userId
         * @property {boolean} certification UserCertificationBroadcast certification
         */

        /**
         * Constructs a new UserCertificationBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a UserCertificationBroadcast.
         * @implements IUserCertificationBroadcast
         * @constructor
         * @param {BroadcastResult.IUserCertificationBroadcast=} [properties] Properties to set
         */
        function UserCertificationBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserCertificationBroadcast userId.
         * @member {string} userId
         * @memberof BroadcastResult.UserCertificationBroadcast
         * @instance
         */
        UserCertificationBroadcast.prototype.userId = "";

        /**
         * UserCertificationBroadcast certification.
         * @member {boolean} certification
         * @memberof BroadcastResult.UserCertificationBroadcast
         * @instance
         */
        UserCertificationBroadcast.prototype.certification = false;

        /**
         * Decodes a UserCertificationBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.UserCertificationBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.UserCertificationBroadcast} UserCertificationBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCertificationBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.UserCertificationBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.certification = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("certification"))
                throw $util.ProtocolError("missing required 'certification'", { instance: message });
            return message;
        };

        /**
         * Decodes a UserCertificationBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.UserCertificationBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.UserCertificationBroadcast} UserCertificationBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCertificationBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserCertificationBroadcast;
    })();

    BroadcastResult.FamilyAnchorStatusBroadcast = (function() {

        /**
         * Properties of a FamilyAnchorStatusBroadcast.
         * @memberof BroadcastResult
         * @interface IFamilyAnchorStatusBroadcast
         * @property {string} userId FamilyAnchorStatusBroadcast userId
         * @property {string} familyId FamilyAnchorStatusBroadcast familyId
         * @property {number} status FamilyAnchorStatusBroadcast status
         */

        /**
         * Constructs a new FamilyAnchorStatusBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a FamilyAnchorStatusBroadcast.
         * @implements IFamilyAnchorStatusBroadcast
         * @constructor
         * @param {BroadcastResult.IFamilyAnchorStatusBroadcast=} [properties] Properties to set
         */
        function FamilyAnchorStatusBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyAnchorStatusBroadcast userId.
         * @member {string} userId
         * @memberof BroadcastResult.FamilyAnchorStatusBroadcast
         * @instance
         */
        FamilyAnchorStatusBroadcast.prototype.userId = "";

        /**
         * FamilyAnchorStatusBroadcast familyId.
         * @member {string} familyId
         * @memberof BroadcastResult.FamilyAnchorStatusBroadcast
         * @instance
         */
        FamilyAnchorStatusBroadcast.prototype.familyId = "";

        /**
         * FamilyAnchorStatusBroadcast status.
         * @member {number} status
         * @memberof BroadcastResult.FamilyAnchorStatusBroadcast
         * @instance
         */
        FamilyAnchorStatusBroadcast.prototype.status = 0;

        /**
         * Decodes a FamilyAnchorStatusBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.FamilyAnchorStatusBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.FamilyAnchorStatusBroadcast} FamilyAnchorStatusBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyAnchorStatusBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.FamilyAnchorStatusBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.familyId = reader.string();
                    break;
                case 3:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("familyId"))
                throw $util.ProtocolError("missing required 'familyId'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes a FamilyAnchorStatusBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.FamilyAnchorStatusBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.FamilyAnchorStatusBroadcast} FamilyAnchorStatusBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyAnchorStatusBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FamilyAnchorStatusBroadcast;
    })();

    BroadcastResult.SyncUploadLog = (function() {

        /**
         * Properties of a SyncUploadLog.
         * @memberof BroadcastResult
         * @interface ISyncUploadLog
         * @property {string} logKey SyncUploadLog logKey
         */

        /**
         * Constructs a new SyncUploadLog.
         * @memberof BroadcastResult
         * @classdesc Represents a SyncUploadLog.
         * @implements ISyncUploadLog
         * @constructor
         * @param {BroadcastResult.ISyncUploadLog=} [properties] Properties to set
         */
        function SyncUploadLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncUploadLog logKey.
         * @member {string} logKey
         * @memberof BroadcastResult.SyncUploadLog
         * @instance
         */
        SyncUploadLog.prototype.logKey = "";

        /**
         * Decodes a SyncUploadLog message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.SyncUploadLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.SyncUploadLog} SyncUploadLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncUploadLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.SyncUploadLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("logKey"))
                throw $util.ProtocolError("missing required 'logKey'", { instance: message });
            return message;
        };

        /**
         * Decodes a SyncUploadLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.SyncUploadLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.SyncUploadLog} SyncUploadLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncUploadLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SyncUploadLog;
    })();

    BroadcastResult.RankInfoBroadcast = (function() {

        /**
         * Properties of a RankInfoBroadcast.
         * @memberof BroadcastResult
         * @interface IRankInfoBroadcast
         * @property {RankResult.ITargetRankInfo} rank RankInfoBroadcast rank
         */

        /**
         * Constructs a new RankInfoBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a RankInfoBroadcast.
         * @implements IRankInfoBroadcast
         * @constructor
         * @param {BroadcastResult.IRankInfoBroadcast=} [properties] Properties to set
         */
        function RankInfoBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankInfoBroadcast rank.
         * @member {RankResult.ITargetRankInfo} rank
         * @memberof BroadcastResult.RankInfoBroadcast
         * @instance
         */
        RankInfoBroadcast.prototype.rank = null;

        /**
         * Decodes a RankInfoBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.RankInfoBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.RankInfoBroadcast} RankInfoBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankInfoBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.RankInfoBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rank = $root.RankResult.TargetRankInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rank"))
                throw $util.ProtocolError("missing required 'rank'", { instance: message });
            return message;
        };

        /**
         * Decodes a RankInfoBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.RankInfoBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.RankInfoBroadcast} RankInfoBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankInfoBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RankInfoBroadcast;
    })();

    BroadcastResult.EnterImGroupBroadcast = (function() {

        /**
         * Properties of an EnterImGroupBroadcast.
         * @memberof BroadcastResult
         * @interface IEnterImGroupBroadcast
         * @property {number} type EnterImGroupBroadcast type
         * @property {string} groupId EnterImGroupBroadcast groupId
         */

        /**
         * Constructs a new EnterImGroupBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents an EnterImGroupBroadcast.
         * @implements IEnterImGroupBroadcast
         * @constructor
         * @param {BroadcastResult.IEnterImGroupBroadcast=} [properties] Properties to set
         */
        function EnterImGroupBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterImGroupBroadcast type.
         * @member {number} type
         * @memberof BroadcastResult.EnterImGroupBroadcast
         * @instance
         */
        EnterImGroupBroadcast.prototype.type = 0;

        /**
         * EnterImGroupBroadcast groupId.
         * @member {string} groupId
         * @memberof BroadcastResult.EnterImGroupBroadcast
         * @instance
         */
        EnterImGroupBroadcast.prototype.groupId = "";

        /**
         * Decodes an EnterImGroupBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.EnterImGroupBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.EnterImGroupBroadcast} EnterImGroupBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterImGroupBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.EnterImGroupBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.groupId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("groupId"))
                throw $util.ProtocolError("missing required 'groupId'", { instance: message });
            return message;
        };

        /**
         * Decodes an EnterImGroupBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.EnterImGroupBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.EnterImGroupBroadcast} EnterImGroupBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterImGroupBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return EnterImGroupBroadcast;
    })();

    BroadcastResult.CrossRoomMatchBroadcast = (function() {

        /**
         * Properties of a CrossRoomMatchBroadcast.
         * @memberof BroadcastResult
         * @interface ICrossRoomMatchBroadcast
         * @property {string} roomId CrossRoomMatchBroadcast roomId
         * @property {number} star CrossRoomMatchBroadcast star
         * @property {RoomResult.IBaseRoomInfo} targetRoom CrossRoomMatchBroadcast targetRoom
         * @property {number} targetStar CrossRoomMatchBroadcast targetStar
         * @property {number|Long} startTime CrossRoomMatchBroadcast startTime
         * @property {number|Long} endTime CrossRoomMatchBroadcast endTime
         * @property {number|Long} addRatioTime CrossRoomMatchBroadcast addRatioTime
         * @property {number} addRatio CrossRoomMatchBroadcast addRatio
         */

        /**
         * Constructs a new CrossRoomMatchBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a CrossRoomMatchBroadcast.
         * @implements ICrossRoomMatchBroadcast
         * @constructor
         * @param {BroadcastResult.ICrossRoomMatchBroadcast=} [properties] Properties to set
         */
        function CrossRoomMatchBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomMatchBroadcast roomId.
         * @member {string} roomId
         * @memberof BroadcastResult.CrossRoomMatchBroadcast
         * @instance
         */
        CrossRoomMatchBroadcast.prototype.roomId = "";

        /**
         * CrossRoomMatchBroadcast star.
         * @member {number} star
         * @memberof BroadcastResult.CrossRoomMatchBroadcast
         * @instance
         */
        CrossRoomMatchBroadcast.prototype.star = 0;

        /**
         * CrossRoomMatchBroadcast targetRoom.
         * @member {RoomResult.IBaseRoomInfo} targetRoom
         * @memberof BroadcastResult.CrossRoomMatchBroadcast
         * @instance
         */
        CrossRoomMatchBroadcast.prototype.targetRoom = null;

        /**
         * CrossRoomMatchBroadcast targetStar.
         * @member {number} targetStar
         * @memberof BroadcastResult.CrossRoomMatchBroadcast
         * @instance
         */
        CrossRoomMatchBroadcast.prototype.targetStar = 0;

        /**
         * CrossRoomMatchBroadcast startTime.
         * @member {number|Long} startTime
         * @memberof BroadcastResult.CrossRoomMatchBroadcast
         * @instance
         */
        CrossRoomMatchBroadcast.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomMatchBroadcast endTime.
         * @member {number|Long} endTime
         * @memberof BroadcastResult.CrossRoomMatchBroadcast
         * @instance
         */
        CrossRoomMatchBroadcast.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomMatchBroadcast addRatioTime.
         * @member {number|Long} addRatioTime
         * @memberof BroadcastResult.CrossRoomMatchBroadcast
         * @instance
         */
        CrossRoomMatchBroadcast.prototype.addRatioTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomMatchBroadcast addRatio.
         * @member {number} addRatio
         * @memberof BroadcastResult.CrossRoomMatchBroadcast
         * @instance
         */
        CrossRoomMatchBroadcast.prototype.addRatio = 0;

        /**
         * Decodes a CrossRoomMatchBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.CrossRoomMatchBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.CrossRoomMatchBroadcast} CrossRoomMatchBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomMatchBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.CrossRoomMatchBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.star = reader.int32();
                    break;
                case 3:
                    message.targetRoom = $root.RoomResult.BaseRoomInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.targetStar = reader.int32();
                    break;
                case 5:
                    message.startTime = reader.int64();
                    break;
                case 6:
                    message.endTime = reader.int64();
                    break;
                case 7:
                    message.addRatioTime = reader.int64();
                    break;
                case 8:
                    message.addRatio = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("star"))
                throw $util.ProtocolError("missing required 'star'", { instance: message });
            if (!message.hasOwnProperty("targetRoom"))
                throw $util.ProtocolError("missing required 'targetRoom'", { instance: message });
            if (!message.hasOwnProperty("targetStar"))
                throw $util.ProtocolError("missing required 'targetStar'", { instance: message });
            if (!message.hasOwnProperty("startTime"))
                throw $util.ProtocolError("missing required 'startTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            if (!message.hasOwnProperty("addRatioTime"))
                throw $util.ProtocolError("missing required 'addRatioTime'", { instance: message });
            if (!message.hasOwnProperty("addRatio"))
                throw $util.ProtocolError("missing required 'addRatio'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomMatchBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.CrossRoomMatchBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.CrossRoomMatchBroadcast} CrossRoomMatchBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomMatchBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomMatchBroadcast;
    })();

    BroadcastResult.CrossRoomResultBroadcast = (function() {

        /**
         * Properties of a CrossRoomResultBroadcast.
         * @memberof BroadcastResult
         * @interface ICrossRoomResultBroadcast
         * @property {string} roomId CrossRoomResultBroadcast roomId
         * @property {number} oriStar CrossRoomResultBroadcast oriStar
         * @property {number} win CrossRoomResultBroadcast win
         * @property {Array.<string>|null} [mvps] CrossRoomResultBroadcast mvps
         */

        /**
         * Constructs a new CrossRoomResultBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a CrossRoomResultBroadcast.
         * @implements ICrossRoomResultBroadcast
         * @constructor
         * @param {BroadcastResult.ICrossRoomResultBroadcast=} [properties] Properties to set
         */
        function CrossRoomResultBroadcast(properties) {
            this.mvps = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomResultBroadcast roomId.
         * @member {string} roomId
         * @memberof BroadcastResult.CrossRoomResultBroadcast
         * @instance
         */
        CrossRoomResultBroadcast.prototype.roomId = "";

        /**
         * CrossRoomResultBroadcast oriStar.
         * @member {number} oriStar
         * @memberof BroadcastResult.CrossRoomResultBroadcast
         * @instance
         */
        CrossRoomResultBroadcast.prototype.oriStar = 0;

        /**
         * CrossRoomResultBroadcast win.
         * @member {number} win
         * @memberof BroadcastResult.CrossRoomResultBroadcast
         * @instance
         */
        CrossRoomResultBroadcast.prototype.win = 0;

        /**
         * CrossRoomResultBroadcast mvps.
         * @member {Array.<string>} mvps
         * @memberof BroadcastResult.CrossRoomResultBroadcast
         * @instance
         */
        CrossRoomResultBroadcast.prototype.mvps = $util.emptyArray;

        /**
         * Decodes a CrossRoomResultBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.CrossRoomResultBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.CrossRoomResultBroadcast} CrossRoomResultBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomResultBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.CrossRoomResultBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.oriStar = reader.int32();
                    break;
                case 3:
                    message.win = reader.int32();
                    break;
                case 4:
                    if (!(message.mvps && message.mvps.length))
                        message.mvps = [];
                    message.mvps.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("oriStar"))
                throw $util.ProtocolError("missing required 'oriStar'", { instance: message });
            if (!message.hasOwnProperty("win"))
                throw $util.ProtocolError("missing required 'win'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomResultBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.CrossRoomResultBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.CrossRoomResultBroadcast} CrossRoomResultBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomResultBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomResultBroadcast;
    })();

    BroadcastResult.CrossRoomPkBroadcast = (function() {

        /**
         * Properties of a CrossRoomPkBroadcast.
         * @memberof BroadcastResult
         * @interface ICrossRoomPkBroadcast
         * @property {string} roomId CrossRoomPkBroadcast roomId
         * @property {number|Long} totalScore CrossRoomPkBroadcast totalScore
         * @property {number|Long} addScore CrossRoomPkBroadcast addScore
         * @property {number|Long} baseScore CrossRoomPkBroadcast baseScore
         * @property {number} addRatio CrossRoomPkBroadcast addRatio
         * @property {boolean} needUpdateMvp CrossRoomPkBroadcast needUpdateMvp
         * @property {Array.<RoomResult.ICrossRoomMvpInfo>|null} [mvps] CrossRoomPkBroadcast mvps
         */

        /**
         * Constructs a new CrossRoomPkBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a CrossRoomPkBroadcast.
         * @implements ICrossRoomPkBroadcast
         * @constructor
         * @param {BroadcastResult.ICrossRoomPkBroadcast=} [properties] Properties to set
         */
        function CrossRoomPkBroadcast(properties) {
            this.mvps = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomPkBroadcast roomId.
         * @member {string} roomId
         * @memberof BroadcastResult.CrossRoomPkBroadcast
         * @instance
         */
        CrossRoomPkBroadcast.prototype.roomId = "";

        /**
         * CrossRoomPkBroadcast totalScore.
         * @member {number|Long} totalScore
         * @memberof BroadcastResult.CrossRoomPkBroadcast
         * @instance
         */
        CrossRoomPkBroadcast.prototype.totalScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomPkBroadcast addScore.
         * @member {number|Long} addScore
         * @memberof BroadcastResult.CrossRoomPkBroadcast
         * @instance
         */
        CrossRoomPkBroadcast.prototype.addScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomPkBroadcast baseScore.
         * @member {number|Long} baseScore
         * @memberof BroadcastResult.CrossRoomPkBroadcast
         * @instance
         */
        CrossRoomPkBroadcast.prototype.baseScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomPkBroadcast addRatio.
         * @member {number} addRatio
         * @memberof BroadcastResult.CrossRoomPkBroadcast
         * @instance
         */
        CrossRoomPkBroadcast.prototype.addRatio = 0;

        /**
         * CrossRoomPkBroadcast needUpdateMvp.
         * @member {boolean} needUpdateMvp
         * @memberof BroadcastResult.CrossRoomPkBroadcast
         * @instance
         */
        CrossRoomPkBroadcast.prototype.needUpdateMvp = false;

        /**
         * CrossRoomPkBroadcast mvps.
         * @member {Array.<RoomResult.ICrossRoomMvpInfo>} mvps
         * @memberof BroadcastResult.CrossRoomPkBroadcast
         * @instance
         */
        CrossRoomPkBroadcast.prototype.mvps = $util.emptyArray;

        /**
         * Decodes a CrossRoomPkBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.CrossRoomPkBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.CrossRoomPkBroadcast} CrossRoomPkBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomPkBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.CrossRoomPkBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.totalScore = reader.int64();
                    break;
                case 3:
                    message.addScore = reader.int64();
                    break;
                case 4:
                    message.baseScore = reader.int64();
                    break;
                case 5:
                    message.addRatio = reader.double();
                    break;
                case 6:
                    message.needUpdateMvp = reader.bool();
                    break;
                case 7:
                    if (!(message.mvps && message.mvps.length))
                        message.mvps = [];
                    message.mvps.push($root.RoomResult.CrossRoomMvpInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("totalScore"))
                throw $util.ProtocolError("missing required 'totalScore'", { instance: message });
            if (!message.hasOwnProperty("addScore"))
                throw $util.ProtocolError("missing required 'addScore'", { instance: message });
            if (!message.hasOwnProperty("baseScore"))
                throw $util.ProtocolError("missing required 'baseScore'", { instance: message });
            if (!message.hasOwnProperty("addRatio"))
                throw $util.ProtocolError("missing required 'addRatio'", { instance: message });
            if (!message.hasOwnProperty("needUpdateMvp"))
                throw $util.ProtocolError("missing required 'needUpdateMvp'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomPkBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.CrossRoomPkBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.CrossRoomPkBroadcast} CrossRoomPkBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomPkBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomPkBroadcast;
    })();

    BroadcastResult.CrossRoomAddRatioBroadcast = (function() {

        /**
         * Properties of a CrossRoomAddRatioBroadcast.
         * @memberof BroadcastResult
         * @interface ICrossRoomAddRatioBroadcast
         * @property {string} roomId CrossRoomAddRatioBroadcast roomId
         * @property {number|Long} addDuration CrossRoomAddRatioBroadcast addDuration
         * @property {number} addRatio CrossRoomAddRatioBroadcast addRatio
         * @property {UserResult.IUserBase} user CrossRoomAddRatioBroadcast user
         */

        /**
         * Constructs a new CrossRoomAddRatioBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a CrossRoomAddRatioBroadcast.
         * @implements ICrossRoomAddRatioBroadcast
         * @constructor
         * @param {BroadcastResult.ICrossRoomAddRatioBroadcast=} [properties] Properties to set
         */
        function CrossRoomAddRatioBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomAddRatioBroadcast roomId.
         * @member {string} roomId
         * @memberof BroadcastResult.CrossRoomAddRatioBroadcast
         * @instance
         */
        CrossRoomAddRatioBroadcast.prototype.roomId = "";

        /**
         * CrossRoomAddRatioBroadcast addDuration.
         * @member {number|Long} addDuration
         * @memberof BroadcastResult.CrossRoomAddRatioBroadcast
         * @instance
         */
        CrossRoomAddRatioBroadcast.prototype.addDuration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomAddRatioBroadcast addRatio.
         * @member {number} addRatio
         * @memberof BroadcastResult.CrossRoomAddRatioBroadcast
         * @instance
         */
        CrossRoomAddRatioBroadcast.prototype.addRatio = 0;

        /**
         * CrossRoomAddRatioBroadcast user.
         * @member {UserResult.IUserBase} user
         * @memberof BroadcastResult.CrossRoomAddRatioBroadcast
         * @instance
         */
        CrossRoomAddRatioBroadcast.prototype.user = null;

        /**
         * Decodes a CrossRoomAddRatioBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.CrossRoomAddRatioBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.CrossRoomAddRatioBroadcast} CrossRoomAddRatioBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomAddRatioBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.CrossRoomAddRatioBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.addDuration = reader.int64();
                    break;
                case 3:
                    message.addRatio = reader.double();
                    break;
                case 4:
                    message.user = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("addDuration"))
                throw $util.ProtocolError("missing required 'addDuration'", { instance: message });
            if (!message.hasOwnProperty("addRatio"))
                throw $util.ProtocolError("missing required 'addRatio'", { instance: message });
            if (!message.hasOwnProperty("user"))
                throw $util.ProtocolError("missing required 'user'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomAddRatioBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.CrossRoomAddRatioBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.CrossRoomAddRatioBroadcast} CrossRoomAddRatioBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomAddRatioBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomAddRatioBroadcast;
    })();

    BroadcastResult.CrossRoomMatchingBroadcast = (function() {

        /**
         * Properties of a CrossRoomMatchingBroadcast.
         * @memberof BroadcastResult
         * @interface ICrossRoomMatchingBroadcast
         * @property {string} roomId CrossRoomMatchingBroadcast roomId
         * @property {number} match CrossRoomMatchingBroadcast match
         */

        /**
         * Constructs a new CrossRoomMatchingBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a CrossRoomMatchingBroadcast.
         * @implements ICrossRoomMatchingBroadcast
         * @constructor
         * @param {BroadcastResult.ICrossRoomMatchingBroadcast=} [properties] Properties to set
         */
        function CrossRoomMatchingBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomMatchingBroadcast roomId.
         * @member {string} roomId
         * @memberof BroadcastResult.CrossRoomMatchingBroadcast
         * @instance
         */
        CrossRoomMatchingBroadcast.prototype.roomId = "";

        /**
         * CrossRoomMatchingBroadcast match.
         * @member {number} match
         * @memberof BroadcastResult.CrossRoomMatchingBroadcast
         * @instance
         */
        CrossRoomMatchingBroadcast.prototype.match = 0;

        /**
         * Decodes a CrossRoomMatchingBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.CrossRoomMatchingBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.CrossRoomMatchingBroadcast} CrossRoomMatchingBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomMatchingBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.CrossRoomMatchingBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.match = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("match"))
                throw $util.ProtocolError("missing required 'match'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomMatchingBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.CrossRoomMatchingBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.CrossRoomMatchingBroadcast} CrossRoomMatchingBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomMatchingBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomMatchingBroadcast;
    })();

    BroadcastResult.RocketRechargeFinishBroadcast = (function() {

        /**
         * Properties of a RocketRechargeFinishBroadcast.
         * @memberof BroadcastResult
         * @interface IRocketRechargeFinishBroadcast
         */

        /**
         * Constructs a new RocketRechargeFinishBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a RocketRechargeFinishBroadcast.
         * @implements IRocketRechargeFinishBroadcast
         * @constructor
         * @param {BroadcastResult.IRocketRechargeFinishBroadcast=} [properties] Properties to set
         */
        function RocketRechargeFinishBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Decodes a RocketRechargeFinishBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.RocketRechargeFinishBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.RocketRechargeFinishBroadcast} RocketRechargeFinishBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RocketRechargeFinishBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.RocketRechargeFinishBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RocketRechargeFinishBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.RocketRechargeFinishBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.RocketRechargeFinishBroadcast} RocketRechargeFinishBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RocketRechargeFinishBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RocketRechargeFinishBroadcast;
    })();

    BroadcastResult.RocketRedPocketReveicedBroadcast = (function() {

        /**
         * Properties of a RocketRedPocketReveicedBroadcast.
         * @memberof BroadcastResult
         * @interface IRocketRedPocketReveicedBroadcast
         * @property {string} userId RocketRedPocketReveicedBroadcast userId
         * @property {number} fgmNum RocketRedPocketReveicedBroadcast fgmNum
         */

        /**
         * Constructs a new RocketRedPocketReveicedBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a RocketRedPocketReveicedBroadcast.
         * @implements IRocketRedPocketReveicedBroadcast
         * @constructor
         * @param {BroadcastResult.IRocketRedPocketReveicedBroadcast=} [properties] Properties to set
         */
        function RocketRedPocketReveicedBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RocketRedPocketReveicedBroadcast userId.
         * @member {string} userId
         * @memberof BroadcastResult.RocketRedPocketReveicedBroadcast
         * @instance
         */
        RocketRedPocketReveicedBroadcast.prototype.userId = "";

        /**
         * RocketRedPocketReveicedBroadcast fgmNum.
         * @member {number} fgmNum
         * @memberof BroadcastResult.RocketRedPocketReveicedBroadcast
         * @instance
         */
        RocketRedPocketReveicedBroadcast.prototype.fgmNum = 0;

        /**
         * Decodes a RocketRedPocketReveicedBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.RocketRedPocketReveicedBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.RocketRedPocketReveicedBroadcast} RocketRedPocketReveicedBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RocketRedPocketReveicedBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.RocketRedPocketReveicedBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.fgmNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("fgmNum"))
                throw $util.ProtocolError("missing required 'fgmNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a RocketRedPocketReveicedBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.RocketRedPocketReveicedBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.RocketRedPocketReveicedBroadcast} RocketRedPocketReveicedBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RocketRedPocketReveicedBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RocketRedPocketReveicedBroadcast;
    })();

    BroadcastResult.PublicChatSendMessageBroadcast = (function() {

        /**
         * Properties of a PublicChatSendMessageBroadcast.
         * @memberof BroadcastResult
         * @interface IPublicChatSendMessageBroadcast
         * @property {PublicChatResult.IPublicChatMessage} message PublicChatSendMessageBroadcast message
         */

        /**
         * Constructs a new PublicChatSendMessageBroadcast.
         * @memberof BroadcastResult
         * @classdesc Represents a PublicChatSendMessageBroadcast.
         * @implements IPublicChatSendMessageBroadcast
         * @constructor
         * @param {BroadcastResult.IPublicChatSendMessageBroadcast=} [properties] Properties to set
         */
        function PublicChatSendMessageBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublicChatSendMessageBroadcast message.
         * @member {PublicChatResult.IPublicChatMessage} message
         * @memberof BroadcastResult.PublicChatSendMessageBroadcast
         * @instance
         */
        PublicChatSendMessageBroadcast.prototype.message = null;

        /**
         * Decodes a PublicChatSendMessageBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof BroadcastResult.PublicChatSendMessageBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BroadcastResult.PublicChatSendMessageBroadcast} PublicChatSendMessageBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicChatSendMessageBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BroadcastResult.PublicChatSendMessageBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message = $root.PublicChatResult.PublicChatMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("message"))
                throw $util.ProtocolError("missing required 'message'", { instance: message });
            return message;
        };

        /**
         * Decodes a PublicChatSendMessageBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BroadcastResult.PublicChatSendMessageBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BroadcastResult.PublicChatSendMessageBroadcast} PublicChatSendMessageBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicChatSendMessageBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return PublicChatSendMessageBroadcast;
    })();

    return BroadcastResult;
})();

export const RankResult = $root.RankResult = (() => {

    /**
     * Namespace RankResult.
     * @exports RankResult
     * @namespace
     */
    const RankResult = {};

    RankResult.RankList = (function() {

        /**
         * Properties of a RankList.
         * @memberof RankResult
         * @interface IRankList
         * @property {Array.<RankResult.IRankInfo>|null} [list] RankList list
         */

        /**
         * Constructs a new RankList.
         * @memberof RankResult
         * @classdesc Represents a RankList.
         * @implements IRankList
         * @constructor
         * @param {RankResult.IRankList=} [properties] Properties to set
         */
        function RankList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankList list.
         * @member {Array.<RankResult.IRankInfo>} list
         * @memberof RankResult.RankList
         * @instance
         */
        RankList.prototype.list = $util.emptyArray;

        /**
         * Decodes a RankList message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.RankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.RankList} RankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.RankList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RankResult.RankInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.RankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.RankList} RankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RankList;
    })();

    RankResult.RankInfo = (function() {

        /**
         * Properties of a RankInfo.
         * @memberof RankResult
         * @interface IRankInfo
         * @property {number} rank RankInfo rank
         * @property {number|Long} preRank RankInfo preRank
         * @property {string} id RankInfo id
         * @property {string|null} [name] RankInfo name
         * @property {number|Long|null} [logoTime] RankInfo logoTime
         * @property {number} rankScore RankInfo rankScore
         */

        /**
         * Constructs a new RankInfo.
         * @memberof RankResult
         * @classdesc Represents a RankInfo.
         * @implements IRankInfo
         * @constructor
         * @param {RankResult.IRankInfo=} [properties] Properties to set
         */
        function RankInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankInfo rank.
         * @member {number} rank
         * @memberof RankResult.RankInfo
         * @instance
         */
        RankInfo.prototype.rank = 0;

        /**
         * RankInfo preRank.
         * @member {number|Long} preRank
         * @memberof RankResult.RankInfo
         * @instance
         */
        RankInfo.prototype.preRank = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RankInfo id.
         * @member {string} id
         * @memberof RankResult.RankInfo
         * @instance
         */
        RankInfo.prototype.id = "";

        /**
         * RankInfo name.
         * @member {string} name
         * @memberof RankResult.RankInfo
         * @instance
         */
        RankInfo.prototype.name = "";

        /**
         * RankInfo logoTime.
         * @member {number|Long} logoTime
         * @memberof RankResult.RankInfo
         * @instance
         */
        RankInfo.prototype.logoTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RankInfo rankScore.
         * @member {number} rankScore
         * @memberof RankResult.RankInfo
         * @instance
         */
        RankInfo.prototype.rankScore = 0;

        /**
         * Decodes a RankInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.RankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.RankInfo} RankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.RankInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rank = reader.int32();
                    break;
                case 2:
                    message.preRank = reader.int64();
                    break;
                case 3:
                    message.id = reader.string();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.logoTime = reader.int64();
                    break;
                case 6:
                    message.rankScore = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rank"))
                throw $util.ProtocolError("missing required 'rank'", { instance: message });
            if (!message.hasOwnProperty("preRank"))
                throw $util.ProtocolError("missing required 'preRank'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("rankScore"))
                throw $util.ProtocolError("missing required 'rankScore'", { instance: message });
            return message;
        };

        /**
         * Decodes a RankInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.RankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.RankInfo} RankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RankInfo;
    })();

    RankResult.LiveRankList = (function() {

        /**
         * Properties of a LiveRankList.
         * @memberof RankResult
         * @interface ILiveRankList
         * @property {Array.<RankResult.ILiveRankInfo>|null} [list] LiveRankList list
         * @property {number|Long|null} [totalScore] LiveRankList totalScore
         * @property {number|Long|null} [myScore] LiveRankList myScore
         * @property {number|Long|null} [newTotalScore] LiveRankList newTotalScore
         * @property {number|Long|null} [newMyScore] LiveRankList newMyScore
         */

        /**
         * Constructs a new LiveRankList.
         * @memberof RankResult
         * @classdesc Represents a LiveRankList.
         * @implements ILiveRankList
         * @constructor
         * @param {RankResult.ILiveRankList=} [properties] Properties to set
         */
        function LiveRankList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveRankList list.
         * @member {Array.<RankResult.ILiveRankInfo>} list
         * @memberof RankResult.LiveRankList
         * @instance
         */
        LiveRankList.prototype.list = $util.emptyArray;

        /**
         * LiveRankList totalScore.
         * @member {number|Long} totalScore
         * @memberof RankResult.LiveRankList
         * @instance
         */
        LiveRankList.prototype.totalScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveRankList myScore.
         * @member {number|Long} myScore
         * @memberof RankResult.LiveRankList
         * @instance
         */
        LiveRankList.prototype.myScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveRankList newTotalScore.
         * @member {number|Long} newTotalScore
         * @memberof RankResult.LiveRankList
         * @instance
         */
        LiveRankList.prototype.newTotalScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveRankList newMyScore.
         * @member {number|Long} newMyScore
         * @memberof RankResult.LiveRankList
         * @instance
         */
        LiveRankList.prototype.newMyScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a LiveRankList message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.LiveRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.LiveRankList} LiveRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.LiveRankList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RankResult.LiveRankInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalScore = reader.int64();
                    break;
                case 3:
                    message.myScore = reader.int64();
                    break;
                case 4:
                    message.newTotalScore = reader.int64();
                    break;
                case 5:
                    message.newMyScore = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LiveRankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.LiveRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.LiveRankList} LiveRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveRankList;
    })();

    RankResult.LiveRankInfo = (function() {

        /**
         * Properties of a LiveRankInfo.
         * @memberof RankResult
         * @interface ILiveRankInfo
         * @property {number} rank LiveRankInfo rank
         * @property {string} userId LiveRankInfo userId
         * @property {number|Long} rankScore LiveRankInfo rankScore
         * @property {boolean|null} [isLive] LiveRankInfo isLive
         * @property {number|null} [roomType] LiveRankInfo roomType
         * @property {number|Long|null} [newRankScore] LiveRankInfo newRankScore
         */

        /**
         * Constructs a new LiveRankInfo.
         * @memberof RankResult
         * @classdesc Represents a LiveRankInfo.
         * @implements ILiveRankInfo
         * @constructor
         * @param {RankResult.ILiveRankInfo=} [properties] Properties to set
         */
        function LiveRankInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveRankInfo rank.
         * @member {number} rank
         * @memberof RankResult.LiveRankInfo
         * @instance
         */
        LiveRankInfo.prototype.rank = 0;

        /**
         * LiveRankInfo userId.
         * @member {string} userId
         * @memberof RankResult.LiveRankInfo
         * @instance
         */
        LiveRankInfo.prototype.userId = "";

        /**
         * LiveRankInfo rankScore.
         * @member {number|Long} rankScore
         * @memberof RankResult.LiveRankInfo
         * @instance
         */
        LiveRankInfo.prototype.rankScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveRankInfo isLive.
         * @member {boolean} isLive
         * @memberof RankResult.LiveRankInfo
         * @instance
         */
        LiveRankInfo.prototype.isLive = false;

        /**
         * LiveRankInfo roomType.
         * @member {number} roomType
         * @memberof RankResult.LiveRankInfo
         * @instance
         */
        LiveRankInfo.prototype.roomType = 0;

        /**
         * LiveRankInfo newRankScore.
         * @member {number|Long} newRankScore
         * @memberof RankResult.LiveRankInfo
         * @instance
         */
        LiveRankInfo.prototype.newRankScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a LiveRankInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.LiveRankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.LiveRankInfo} LiveRankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRankInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.LiveRankInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rank = reader.int32();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.rankScore = reader.int64();
                    break;
                case 4:
                    message.isLive = reader.bool();
                    break;
                case 5:
                    message.roomType = reader.int32();
                    break;
                case 6:
                    message.newRankScore = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rank"))
                throw $util.ProtocolError("missing required 'rank'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("rankScore"))
                throw $util.ProtocolError("missing required 'rankScore'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveRankInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.LiveRankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.LiveRankInfo} LiveRankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRankInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveRankInfo;
    })();

    RankResult.RoomRankList = (function() {

        /**
         * Properties of a RoomRankList.
         * @memberof RankResult
         * @interface IRoomRankList
         * @property {Array.<RankResult.IRoomRankInfo>|null} [list] RoomRankList list
         * @property {number|Long|null} [rank] RoomRankList rank
         * @property {number|Long|null} [score] RoomRankList score
         */

        /**
         * Constructs a new RoomRankList.
         * @memberof RankResult
         * @classdesc Represents a RoomRankList.
         * @implements IRoomRankList
         * @constructor
         * @param {RankResult.IRoomRankList=} [properties] Properties to set
         */
        function RoomRankList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomRankList list.
         * @member {Array.<RankResult.IRoomRankInfo>} list
         * @memberof RankResult.RoomRankList
         * @instance
         */
        RoomRankList.prototype.list = $util.emptyArray;

        /**
         * RoomRankList rank.
         * @member {number|Long} rank
         * @memberof RankResult.RoomRankList
         * @instance
         */
        RoomRankList.prototype.rank = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomRankList score.
         * @member {number|Long} score
         * @memberof RankResult.RoomRankList
         * @instance
         */
        RoomRankList.prototype.score = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a RoomRankList message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.RoomRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.RoomRankList} RoomRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.RoomRankList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RankResult.RoomRankInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.rank = reader.int64();
                    break;
                case 3:
                    message.score = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoomRankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.RoomRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.RoomRankList} RoomRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomRankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomRankList;
    })();

    RankResult.RoomRankInfo = (function() {

        /**
         * Properties of a RoomRankInfo.
         * @memberof RankResult
         * @interface IRoomRankInfo
         * @property {string} roomId RoomRankInfo roomId
         * @property {number} rank RoomRankInfo rank
         * @property {number|Long} score RoomRankInfo score
         */

        /**
         * Constructs a new RoomRankInfo.
         * @memberof RankResult
         * @classdesc Represents a RoomRankInfo.
         * @implements IRoomRankInfo
         * @constructor
         * @param {RankResult.IRoomRankInfo=} [properties] Properties to set
         */
        function RoomRankInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomRankInfo roomId.
         * @member {string} roomId
         * @memberof RankResult.RoomRankInfo
         * @instance
         */
        RoomRankInfo.prototype.roomId = "";

        /**
         * RoomRankInfo rank.
         * @member {number} rank
         * @memberof RankResult.RoomRankInfo
         * @instance
         */
        RoomRankInfo.prototype.rank = 0;

        /**
         * RoomRankInfo score.
         * @member {number|Long} score
         * @memberof RankResult.RoomRankInfo
         * @instance
         */
        RoomRankInfo.prototype.score = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a RoomRankInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.RoomRankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.RoomRankInfo} RoomRankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomRankInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.RoomRankInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.rank = reader.int32();
                    break;
                case 3:
                    message.score = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("rank"))
                throw $util.ProtocolError("missing required 'rank'", { instance: message });
            if (!message.hasOwnProperty("score"))
                throw $util.ProtocolError("missing required 'score'", { instance: message });
            return message;
        };

        /**
         * Decodes a RoomRankInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.RoomRankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.RoomRankInfo} RoomRankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomRankInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomRankInfo;
    })();

    RankResult.TargetRankInfo = (function() {

        /**
         * Properties of a TargetRankInfo.
         * @memberof RankResult
         * @interface ITargetRankInfo
         * @property {string} targetId TargetRankInfo targetId
         * @property {number} rankType TargetRankInfo rankType
         * @property {boolean} isFilter TargetRankInfo isFilter
         * @property {number|null} [rank] TargetRankInfo rank
         * @property {number|Long|null} [score] TargetRankInfo score
         * @property {number|Long|null} [diffScore] TargetRankInfo diffScore
         */

        /**
         * Constructs a new TargetRankInfo.
         * @memberof RankResult
         * @classdesc Represents a TargetRankInfo.
         * @implements ITargetRankInfo
         * @constructor
         * @param {RankResult.ITargetRankInfo=} [properties] Properties to set
         */
        function TargetRankInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetRankInfo targetId.
         * @member {string} targetId
         * @memberof RankResult.TargetRankInfo
         * @instance
         */
        TargetRankInfo.prototype.targetId = "";

        /**
         * TargetRankInfo rankType.
         * @member {number} rankType
         * @memberof RankResult.TargetRankInfo
         * @instance
         */
        TargetRankInfo.prototype.rankType = 0;

        /**
         * TargetRankInfo isFilter.
         * @member {boolean} isFilter
         * @memberof RankResult.TargetRankInfo
         * @instance
         */
        TargetRankInfo.prototype.isFilter = false;

        /**
         * TargetRankInfo rank.
         * @member {number} rank
         * @memberof RankResult.TargetRankInfo
         * @instance
         */
        TargetRankInfo.prototype.rank = 0;

        /**
         * TargetRankInfo score.
         * @member {number|Long} score
         * @memberof RankResult.TargetRankInfo
         * @instance
         */
        TargetRankInfo.prototype.score = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TargetRankInfo diffScore.
         * @member {number|Long} diffScore
         * @memberof RankResult.TargetRankInfo
         * @instance
         */
        TargetRankInfo.prototype.diffScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a TargetRankInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.TargetRankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.TargetRankInfo} TargetRankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetRankInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.TargetRankInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                case 2:
                    message.rankType = reader.int32();
                    break;
                case 3:
                    message.isFilter = reader.bool();
                    break;
                case 4:
                    message.rank = reader.int32();
                    break;
                case 5:
                    message.score = reader.int64();
                    break;
                case 6:
                    message.diffScore = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            if (!message.hasOwnProperty("rankType"))
                throw $util.ProtocolError("missing required 'rankType'", { instance: message });
            if (!message.hasOwnProperty("isFilter"))
                throw $util.ProtocolError("missing required 'isFilter'", { instance: message });
            return message;
        };

        /**
         * Decodes a TargetRankInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.TargetRankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.TargetRankInfo} TargetRankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetRankInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return TargetRankInfo;
    })();

    RankResult.CrossRoomRank = (function() {

        /**
         * Properties of a CrossRoomRank.
         * @memberof RankResult
         * @interface ICrossRoomRank
         * @property {RoomResult.IBaseRoomInfo|null} [room] CrossRoomRank room
         * @property {number} rank CrossRoomRank rank
         * @property {number} star CrossRoomRank star
         */

        /**
         * Constructs a new CrossRoomRank.
         * @memberof RankResult
         * @classdesc Represents a CrossRoomRank.
         * @implements ICrossRoomRank
         * @constructor
         * @param {RankResult.ICrossRoomRank=} [properties] Properties to set
         */
        function CrossRoomRank(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomRank room.
         * @member {RoomResult.IBaseRoomInfo|null|undefined} room
         * @memberof RankResult.CrossRoomRank
         * @instance
         */
        CrossRoomRank.prototype.room = null;

        /**
         * CrossRoomRank rank.
         * @member {number} rank
         * @memberof RankResult.CrossRoomRank
         * @instance
         */
        CrossRoomRank.prototype.rank = 0;

        /**
         * CrossRoomRank star.
         * @member {number} star
         * @memberof RankResult.CrossRoomRank
         * @instance
         */
        CrossRoomRank.prototype.star = 0;

        /**
         * Decodes a CrossRoomRank message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.CrossRoomRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.CrossRoomRank} CrossRoomRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.CrossRoomRank();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room = $root.RoomResult.BaseRoomInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.rank = reader.int32();
                    break;
                case 3:
                    message.star = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rank"))
                throw $util.ProtocolError("missing required 'rank'", { instance: message });
            if (!message.hasOwnProperty("star"))
                throw $util.ProtocolError("missing required 'star'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomRank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.CrossRoomRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.CrossRoomRank} CrossRoomRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomRank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomRank;
    })();

    RankResult.CrossRoomRanks = (function() {

        /**
         * Properties of a CrossRoomRanks.
         * @memberof RankResult
         * @interface ICrossRoomRanks
         * @property {Array.<RankResult.ICrossRoomRank>|null} [ranks] CrossRoomRanks ranks
         * @property {RankResult.ICrossRoomRank|null} [myRank] CrossRoomRanks myRank
         */

        /**
         * Constructs a new CrossRoomRanks.
         * @memberof RankResult
         * @classdesc Represents a CrossRoomRanks.
         * @implements ICrossRoomRanks
         * @constructor
         * @param {RankResult.ICrossRoomRanks=} [properties] Properties to set
         */
        function CrossRoomRanks(properties) {
            this.ranks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomRanks ranks.
         * @member {Array.<RankResult.ICrossRoomRank>} ranks
         * @memberof RankResult.CrossRoomRanks
         * @instance
         */
        CrossRoomRanks.prototype.ranks = $util.emptyArray;

        /**
         * CrossRoomRanks myRank.
         * @member {RankResult.ICrossRoomRank|null|undefined} myRank
         * @memberof RankResult.CrossRoomRanks
         * @instance
         */
        CrossRoomRanks.prototype.myRank = null;

        /**
         * Decodes a CrossRoomRanks message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.CrossRoomRanks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.CrossRoomRanks} CrossRoomRanks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomRanks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.CrossRoomRanks();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ranks && message.ranks.length))
                        message.ranks = [];
                    message.ranks.push($root.RankResult.CrossRoomRank.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.myRank = $root.RankResult.CrossRoomRank.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrossRoomRanks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.CrossRoomRanks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.CrossRoomRanks} CrossRoomRanks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomRanks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomRanks;
    })();

    RankResult.CrossRoomMvp = (function() {

        /**
         * Properties of a CrossRoomMvp.
         * @memberof RankResult
         * @interface ICrossRoomMvp
         * @property {UserResult.IUserBase|null} [user] CrossRoomMvp user
         * @property {number} rank CrossRoomMvp rank
         * @property {number} mvp CrossRoomMvp mvp
         * @property {number} ass CrossRoomMvp ass
         * @property {number} roomStatus CrossRoomMvp roomStatus
         * @property {string|null} [roomId] CrossRoomMvp roomId
         */

        /**
         * Constructs a new CrossRoomMvp.
         * @memberof RankResult
         * @classdesc Represents a CrossRoomMvp.
         * @implements ICrossRoomMvp
         * @constructor
         * @param {RankResult.ICrossRoomMvp=} [properties] Properties to set
         */
        function CrossRoomMvp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomMvp user.
         * @member {UserResult.IUserBase|null|undefined} user
         * @memberof RankResult.CrossRoomMvp
         * @instance
         */
        CrossRoomMvp.prototype.user = null;

        /**
         * CrossRoomMvp rank.
         * @member {number} rank
         * @memberof RankResult.CrossRoomMvp
         * @instance
         */
        CrossRoomMvp.prototype.rank = 0;

        /**
         * CrossRoomMvp mvp.
         * @member {number} mvp
         * @memberof RankResult.CrossRoomMvp
         * @instance
         */
        CrossRoomMvp.prototype.mvp = 0;

        /**
         * CrossRoomMvp ass.
         * @member {number} ass
         * @memberof RankResult.CrossRoomMvp
         * @instance
         */
        CrossRoomMvp.prototype.ass = 0;

        /**
         * CrossRoomMvp roomStatus.
         * @member {number} roomStatus
         * @memberof RankResult.CrossRoomMvp
         * @instance
         */
        CrossRoomMvp.prototype.roomStatus = 0;

        /**
         * CrossRoomMvp roomId.
         * @member {string} roomId
         * @memberof RankResult.CrossRoomMvp
         * @instance
         */
        CrossRoomMvp.prototype.roomId = "";

        /**
         * Decodes a CrossRoomMvp message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.CrossRoomMvp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.CrossRoomMvp} CrossRoomMvp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomMvp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.CrossRoomMvp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.user = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.rank = reader.int32();
                    break;
                case 3:
                    message.mvp = reader.int32();
                    break;
                case 4:
                    message.ass = reader.int32();
                    break;
                case 5:
                    message.roomStatus = reader.int32();
                    break;
                case 6:
                    message.roomId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rank"))
                throw $util.ProtocolError("missing required 'rank'", { instance: message });
            if (!message.hasOwnProperty("mvp"))
                throw $util.ProtocolError("missing required 'mvp'", { instance: message });
            if (!message.hasOwnProperty("ass"))
                throw $util.ProtocolError("missing required 'ass'", { instance: message });
            if (!message.hasOwnProperty("roomStatus"))
                throw $util.ProtocolError("missing required 'roomStatus'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomMvp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.CrossRoomMvp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.CrossRoomMvp} CrossRoomMvp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomMvp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomMvp;
    })();

    RankResult.CrossRoomMvpRanks = (function() {

        /**
         * Properties of a CrossRoomMvpRanks.
         * @memberof RankResult
         * @interface ICrossRoomMvpRanks
         * @property {Array.<RankResult.ICrossRoomMvp>|null} [ranks] CrossRoomMvpRanks ranks
         * @property {RankResult.ICrossRoomMvp|null} [myRank] CrossRoomMvpRanks myRank
         */

        /**
         * Constructs a new CrossRoomMvpRanks.
         * @memberof RankResult
         * @classdesc Represents a CrossRoomMvpRanks.
         * @implements ICrossRoomMvpRanks
         * @constructor
         * @param {RankResult.ICrossRoomMvpRanks=} [properties] Properties to set
         */
        function CrossRoomMvpRanks(properties) {
            this.ranks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomMvpRanks ranks.
         * @member {Array.<RankResult.ICrossRoomMvp>} ranks
         * @memberof RankResult.CrossRoomMvpRanks
         * @instance
         */
        CrossRoomMvpRanks.prototype.ranks = $util.emptyArray;

        /**
         * CrossRoomMvpRanks myRank.
         * @member {RankResult.ICrossRoomMvp|null|undefined} myRank
         * @memberof RankResult.CrossRoomMvpRanks
         * @instance
         */
        CrossRoomMvpRanks.prototype.myRank = null;

        /**
         * Decodes a CrossRoomMvpRanks message from the specified reader or buffer.
         * @function decode
         * @memberof RankResult.CrossRoomMvpRanks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RankResult.CrossRoomMvpRanks} CrossRoomMvpRanks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomMvpRanks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RankResult.CrossRoomMvpRanks();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ranks && message.ranks.length))
                        message.ranks = [];
                    message.ranks.push($root.RankResult.CrossRoomMvp.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.myRank = $root.RankResult.CrossRoomMvp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrossRoomMvpRanks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RankResult.CrossRoomMvpRanks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RankResult.CrossRoomMvpRanks} CrossRoomMvpRanks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomMvpRanks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomMvpRanks;
    })();

    return RankResult;
})();

export const RoomResult = $root.RoomResult = (() => {

    /**
     * Namespace RoomResult.
     * @exports RoomResult
     * @namespace
     */
    const RoomResult = {};

    RoomResult.RoomList = (function() {

        /**
         * Properties of a RoomList.
         * @memberof RoomResult
         * @interface IRoomList
         * @property {Array.<RoomResult.IRoomInfo>|null} [list] RoomList list
         */

        /**
         * Constructs a new RoomList.
         * @memberof RoomResult
         * @classdesc Represents a RoomList.
         * @implements IRoomList
         * @constructor
         * @param {RoomResult.IRoomList=} [properties] Properties to set
         */
        function RoomList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomList list.
         * @member {Array.<RoomResult.IRoomInfo>} list
         * @memberof RoomResult.RoomList
         * @instance
         */
        RoomList.prototype.list = $util.emptyArray;

        /**
         * Decodes a RoomList message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomList} RoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RoomResult.RoomInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoomList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomList} RoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomList;
    })();

    RoomResult.FollowRoomList = (function() {

        /**
         * Properties of a FollowRoomList.
         * @memberof RoomResult
         * @interface IFollowRoomList
         * @property {Array.<RoomResult.IRoomInfo>|null} [list] FollowRoomList list
         * @property {Array.<RoomResult.IRoomInfo>|null} [recommends] FollowRoomList recommends
         */

        /**
         * Constructs a new FollowRoomList.
         * @memberof RoomResult
         * @classdesc Represents a FollowRoomList.
         * @implements IFollowRoomList
         * @constructor
         * @param {RoomResult.IFollowRoomList=} [properties] Properties to set
         */
        function FollowRoomList(properties) {
            this.list = [];
            this.recommends = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FollowRoomList list.
         * @member {Array.<RoomResult.IRoomInfo>} list
         * @memberof RoomResult.FollowRoomList
         * @instance
         */
        FollowRoomList.prototype.list = $util.emptyArray;

        /**
         * FollowRoomList recommends.
         * @member {Array.<RoomResult.IRoomInfo>} recommends
         * @memberof RoomResult.FollowRoomList
         * @instance
         */
        FollowRoomList.prototype.recommends = $util.emptyArray;

        /**
         * Decodes a FollowRoomList message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.FollowRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.FollowRoomList} FollowRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FollowRoomList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.FollowRoomList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RoomResult.RoomInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.recommends && message.recommends.length))
                        message.recommends = [];
                    message.recommends.push($root.RoomResult.RoomInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FollowRoomList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.FollowRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.FollowRoomList} FollowRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FollowRoomList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FollowRoomList;
    })();

    RoomResult.RoomInfo = (function() {

        /**
         * Properties of a RoomInfo.
         * @memberof RoomResult
         * @interface IRoomInfo
         * @property {string} roomId RoomInfo roomId
         * @property {string|null} [roomName] RoomInfo roomName
         * @property {string|null} [createId] RoomInfo createId
         * @property {number|null} [onlineNum] RoomInfo onlineNum
         * @property {UserResult.IUserBase|null} [base] RoomInfo base
         * @property {boolean|null} [password] RoomInfo password
         * @property {number|null} [roomType] RoomInfo roomType
         * @property {number|null} [lableId] RoomInfo lableId
         * @property {number|null} [logoTime] RoomInfo logoTime
         * @property {UserResult.IUserBase|null} [micUserBase] RoomInfo micUserBase
         * @property {boolean|null} [homoMicUser] RoomInfo homoMicUser
         * @property {number|null} [favourType] RoomInfo favourType
         * @property {string|null} [notic] RoomInfo notic
         */

        /**
         * Constructs a new RoomInfo.
         * @memberof RoomResult
         * @classdesc Represents a RoomInfo.
         * @implements IRoomInfo
         * @constructor
         * @param {RoomResult.IRoomInfo=} [properties] Properties to set
         */
        function RoomInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomInfo roomId.
         * @member {string} roomId
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.roomId = "";

        /**
         * RoomInfo roomName.
         * @member {string} roomName
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.roomName = "";

        /**
         * RoomInfo createId.
         * @member {string} createId
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.createId = "";

        /**
         * RoomInfo onlineNum.
         * @member {number} onlineNum
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.onlineNum = 0;

        /**
         * RoomInfo base.
         * @member {UserResult.IUserBase|null|undefined} base
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.base = null;

        /**
         * RoomInfo password.
         * @member {boolean} password
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.password = false;

        /**
         * RoomInfo roomType.
         * @member {number} roomType
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.roomType = 0;

        /**
         * RoomInfo lableId.
         * @member {number} lableId
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.lableId = 0;

        /**
         * RoomInfo logoTime.
         * @member {number} logoTime
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.logoTime = 0;

        /**
         * RoomInfo micUserBase.
         * @member {UserResult.IUserBase|null|undefined} micUserBase
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.micUserBase = null;

        /**
         * RoomInfo homoMicUser.
         * @member {boolean} homoMicUser
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.homoMicUser = false;

        /**
         * RoomInfo favourType.
         * @member {number} favourType
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.favourType = 0;

        /**
         * RoomInfo notic.
         * @member {string} notic
         * @memberof RoomResult.RoomInfo
         * @instance
         */
        RoomInfo.prototype.notic = "";

        /**
         * Decodes a RoomInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomInfo} RoomInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.roomName = reader.string();
                    break;
                case 3:
                    message.createId = reader.string();
                    break;
                case 4:
                    message.onlineNum = reader.int32();
                    break;
                case 5:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.password = reader.bool();
                    break;
                case 7:
                    message.roomType = reader.int32();
                    break;
                case 8:
                    message.lableId = reader.int32();
                    break;
                case 9:
                    message.logoTime = reader.int32();
                    break;
                case 10:
                    message.micUserBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.homoMicUser = reader.bool();
                    break;
                case 12:
                    message.favourType = reader.int32();
                    break;
                case 13:
                    message.notic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            return message;
        };

        /**
         * Decodes a RoomInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomInfo} RoomInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomInfo;
    })();

    RoomResult.RoomData = (function() {

        /**
         * Properties of a RoomData.
         * @memberof RoomResult
         * @interface IRoomData
         * @property {string} roomId RoomData roomId
         * @property {number} type RoomData type
         * @property {string} createId RoomData createId
         * @property {string|null} [notic] RoomData notic
         * @property {Array.<RoomResult.IMicInfo>|null} [infos] RoomData infos
         * @property {string} bg RoomData bg
         * @property {number|Long|null} [myForbid] RoomData myForbid
         * @property {number|null} [onlineNum] RoomData onlineNum
         * @property {string|null} [roomName] RoomData roomName
         * @property {boolean|null} [needPassword] RoomData needPassword
         * @property {boolean|null} [createOnline] RoomData createOnline
         * @property {boolean|null} [myForbidMic] RoomData myForbidMic
         * @property {number|Long|null} [myForbidTime] RoomData myForbidTime
         * @property {number|null} [charm] RoomData charm
         * @property {number|null} [roomType] RoomData roomType
         * @property {boolean|null} [createOpenMic] RoomData createOpenMic
         * @property {number|null} [jobId] RoomData jobId
         * @property {UserResult.IUserBase|null} [roomContribute] RoomData roomContribute
         * @property {string|null} [worldContribute] RoomData worldContribute
         * @property {RoomResult.IFriendRoomData|null} [friendRoomData] RoomData friendRoomData
         * @property {Array.<UserResult.IUserBase>|null} [micQues] RoomData micQues
         * @property {Array.<RoomResult.IKickData>|null} [kickData] RoomData kickData
         * @property {number|null} [roomMode] RoomData roomMode
         * @property {number|null} [freeGiftRemainTime] RoomData freeGiftRemainTime
         * @property {RoomResult.ICPRoomData|null} [cpRoomData] RoomData cpRoomData
         * @property {number|null} [guardMemberCount] RoomData guardMemberCount
         * @property {string|null} [guardName] RoomData guardName
         * @property {boolean|null} [isGuardian] RoomData isGuardian
         * @property {number|null} [guardianLv] RoomData guardianLv
         * @property {UserResult.IUserBase|null} [roomCharm] RoomData roomCharm
         * @property {string|null} [worldCharm] RoomData worldCharm
         * @property {number|null} [logoTime] RoomData logoTime
         * @property {Array.<number>|null} [dragonBalls] RoomData dragonBalls
         * @property {string|null} [hatId] RoomData hatId
         * @property {string|null} [anchorHatId] RoomData anchorHatId
         * @property {number|Long|null} [contribute] RoomData contribute
         * @property {string|null} [roomOwnerId] RoomData roomOwnerId
         * @property {string|null} [roomGroupId] RoomData roomGroupId
         * @property {boolean|null} [isInRoomGroup] RoomData isInRoomGroup
         * @property {string|null} [liveflowUrl] RoomData liveflowUrl
         * @property {boolean|null} [createOpenVideo] RoomData createOpenVideo
         * @property {number|null} [roomH5] RoomData roomH5
         * @property {number|null} [cardType] RoomData cardType
         * @property {number|null} [anchorCardType] RoomData anchorCardType
         * @property {Array.<number>|null} [micQuesCardType] RoomData micQuesCardType
         * @property {number|Long|null} [newContribute] RoomData newContribute
         * @property {boolean|null} [isFavourHall] RoomData isFavourHall
         * @property {number|Long|null} [createHeartValue] RoomData createHeartValue
         * @property {boolean|null} [offlineMode] RoomData offlineMode
         * @property {RoomResult.ICrossRoomPk|null} [crossRoomPk] RoomData crossRoomPk
         * @property {boolean|null} [giftAnimation] RoomData giftAnimation
         * @property {string|null} [dashBoardToken] RoomData dashBoardToken
         * @property {string|null} [password] RoomData password
         * @property {RoomResult.IChatRoomData|null} [chatRoomData] RoomData chatRoomData
         */

        /**
         * Constructs a new RoomData.
         * @memberof RoomResult
         * @classdesc Represents a RoomData.
         * @implements IRoomData
         * @constructor
         * @param {RoomResult.IRoomData=} [properties] Properties to set
         */
        function RoomData(properties) {
            this.infos = [];
            this.micQues = [];
            this.kickData = [];
            this.dragonBalls = [];
            this.micQuesCardType = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomData roomId.
         * @member {string} roomId
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.roomId = "";

        /**
         * RoomData type.
         * @member {number} type
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.type = 0;

        /**
         * RoomData createId.
         * @member {string} createId
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.createId = "";

        /**
         * RoomData notic.
         * @member {string} notic
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.notic = "";

        /**
         * RoomData infos.
         * @member {Array.<RoomResult.IMicInfo>} infos
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.infos = $util.emptyArray;

        /**
         * RoomData bg.
         * @member {string} bg
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.bg = "";

        /**
         * RoomData myForbid.
         * @member {number|Long} myForbid
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.myForbid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomData onlineNum.
         * @member {number} onlineNum
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.onlineNum = 0;

        /**
         * RoomData roomName.
         * @member {string} roomName
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.roomName = "";

        /**
         * RoomData needPassword.
         * @member {boolean} needPassword
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.needPassword = false;

        /**
         * RoomData createOnline.
         * @member {boolean} createOnline
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.createOnline = false;

        /**
         * RoomData myForbidMic.
         * @member {boolean} myForbidMic
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.myForbidMic = false;

        /**
         * RoomData myForbidTime.
         * @member {number|Long} myForbidTime
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.myForbidTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomData charm.
         * @member {number} charm
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.charm = 0;

        /**
         * RoomData roomType.
         * @member {number} roomType
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.roomType = 0;

        /**
         * RoomData createOpenMic.
         * @member {boolean} createOpenMic
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.createOpenMic = false;

        /**
         * RoomData jobId.
         * @member {number} jobId
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.jobId = 0;

        /**
         * RoomData roomContribute.
         * @member {UserResult.IUserBase|null|undefined} roomContribute
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.roomContribute = null;

        /**
         * RoomData worldContribute.
         * @member {string} worldContribute
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.worldContribute = "";

        /**
         * RoomData friendRoomData.
         * @member {RoomResult.IFriendRoomData|null|undefined} friendRoomData
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.friendRoomData = null;

        /**
         * RoomData micQues.
         * @member {Array.<UserResult.IUserBase>} micQues
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.micQues = $util.emptyArray;

        /**
         * RoomData kickData.
         * @member {Array.<RoomResult.IKickData>} kickData
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.kickData = $util.emptyArray;

        /**
         * RoomData roomMode.
         * @member {number} roomMode
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.roomMode = 0;

        /**
         * RoomData freeGiftRemainTime.
         * @member {number} freeGiftRemainTime
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.freeGiftRemainTime = 0;

        /**
         * RoomData cpRoomData.
         * @member {RoomResult.ICPRoomData|null|undefined} cpRoomData
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.cpRoomData = null;

        /**
         * RoomData guardMemberCount.
         * @member {number} guardMemberCount
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.guardMemberCount = 0;

        /**
         * RoomData guardName.
         * @member {string} guardName
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.guardName = "";

        /**
         * RoomData isGuardian.
         * @member {boolean} isGuardian
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.isGuardian = false;

        /**
         * RoomData guardianLv.
         * @member {number} guardianLv
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.guardianLv = 0;

        /**
         * RoomData roomCharm.
         * @member {UserResult.IUserBase|null|undefined} roomCharm
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.roomCharm = null;

        /**
         * RoomData worldCharm.
         * @member {string} worldCharm
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.worldCharm = "";

        /**
         * RoomData logoTime.
         * @member {number} logoTime
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.logoTime = 0;

        /**
         * RoomData dragonBalls.
         * @member {Array.<number>} dragonBalls
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.dragonBalls = $util.emptyArray;

        /**
         * RoomData hatId.
         * @member {string} hatId
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.hatId = "";

        /**
         * RoomData anchorHatId.
         * @member {string} anchorHatId
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.anchorHatId = "";

        /**
         * RoomData contribute.
         * @member {number|Long} contribute
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.contribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomData roomOwnerId.
         * @member {string} roomOwnerId
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.roomOwnerId = "";

        /**
         * RoomData roomGroupId.
         * @member {string} roomGroupId
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.roomGroupId = "";

        /**
         * RoomData isInRoomGroup.
         * @member {boolean} isInRoomGroup
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.isInRoomGroup = false;

        /**
         * RoomData liveflowUrl.
         * @member {string} liveflowUrl
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.liveflowUrl = "";

        /**
         * RoomData createOpenVideo.
         * @member {boolean} createOpenVideo
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.createOpenVideo = false;

        /**
         * RoomData roomH5.
         * @member {number} roomH5
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.roomH5 = 0;

        /**
         * RoomData cardType.
         * @member {number} cardType
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.cardType = 0;

        /**
         * RoomData anchorCardType.
         * @member {number} anchorCardType
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.anchorCardType = 0;

        /**
         * RoomData micQuesCardType.
         * @member {Array.<number>} micQuesCardType
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.micQuesCardType = $util.emptyArray;

        /**
         * RoomData newContribute.
         * @member {number|Long} newContribute
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.newContribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomData isFavourHall.
         * @member {boolean} isFavourHall
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.isFavourHall = false;

        /**
         * RoomData createHeartValue.
         * @member {number|Long} createHeartValue
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.createHeartValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoomData offlineMode.
         * @member {boolean} offlineMode
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.offlineMode = false;

        /**
         * RoomData crossRoomPk.
         * @member {RoomResult.ICrossRoomPk|null|undefined} crossRoomPk
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.crossRoomPk = null;

        /**
         * RoomData giftAnimation.
         * @member {boolean} giftAnimation
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.giftAnimation = false;

        /**
         * RoomData dashBoardToken.
         * @member {string} dashBoardToken
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.dashBoardToken = "";

        /**
         * RoomData password.
         * @member {string} password
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.password = "";

        /**
         * RoomData chatRoomData.
         * @member {RoomResult.IChatRoomData|null|undefined} chatRoomData
         * @memberof RoomResult.RoomData
         * @instance
         */
        RoomData.prototype.chatRoomData = null;

        /**
         * Decodes a RoomData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomData} RoomData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.createId = reader.string();
                    break;
                case 4:
                    message.notic = reader.string();
                    break;
                case 5:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.RoomResult.MicInfo.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.bg = reader.string();
                    break;
                case 7:
                    message.myForbid = reader.int64();
                    break;
                case 8:
                    message.onlineNum = reader.int32();
                    break;
                case 9:
                    message.roomName = reader.string();
                    break;
                case 10:
                    message.needPassword = reader.bool();
                    break;
                case 11:
                    message.createOnline = reader.bool();
                    break;
                case 12:
                    message.myForbidMic = reader.bool();
                    break;
                case 13:
                    message.myForbidTime = reader.int64();
                    break;
                case 14:
                    message.charm = reader.int32();
                    break;
                case 15:
                    message.roomType = reader.int32();
                    break;
                case 16:
                    message.createOpenMic = reader.bool();
                    break;
                case 17:
                    message.jobId = reader.int32();
                    break;
                case 18:
                    message.roomContribute = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.worldContribute = reader.string();
                    break;
                case 20:
                    message.friendRoomData = $root.RoomResult.FriendRoomData.decode(reader, reader.uint32());
                    break;
                case 21:
                    if (!(message.micQues && message.micQues.length))
                        message.micQues = [];
                    message.micQues.push($root.UserResult.UserBase.decode(reader, reader.uint32()));
                    break;
                case 22:
                    if (!(message.kickData && message.kickData.length))
                        message.kickData = [];
                    message.kickData.push($root.RoomResult.KickData.decode(reader, reader.uint32()));
                    break;
                case 23:
                    message.roomMode = reader.int32();
                    break;
                case 24:
                    message.freeGiftRemainTime = reader.int32();
                    break;
                case 25:
                    message.cpRoomData = $root.RoomResult.CPRoomData.decode(reader, reader.uint32());
                    break;
                case 26:
                    message.guardMemberCount = reader.int32();
                    break;
                case 27:
                    message.guardName = reader.string();
                    break;
                case 28:
                    message.isGuardian = reader.bool();
                    break;
                case 29:
                    message.guardianLv = reader.int32();
                    break;
                case 30:
                    message.roomCharm = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.worldCharm = reader.string();
                    break;
                case 32:
                    message.logoTime = reader.int32();
                    break;
                case 33:
                    if (!(message.dragonBalls && message.dragonBalls.length))
                        message.dragonBalls = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.dragonBalls.push(reader.int32());
                    } else
                        message.dragonBalls.push(reader.int32());
                    break;
                case 34:
                    message.hatId = reader.string();
                    break;
                case 35:
                    message.anchorHatId = reader.string();
                    break;
                case 36:
                    message.contribute = reader.int64();
                    break;
                case 37:
                    message.roomOwnerId = reader.string();
                    break;
                case 38:
                    message.roomGroupId = reader.string();
                    break;
                case 39:
                    message.isInRoomGroup = reader.bool();
                    break;
                case 40:
                    message.liveflowUrl = reader.string();
                    break;
                case 41:
                    message.createOpenVideo = reader.bool();
                    break;
                case 42:
                    message.roomH5 = reader.int32();
                    break;
                case 43:
                    message.cardType = reader.int32();
                    break;
                case 44:
                    message.anchorCardType = reader.int32();
                    break;
                case 45:
                    if (!(message.micQuesCardType && message.micQuesCardType.length))
                        message.micQuesCardType = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.micQuesCardType.push(reader.int32());
                    } else
                        message.micQuesCardType.push(reader.int32());
                    break;
                case 46:
                    message.newContribute = reader.int64();
                    break;
                case 47:
                    message.isFavourHall = reader.bool();
                    break;
                case 48:
                    message.createHeartValue = reader.int64();
                    break;
                case 49:
                    message.offlineMode = reader.bool();
                    break;
                case 50:
                    message.crossRoomPk = $root.RoomResult.CrossRoomPk.decode(reader, reader.uint32());
                    break;
                case 51:
                    message.giftAnimation = reader.bool();
                    break;
                case 52:
                    message.dashBoardToken = reader.string();
                    break;
                case 53:
                    message.password = reader.string();
                    break;
                case 54:
                    message.chatRoomData = $root.RoomResult.ChatRoomData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("createId"))
                throw $util.ProtocolError("missing required 'createId'", { instance: message });
            if (!message.hasOwnProperty("bg"))
                throw $util.ProtocolError("missing required 'bg'", { instance: message });
            return message;
        };

        /**
         * Decodes a RoomData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomData} RoomData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomData;
    })();

    RoomResult.ChatRoomData = (function() {

        /**
         * Properties of a ChatRoomData.
         * @memberof RoomResult
         * @interface IChatRoomData
         * @property {number|null} [chatTime] ChatRoomData chatTime
         * @property {number|null} [anchorMoney] ChatRoomData anchorMoney
         * @property {number|null} [ltMinute] ChatRoomData ltMinute
         */

        /**
         * Constructs a new ChatRoomData.
         * @memberof RoomResult
         * @classdesc Represents a ChatRoomData.
         * @implements IChatRoomData
         * @constructor
         * @param {RoomResult.IChatRoomData=} [properties] Properties to set
         */
        function ChatRoomData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatRoomData chatTime.
         * @member {number} chatTime
         * @memberof RoomResult.ChatRoomData
         * @instance
         */
        ChatRoomData.prototype.chatTime = 0;

        /**
         * ChatRoomData anchorMoney.
         * @member {number} anchorMoney
         * @memberof RoomResult.ChatRoomData
         * @instance
         */
        ChatRoomData.prototype.anchorMoney = 0;

        /**
         * ChatRoomData ltMinute.
         * @member {number} ltMinute
         * @memberof RoomResult.ChatRoomData
         * @instance
         */
        ChatRoomData.prototype.ltMinute = 0;

        /**
         * Decodes a ChatRoomData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.ChatRoomData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.ChatRoomData} ChatRoomData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatRoomData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.ChatRoomData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chatTime = reader.int32();
                    break;
                case 2:
                    message.anchorMoney = reader.int32();
                    break;
                case 3:
                    message.ltMinute = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatRoomData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.ChatRoomData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.ChatRoomData} ChatRoomData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatRoomData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ChatRoomData;
    })();

    RoomResult.CPRoomData = (function() {

        /**
         * Properties of a CPRoomData.
         * @memberof RoomResult
         * @interface ICPRoomData
         * @property {number|Long|null} [cpLeftTime] CPRoomData cpLeftTime
         * @property {string|null} [oldRoomId] CPRoomData oldRoomId
         */

        /**
         * Constructs a new CPRoomData.
         * @memberof RoomResult
         * @classdesc Represents a CPRoomData.
         * @implements ICPRoomData
         * @constructor
         * @param {RoomResult.ICPRoomData=} [properties] Properties to set
         */
        function CPRoomData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CPRoomData cpLeftTime.
         * @member {number|Long} cpLeftTime
         * @memberof RoomResult.CPRoomData
         * @instance
         */
        CPRoomData.prototype.cpLeftTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CPRoomData oldRoomId.
         * @member {string} oldRoomId
         * @memberof RoomResult.CPRoomData
         * @instance
         */
        CPRoomData.prototype.oldRoomId = "";

        /**
         * Decodes a CPRoomData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.CPRoomData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.CPRoomData} CPRoomData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CPRoomData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.CPRoomData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cpLeftTime = reader.int64();
                    break;
                case 2:
                    message.oldRoomId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CPRoomData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.CPRoomData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.CPRoomData} CPRoomData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CPRoomData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CPRoomData;
    })();

    RoomResult.CPRoomBroadcast = (function() {

        /**
         * Properties of a CPRoomBroadcast.
         * @memberof RoomResult
         * @interface ICPRoomBroadcast
         * @property {number} status CPRoomBroadcast status
         * @property {UserResult.IUserBase|null} [inviter] CPRoomBroadcast inviter
         * @property {UserResult.IUserBase|null} [user1] CPRoomBroadcast user1
         * @property {UserResult.IUserBase|null} [user2] CPRoomBroadcast user2
         * @property {string|null} [cpRoomId] CPRoomBroadcast cpRoomId
         * @property {string|null} [oldRoomId] CPRoomBroadcast oldRoomId
         * @property {number|null} [duration] CPRoomBroadcast duration
         */

        /**
         * Constructs a new CPRoomBroadcast.
         * @memberof RoomResult
         * @classdesc Represents a CPRoomBroadcast.
         * @implements ICPRoomBroadcast
         * @constructor
         * @param {RoomResult.ICPRoomBroadcast=} [properties] Properties to set
         */
        function CPRoomBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CPRoomBroadcast status.
         * @member {number} status
         * @memberof RoomResult.CPRoomBroadcast
         * @instance
         */
        CPRoomBroadcast.prototype.status = 0;

        /**
         * CPRoomBroadcast inviter.
         * @member {UserResult.IUserBase|null|undefined} inviter
         * @memberof RoomResult.CPRoomBroadcast
         * @instance
         */
        CPRoomBroadcast.prototype.inviter = null;

        /**
         * CPRoomBroadcast user1.
         * @member {UserResult.IUserBase|null|undefined} user1
         * @memberof RoomResult.CPRoomBroadcast
         * @instance
         */
        CPRoomBroadcast.prototype.user1 = null;

        /**
         * CPRoomBroadcast user2.
         * @member {UserResult.IUserBase|null|undefined} user2
         * @memberof RoomResult.CPRoomBroadcast
         * @instance
         */
        CPRoomBroadcast.prototype.user2 = null;

        /**
         * CPRoomBroadcast cpRoomId.
         * @member {string} cpRoomId
         * @memberof RoomResult.CPRoomBroadcast
         * @instance
         */
        CPRoomBroadcast.prototype.cpRoomId = "";

        /**
         * CPRoomBroadcast oldRoomId.
         * @member {string} oldRoomId
         * @memberof RoomResult.CPRoomBroadcast
         * @instance
         */
        CPRoomBroadcast.prototype.oldRoomId = "";

        /**
         * CPRoomBroadcast duration.
         * @member {number} duration
         * @memberof RoomResult.CPRoomBroadcast
         * @instance
         */
        CPRoomBroadcast.prototype.duration = 0;

        /**
         * Decodes a CPRoomBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.CPRoomBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.CPRoomBroadcast} CPRoomBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CPRoomBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.CPRoomBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.inviter = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.user1 = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.user2 = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.cpRoomId = reader.string();
                    break;
                case 6:
                    message.oldRoomId = reader.string();
                    break;
                case 7:
                    message.duration = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes a CPRoomBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.CPRoomBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.CPRoomBroadcast} CPRoomBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CPRoomBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CPRoomBroadcast;
    })();

    RoomResult.FriendRoomData = (function() {

        /**
         * Properties of a FriendRoomData.
         * @memberof RoomResult
         * @interface IFriendRoomData
         * @property {number|null} [stage] FriendRoomData stage
         * @property {number|Long|null} [stageLeftTime] FriendRoomData stageLeftTime
         */

        /**
         * Constructs a new FriendRoomData.
         * @memberof RoomResult
         * @classdesc Represents a FriendRoomData.
         * @implements IFriendRoomData
         * @constructor
         * @param {RoomResult.IFriendRoomData=} [properties] Properties to set
         */
        function FriendRoomData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendRoomData stage.
         * @member {number} stage
         * @memberof RoomResult.FriendRoomData
         * @instance
         */
        FriendRoomData.prototype.stage = 0;

        /**
         * FriendRoomData stageLeftTime.
         * @member {number|Long} stageLeftTime
         * @memberof RoomResult.FriendRoomData
         * @instance
         */
        FriendRoomData.prototype.stageLeftTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a FriendRoomData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.FriendRoomData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.FriendRoomData} FriendRoomData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendRoomData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.FriendRoomData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stage = reader.int32();
                    break;
                case 2:
                    message.stageLeftTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendRoomData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.FriendRoomData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.FriendRoomData} FriendRoomData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendRoomData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FriendRoomData;
    })();

    RoomResult.FriendRoomStageBroadcast = (function() {

        /**
         * Properties of a FriendRoomStageBroadcast.
         * @memberof RoomResult
         * @interface IFriendRoomStageBroadcast
         * @property {RoomResult.IFriendRoomData|null} [friendRoomData] FriendRoomStageBroadcast friendRoomData
         * @property {Array.<RoomResult.IFriendMatchData>|null} [matchDatas] FriendRoomStageBroadcast matchDatas
         */

        /**
         * Constructs a new FriendRoomStageBroadcast.
         * @memberof RoomResult
         * @classdesc Represents a FriendRoomStageBroadcast.
         * @implements IFriendRoomStageBroadcast
         * @constructor
         * @param {RoomResult.IFriendRoomStageBroadcast=} [properties] Properties to set
         */
        function FriendRoomStageBroadcast(properties) {
            this.matchDatas = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendRoomStageBroadcast friendRoomData.
         * @member {RoomResult.IFriendRoomData|null|undefined} friendRoomData
         * @memberof RoomResult.FriendRoomStageBroadcast
         * @instance
         */
        FriendRoomStageBroadcast.prototype.friendRoomData = null;

        /**
         * FriendRoomStageBroadcast matchDatas.
         * @member {Array.<RoomResult.IFriendMatchData>} matchDatas
         * @memberof RoomResult.FriendRoomStageBroadcast
         * @instance
         */
        FriendRoomStageBroadcast.prototype.matchDatas = $util.emptyArray;

        /**
         * Decodes a FriendRoomStageBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.FriendRoomStageBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.FriendRoomStageBroadcast} FriendRoomStageBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendRoomStageBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.FriendRoomStageBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.friendRoomData = $root.RoomResult.FriendRoomData.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.matchDatas && message.matchDatas.length))
                        message.matchDatas = [];
                    message.matchDatas.push($root.RoomResult.FriendMatchData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendRoomStageBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.FriendRoomStageBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.FriendRoomStageBroadcast} FriendRoomStageBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendRoomStageBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FriendRoomStageBroadcast;
    })();

    RoomResult.FriendMatchData = (function() {

        /**
         * Properties of a FriendMatchData.
         * @memberof RoomResult
         * @interface IFriendMatchData
         * @property {UserResult.IUserBase|null} [base1] FriendMatchData base1
         * @property {UserResult.IUserBase|null} [base2] FriendMatchData base2
         * @property {number|Long|null} [totalValue] FriendMatchData totalValue
         */

        /**
         * Constructs a new FriendMatchData.
         * @memberof RoomResult
         * @classdesc Represents a FriendMatchData.
         * @implements IFriendMatchData
         * @constructor
         * @param {RoomResult.IFriendMatchData=} [properties] Properties to set
         */
        function FriendMatchData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendMatchData base1.
         * @member {UserResult.IUserBase|null|undefined} base1
         * @memberof RoomResult.FriendMatchData
         * @instance
         */
        FriendMatchData.prototype.base1 = null;

        /**
         * FriendMatchData base2.
         * @member {UserResult.IUserBase|null|undefined} base2
         * @memberof RoomResult.FriendMatchData
         * @instance
         */
        FriendMatchData.prototype.base2 = null;

        /**
         * FriendMatchData totalValue.
         * @member {number|Long} totalValue
         * @memberof RoomResult.FriendMatchData
         * @instance
         */
        FriendMatchData.prototype.totalValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a FriendMatchData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.FriendMatchData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.FriendMatchData} FriendMatchData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendMatchData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.FriendMatchData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base1 = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.base2 = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.totalValue = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendMatchData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.FriendMatchData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.FriendMatchData} FriendMatchData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendMatchData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FriendMatchData;
    })();

    RoomResult.RoomMicData = (function() {

        /**
         * Properties of a RoomMicData.
         * @memberof RoomResult
         * @interface IRoomMicData
         * @property {Array.<RoomResult.IMicInfo>|null} [infos] RoomMicData infos
         */

        /**
         * Constructs a new RoomMicData.
         * @memberof RoomResult
         * @classdesc Represents a RoomMicData.
         * @implements IRoomMicData
         * @constructor
         * @param {RoomResult.IRoomMicData=} [properties] Properties to set
         */
        function RoomMicData(properties) {
            this.infos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomMicData infos.
         * @member {Array.<RoomResult.IMicInfo>} infos
         * @memberof RoomResult.RoomMicData
         * @instance
         */
        RoomMicData.prototype.infos = $util.emptyArray;

        /**
         * Decodes a RoomMicData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomMicData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomMicData} RoomMicData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomMicData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomMicData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.RoomResult.MicInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoomMicData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomMicData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomMicData} RoomMicData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomMicData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomMicData;
    })();

    RoomResult.MicInfo = (function() {

        /**
         * Properties of a MicInfo.
         * @memberof RoomResult
         * @interface IMicInfo
         * @property {UserResult.IUserBase|null} [base] MicInfo base
         * @property {number|null} [position] MicInfo position
         * @property {boolean|null} [lock] MicInfo lock
         * @property {boolean|null} [forbidMic] MicInfo forbidMic
         * @property {string|null} [friendRemark] MicInfo friendRemark
         * @property {boolean|null} [openMic] MicInfo openMic
         * @property {number|Long|null} [forbidTime] MicInfo forbidTime
         * @property {number|Long|null} [heartValue] MicInfo heartValue
         * @property {string|null} [chooseId] MicInfo chooseId
         * @property {number|null} [jobId] MicInfo jobId
         * @property {string|null} [hatId] MicInfo hatId
         * @property {boolean|null} [isHatBuff] MicInfo isHatBuff
         * @property {Array.<number>|null} [dragonBalls] MicInfo dragonBalls
         * @property {Array.<UserResult.IUserBase>|null} [contributeUser] MicInfo contributeUser
         * @property {string|null} [banners] MicInfo banners
         * @property {boolean|null} [openVideo] MicInfo openVideo
         * @property {number|Long|null} [micOverTime] MicInfo micOverTime
         * @property {number|null} [cardType] MicInfo cardType
         */

        /**
         * Constructs a new MicInfo.
         * @memberof RoomResult
         * @classdesc Represents a MicInfo.
         * @implements IMicInfo
         * @constructor
         * @param {RoomResult.IMicInfo=} [properties] Properties to set
         */
        function MicInfo(properties) {
            this.dragonBalls = [];
            this.contributeUser = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MicInfo base.
         * @member {UserResult.IUserBase|null|undefined} base
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.base = null;

        /**
         * MicInfo position.
         * @member {number} position
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.position = 0;

        /**
         * MicInfo lock.
         * @member {boolean} lock
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.lock = false;

        /**
         * MicInfo forbidMic.
         * @member {boolean} forbidMic
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.forbidMic = false;

        /**
         * MicInfo friendRemark.
         * @member {string} friendRemark
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.friendRemark = "";

        /**
         * MicInfo openMic.
         * @member {boolean} openMic
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.openMic = false;

        /**
         * MicInfo forbidTime.
         * @member {number|Long} forbidTime
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.forbidTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MicInfo heartValue.
         * @member {number|Long} heartValue
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.heartValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MicInfo chooseId.
         * @member {string} chooseId
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.chooseId = "";

        /**
         * MicInfo jobId.
         * @member {number} jobId
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.jobId = 0;

        /**
         * MicInfo hatId.
         * @member {string} hatId
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.hatId = "";

        /**
         * MicInfo isHatBuff.
         * @member {boolean} isHatBuff
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.isHatBuff = false;

        /**
         * MicInfo dragonBalls.
         * @member {Array.<number>} dragonBalls
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.dragonBalls = $util.emptyArray;

        /**
         * MicInfo contributeUser.
         * @member {Array.<UserResult.IUserBase>} contributeUser
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.contributeUser = $util.emptyArray;

        /**
         * MicInfo banners.
         * @member {string} banners
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.banners = "";

        /**
         * MicInfo openVideo.
         * @member {boolean} openVideo
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.openVideo = false;

        /**
         * MicInfo micOverTime.
         * @member {number|Long} micOverTime
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.micOverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MicInfo cardType.
         * @member {number} cardType
         * @memberof RoomResult.MicInfo
         * @instance
         */
        MicInfo.prototype.cardType = 0;

        /**
         * Decodes a MicInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.MicInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.MicInfo} MicInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MicInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.MicInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.position = reader.int32();
                    break;
                case 3:
                    message.lock = reader.bool();
                    break;
                case 4:
                    message.forbidMic = reader.bool();
                    break;
                case 5:
                    message.friendRemark = reader.string();
                    break;
                case 6:
                    message.openMic = reader.bool();
                    break;
                case 7:
                    message.forbidTime = reader.int64();
                    break;
                case 8:
                    message.heartValue = reader.int64();
                    break;
                case 9:
                    message.chooseId = reader.string();
                    break;
                case 10:
                    message.jobId = reader.int32();
                    break;
                case 11:
                    message.hatId = reader.string();
                    break;
                case 12:
                    message.isHatBuff = reader.bool();
                    break;
                case 13:
                    if (!(message.dragonBalls && message.dragonBalls.length))
                        message.dragonBalls = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.dragonBalls.push(reader.int32());
                    } else
                        message.dragonBalls.push(reader.int32());
                    break;
                case 14:
                    if (!(message.contributeUser && message.contributeUser.length))
                        message.contributeUser = [];
                    message.contributeUser.push($root.UserResult.UserBase.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message.banners = reader.string();
                    break;
                case 16:
                    message.openVideo = reader.bool();
                    break;
                case 17:
                    message.micOverTime = reader.int64();
                    break;
                case 18:
                    message.cardType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MicInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.MicInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.MicInfo} MicInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MicInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MicInfo;
    })();

    RoomResult.RoomConfigData = (function() {

        /**
         * Properties of a RoomConfigData.
         * @memberof RoomResult
         * @interface IRoomConfigData
         * @property {boolean|null} [password] RoomConfigData password
         * @property {boolean|null} [autoMic] RoomConfigData autoMic
         * @property {boolean|null} [hasFreeModeEntrance] RoomConfigData hasFreeModeEntrance
         */

        /**
         * Constructs a new RoomConfigData.
         * @memberof RoomResult
         * @classdesc Represents a RoomConfigData.
         * @implements IRoomConfigData
         * @constructor
         * @param {RoomResult.IRoomConfigData=} [properties] Properties to set
         */
        function RoomConfigData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomConfigData password.
         * @member {boolean} password
         * @memberof RoomResult.RoomConfigData
         * @instance
         */
        RoomConfigData.prototype.password = false;

        /**
         * RoomConfigData autoMic.
         * @member {boolean} autoMic
         * @memberof RoomResult.RoomConfigData
         * @instance
         */
        RoomConfigData.prototype.autoMic = false;

        /**
         * RoomConfigData hasFreeModeEntrance.
         * @member {boolean} hasFreeModeEntrance
         * @memberof RoomResult.RoomConfigData
         * @instance
         */
        RoomConfigData.prototype.hasFreeModeEntrance = false;

        /**
         * Decodes a RoomConfigData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomConfigData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomConfigData} RoomConfigData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomConfigData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomConfigData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.password = reader.bool();
                    break;
                case 2:
                    message.autoMic = reader.bool();
                    break;
                case 3:
                    message.hasFreeModeEntrance = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoomConfigData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomConfigData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomConfigData} RoomConfigData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomConfigData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomConfigData;
    })();

    RoomResult.FunRoomDividedRateInfos = (function() {

        /**
         * Properties of a FunRoomDividedRateInfos.
         * @memberof RoomResult
         * @interface IFunRoomDividedRateInfos
         * @property {Array.<RoomResult.IFunRoomDividedRateInfo>|null} [list] FunRoomDividedRateInfos list
         */

        /**
         * Constructs a new FunRoomDividedRateInfos.
         * @memberof RoomResult
         * @classdesc Represents a FunRoomDividedRateInfos.
         * @implements IFunRoomDividedRateInfos
         * @constructor
         * @param {RoomResult.IFunRoomDividedRateInfos=} [properties] Properties to set
         */
        function FunRoomDividedRateInfos(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FunRoomDividedRateInfos list.
         * @member {Array.<RoomResult.IFunRoomDividedRateInfo>} list
         * @memberof RoomResult.FunRoomDividedRateInfos
         * @instance
         */
        FunRoomDividedRateInfos.prototype.list = $util.emptyArray;

        /**
         * Decodes a FunRoomDividedRateInfos message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.FunRoomDividedRateInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.FunRoomDividedRateInfos} FunRoomDividedRateInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunRoomDividedRateInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.FunRoomDividedRateInfos();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RoomResult.FunRoomDividedRateInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FunRoomDividedRateInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.FunRoomDividedRateInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.FunRoomDividedRateInfos} FunRoomDividedRateInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunRoomDividedRateInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FunRoomDividedRateInfos;
    })();

    RoomResult.FunRoomDividedRateInfo = (function() {

        /**
         * Properties of a FunRoomDividedRateInfo.
         * @memberof RoomResult
         * @interface IFunRoomDividedRateInfo
         * @property {string} dividedId FunRoomDividedRateInfo dividedId
         * @property {string} desc FunRoomDividedRateInfo desc
         * @property {string} detail FunRoomDividedRateInfo detail
         * @property {boolean} isShow FunRoomDividedRateInfo isShow
         * @property {boolean} isSelected FunRoomDividedRateInfo isSelected
         */

        /**
         * Constructs a new FunRoomDividedRateInfo.
         * @memberof RoomResult
         * @classdesc Represents a FunRoomDividedRateInfo.
         * @implements IFunRoomDividedRateInfo
         * @constructor
         * @param {RoomResult.IFunRoomDividedRateInfo=} [properties] Properties to set
         */
        function FunRoomDividedRateInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FunRoomDividedRateInfo dividedId.
         * @member {string} dividedId
         * @memberof RoomResult.FunRoomDividedRateInfo
         * @instance
         */
        FunRoomDividedRateInfo.prototype.dividedId = "";

        /**
         * FunRoomDividedRateInfo desc.
         * @member {string} desc
         * @memberof RoomResult.FunRoomDividedRateInfo
         * @instance
         */
        FunRoomDividedRateInfo.prototype.desc = "";

        /**
         * FunRoomDividedRateInfo detail.
         * @member {string} detail
         * @memberof RoomResult.FunRoomDividedRateInfo
         * @instance
         */
        FunRoomDividedRateInfo.prototype.detail = "";

        /**
         * FunRoomDividedRateInfo isShow.
         * @member {boolean} isShow
         * @memberof RoomResult.FunRoomDividedRateInfo
         * @instance
         */
        FunRoomDividedRateInfo.prototype.isShow = false;

        /**
         * FunRoomDividedRateInfo isSelected.
         * @member {boolean} isSelected
         * @memberof RoomResult.FunRoomDividedRateInfo
         * @instance
         */
        FunRoomDividedRateInfo.prototype.isSelected = false;

        /**
         * Decodes a FunRoomDividedRateInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.FunRoomDividedRateInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.FunRoomDividedRateInfo} FunRoomDividedRateInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunRoomDividedRateInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.FunRoomDividedRateInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dividedId = reader.string();
                    break;
                case 2:
                    message.desc = reader.string();
                    break;
                case 3:
                    message.detail = reader.string();
                    break;
                case 4:
                    message.isShow = reader.bool();
                    break;
                case 5:
                    message.isSelected = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("dividedId"))
                throw $util.ProtocolError("missing required 'dividedId'", { instance: message });
            if (!message.hasOwnProperty("desc"))
                throw $util.ProtocolError("missing required 'desc'", { instance: message });
            if (!message.hasOwnProperty("detail"))
                throw $util.ProtocolError("missing required 'detail'", { instance: message });
            if (!message.hasOwnProperty("isShow"))
                throw $util.ProtocolError("missing required 'isShow'", { instance: message });
            if (!message.hasOwnProperty("isSelected"))
                throw $util.ProtocolError("missing required 'isSelected'", { instance: message });
            return message;
        };

        /**
         * Decodes a FunRoomDividedRateInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.FunRoomDividedRateInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.FunRoomDividedRateInfo} FunRoomDividedRateInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunRoomDividedRateInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FunRoomDividedRateInfo;
    })();

    RoomResult.AtRoomUserBroadcast = (function() {

        /**
         * Properties of an AtRoomUserBroadcast.
         * @memberof RoomResult
         * @interface IAtRoomUserBroadcast
         * @property {string} roomId AtRoomUserBroadcast roomId
         * @property {string} userId AtRoomUserBroadcast userId
         */

        /**
         * Constructs a new AtRoomUserBroadcast.
         * @memberof RoomResult
         * @classdesc Represents an AtRoomUserBroadcast.
         * @implements IAtRoomUserBroadcast
         * @constructor
         * @param {RoomResult.IAtRoomUserBroadcast=} [properties] Properties to set
         */
        function AtRoomUserBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AtRoomUserBroadcast roomId.
         * @member {string} roomId
         * @memberof RoomResult.AtRoomUserBroadcast
         * @instance
         */
        AtRoomUserBroadcast.prototype.roomId = "";

        /**
         * AtRoomUserBroadcast userId.
         * @member {string} userId
         * @memberof RoomResult.AtRoomUserBroadcast
         * @instance
         */
        AtRoomUserBroadcast.prototype.userId = "";

        /**
         * Decodes an AtRoomUserBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.AtRoomUserBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.AtRoomUserBroadcast} AtRoomUserBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtRoomUserBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.AtRoomUserBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            return message;
        };

        /**
         * Decodes an AtRoomUserBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.AtRoomUserBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.AtRoomUserBroadcast} AtRoomUserBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtRoomUserBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return AtRoomUserBroadcast;
    })();

    RoomResult.MemberList = (function() {

        /**
         * Properties of a MemberList.
         * @memberof RoomResult
         * @interface IMemberList
         * @property {Array.<RoomResult.IMemberInfo>|null} [list] MemberList list
         * @property {number} onlineNum MemberList onlineNum
         */

        /**
         * Constructs a new MemberList.
         * @memberof RoomResult
         * @classdesc Represents a MemberList.
         * @implements IMemberList
         * @constructor
         * @param {RoomResult.IMemberList=} [properties] Properties to set
         */
        function MemberList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemberList list.
         * @member {Array.<RoomResult.IMemberInfo>} list
         * @memberof RoomResult.MemberList
         * @instance
         */
        MemberList.prototype.list = $util.emptyArray;

        /**
         * MemberList onlineNum.
         * @member {number} onlineNum
         * @memberof RoomResult.MemberList
         * @instance
         */
        MemberList.prototype.onlineNum = 0;

        /**
         * Decodes a MemberList message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.MemberList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.MemberList} MemberList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.MemberList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RoomResult.MemberInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.onlineNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("onlineNum"))
                throw $util.ProtocolError("missing required 'onlineNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a MemberList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.MemberList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.MemberList} MemberList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MemberList;
    })();

    RoomResult.MemberInfo = (function() {

        /**
         * Properties of a MemberInfo.
         * @memberof RoomResult
         * @interface IMemberInfo
         * @property {UserResult.IUserBase} base MemberInfo base
         * @property {number|null} [jobId] MemberInfo jobId
         * @property {boolean|null} [onMic] MemberInfo onMic
         * @property {number|null} [cardType] MemberInfo cardType
         */

        /**
         * Constructs a new MemberInfo.
         * @memberof RoomResult
         * @classdesc Represents a MemberInfo.
         * @implements IMemberInfo
         * @constructor
         * @param {RoomResult.IMemberInfo=} [properties] Properties to set
         */
        function MemberInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemberInfo base.
         * @member {UserResult.IUserBase} base
         * @memberof RoomResult.MemberInfo
         * @instance
         */
        MemberInfo.prototype.base = null;

        /**
         * MemberInfo jobId.
         * @member {number} jobId
         * @memberof RoomResult.MemberInfo
         * @instance
         */
        MemberInfo.prototype.jobId = 0;

        /**
         * MemberInfo onMic.
         * @member {boolean} onMic
         * @memberof RoomResult.MemberInfo
         * @instance
         */
        MemberInfo.prototype.onMic = false;

        /**
         * MemberInfo cardType.
         * @member {number} cardType
         * @memberof RoomResult.MemberInfo
         * @instance
         */
        MemberInfo.prototype.cardType = 0;

        /**
         * Decodes a MemberInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.MemberInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.MemberInfo} MemberInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.MemberInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.jobId = reader.int32();
                    break;
                case 3:
                    message.onMic = reader.bool();
                    break;
                case 4:
                    message.cardType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("base"))
                throw $util.ProtocolError("missing required 'base'", { instance: message });
            return message;
        };

        /**
         * Decodes a MemberInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.MemberInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.MemberInfo} MemberInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MemberInfo;
    })();

    RoomResult.EnterRoomBroadcast = (function() {

        /**
         * Properties of an EnterRoomBroadcast.
         * @memberof RoomResult
         * @interface IEnterRoomBroadcast
         * @property {string} roomId EnterRoomBroadcast roomId
         * @property {number} mainType EnterRoomBroadcast mainType
         * @property {UserResult.IUserBase} base EnterRoomBroadcast base
         * @property {number|null} [onlineNum] EnterRoomBroadcast onlineNum
         * @property {number} index EnterRoomBroadcast index
         * @property {string|null} [carId] EnterRoomBroadcast carId
         * @property {number|null} [charmLv] EnterRoomBroadcast charmLv
         * @property {number|null} [contributeLv] EnterRoomBroadcast contributeLv
         * @property {boolean|null} [openMirror] EnterRoomBroadcast openMirror
         * @property {number|null} [identity] EnterRoomBroadcast identity
         * @property {number|null} [source] EnterRoomBroadcast source
         * @property {number|Long|null} [loginTime] EnterRoomBroadcast loginTime
         * @property {boolean|null} [showCar] EnterRoomBroadcast showCar
         * @property {number|null} [jobId] EnterRoomBroadcast jobId
         * @property {boolean|null} [isGuardian] EnterRoomBroadcast isGuardian
         * @property {number|null} [guardianLv] EnterRoomBroadcast guardianLv
         * @property {number|null} [cardType] EnterRoomBroadcast cardType
         */

        /**
         * Constructs a new EnterRoomBroadcast.
         * @memberof RoomResult
         * @classdesc Represents an EnterRoomBroadcast.
         * @implements IEnterRoomBroadcast
         * @constructor
         * @param {RoomResult.IEnterRoomBroadcast=} [properties] Properties to set
         */
        function EnterRoomBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterRoomBroadcast roomId.
         * @member {string} roomId
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.roomId = "";

        /**
         * EnterRoomBroadcast mainType.
         * @member {number} mainType
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.mainType = 0;

        /**
         * EnterRoomBroadcast base.
         * @member {UserResult.IUserBase} base
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.base = null;

        /**
         * EnterRoomBroadcast onlineNum.
         * @member {number} onlineNum
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.onlineNum = 0;

        /**
         * EnterRoomBroadcast index.
         * @member {number} index
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.index = 0;

        /**
         * EnterRoomBroadcast carId.
         * @member {string} carId
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.carId = "";

        /**
         * EnterRoomBroadcast charmLv.
         * @member {number} charmLv
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.charmLv = 0;

        /**
         * EnterRoomBroadcast contributeLv.
         * @member {number} contributeLv
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.contributeLv = 0;

        /**
         * EnterRoomBroadcast openMirror.
         * @member {boolean} openMirror
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.openMirror = false;

        /**
         * EnterRoomBroadcast identity.
         * @member {number} identity
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.identity = 0;

        /**
         * EnterRoomBroadcast source.
         * @member {number} source
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.source = 0;

        /**
         * EnterRoomBroadcast loginTime.
         * @member {number|Long} loginTime
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.loginTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterRoomBroadcast showCar.
         * @member {boolean} showCar
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.showCar = false;

        /**
         * EnterRoomBroadcast jobId.
         * @member {number} jobId
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.jobId = 0;

        /**
         * EnterRoomBroadcast isGuardian.
         * @member {boolean} isGuardian
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.isGuardian = false;

        /**
         * EnterRoomBroadcast guardianLv.
         * @member {number} guardianLv
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.guardianLv = 0;

        /**
         * EnterRoomBroadcast cardType.
         * @member {number} cardType
         * @memberof RoomResult.EnterRoomBroadcast
         * @instance
         */
        EnterRoomBroadcast.prototype.cardType = 0;

        /**
         * Decodes an EnterRoomBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.EnterRoomBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.EnterRoomBroadcast} EnterRoomBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterRoomBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.EnterRoomBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.mainType = reader.int32();
                    break;
                case 3:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.onlineNum = reader.int32();
                    break;
                case 5:
                    message.index = reader.int32();
                    break;
                case 6:
                    message.carId = reader.string();
                    break;
                case 7:
                    message.charmLv = reader.int32();
                    break;
                case 8:
                    message.contributeLv = reader.int32();
                    break;
                case 9:
                    message.openMirror = reader.bool();
                    break;
                case 10:
                    message.identity = reader.int32();
                    break;
                case 11:
                    message.source = reader.int32();
                    break;
                case 12:
                    message.loginTime = reader.int64();
                    break;
                case 13:
                    message.showCar = reader.bool();
                    break;
                case 14:
                    message.jobId = reader.int32();
                    break;
                case 15:
                    message.isGuardian = reader.bool();
                    break;
                case 17:
                    message.guardianLv = reader.int32();
                    break;
                case 18:
                    message.cardType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("mainType"))
                throw $util.ProtocolError("missing required 'mainType'", { instance: message });
            if (!message.hasOwnProperty("base"))
                throw $util.ProtocolError("missing required 'base'", { instance: message });
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };

        /**
         * Decodes an EnterRoomBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.EnterRoomBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.EnterRoomBroadcast} EnterRoomBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterRoomBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return EnterRoomBroadcast;
    })();

    RoomResult.LeaveRoomBroadcast = (function() {

        /**
         * Properties of a LeaveRoomBroadcast.
         * @memberof RoomResult
         * @interface ILeaveRoomBroadcast
         * @property {string} roomId LeaveRoomBroadcast roomId
         * @property {number} mainType LeaveRoomBroadcast mainType
         * @property {string} userId LeaveRoomBroadcast userId
         * @property {number} onlineNum LeaveRoomBroadcast onlineNum
         */

        /**
         * Constructs a new LeaveRoomBroadcast.
         * @memberof RoomResult
         * @classdesc Represents a LeaveRoomBroadcast.
         * @implements ILeaveRoomBroadcast
         * @constructor
         * @param {RoomResult.ILeaveRoomBroadcast=} [properties] Properties to set
         */
        function LeaveRoomBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LeaveRoomBroadcast roomId.
         * @member {string} roomId
         * @memberof RoomResult.LeaveRoomBroadcast
         * @instance
         */
        LeaveRoomBroadcast.prototype.roomId = "";

        /**
         * LeaveRoomBroadcast mainType.
         * @member {number} mainType
         * @memberof RoomResult.LeaveRoomBroadcast
         * @instance
         */
        LeaveRoomBroadcast.prototype.mainType = 0;

        /**
         * LeaveRoomBroadcast userId.
         * @member {string} userId
         * @memberof RoomResult.LeaveRoomBroadcast
         * @instance
         */
        LeaveRoomBroadcast.prototype.userId = "";

        /**
         * LeaveRoomBroadcast onlineNum.
         * @member {number} onlineNum
         * @memberof RoomResult.LeaveRoomBroadcast
         * @instance
         */
        LeaveRoomBroadcast.prototype.onlineNum = 0;

        /**
         * Decodes a LeaveRoomBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.LeaveRoomBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.LeaveRoomBroadcast} LeaveRoomBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaveRoomBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.LeaveRoomBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 3:
                    message.mainType = reader.int32();
                    break;
                case 4:
                    message.userId = reader.string();
                    break;
                case 5:
                    message.onlineNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("mainType"))
                throw $util.ProtocolError("missing required 'mainType'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("onlineNum"))
                throw $util.ProtocolError("missing required 'onlineNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a LeaveRoomBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.LeaveRoomBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.LeaveRoomBroadcast} LeaveRoomBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaveRoomBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LeaveRoomBroadcast;
    })();

    RoomResult.RoomActionBroadcast = (function() {

        /**
         * Properties of a RoomActionBroadcast.
         * @memberof RoomResult
         * @interface IRoomActionBroadcast
         * @property {string} roomId RoomActionBroadcast roomId
         * @property {number} actType RoomActionBroadcast actType
         * @property {string} userId RoomActionBroadcast userId
         * @property {string} targetId RoomActionBroadcast targetId
         * @property {number} position RoomActionBroadcast position
         * @property {string|null} [param] RoomActionBroadcast param
         * @property {number|null} [mainType] RoomActionBroadcast mainType
         * @property {string|null} [nickName] RoomActionBroadcast nickName
         * @property {number|null} [sex] RoomActionBroadcast sex
         * @property {string|null} [targetNickName] RoomActionBroadcast targetNickName
         * @property {number|null} [targetSex] RoomActionBroadcast targetSex
         */

        /**
         * Constructs a new RoomActionBroadcast.
         * @memberof RoomResult
         * @classdesc Represents a RoomActionBroadcast.
         * @implements IRoomActionBroadcast
         * @constructor
         * @param {RoomResult.IRoomActionBroadcast=} [properties] Properties to set
         */
        function RoomActionBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomActionBroadcast roomId.
         * @member {string} roomId
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.roomId = "";

        /**
         * RoomActionBroadcast actType.
         * @member {number} actType
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.actType = 0;

        /**
         * RoomActionBroadcast userId.
         * @member {string} userId
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.userId = "";

        /**
         * RoomActionBroadcast targetId.
         * @member {string} targetId
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.targetId = "";

        /**
         * RoomActionBroadcast position.
         * @member {number} position
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.position = 0;

        /**
         * RoomActionBroadcast param.
         * @member {string} param
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.param = "";

        /**
         * RoomActionBroadcast mainType.
         * @member {number} mainType
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.mainType = 0;

        /**
         * RoomActionBroadcast nickName.
         * @member {string} nickName
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.nickName = "";

        /**
         * RoomActionBroadcast sex.
         * @member {number} sex
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.sex = 0;

        /**
         * RoomActionBroadcast targetNickName.
         * @member {string} targetNickName
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.targetNickName = "";

        /**
         * RoomActionBroadcast targetSex.
         * @member {number} targetSex
         * @memberof RoomResult.RoomActionBroadcast
         * @instance
         */
        RoomActionBroadcast.prototype.targetSex = 0;

        /**
         * Decodes a RoomActionBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomActionBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomActionBroadcast} RoomActionBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomActionBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomActionBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.actType = reader.int32();
                    break;
                case 3:
                    message.userId = reader.string();
                    break;
                case 4:
                    message.targetId = reader.string();
                    break;
                case 5:
                    message.position = reader.int32();
                    break;
                case 6:
                    message.param = reader.string();
                    break;
                case 7:
                    message.mainType = reader.int32();
                    break;
                case 8:
                    message.nickName = reader.string();
                    break;
                case 9:
                    message.sex = reader.int32();
                    break;
                case 10:
                    message.targetNickName = reader.string();
                    break;
                case 11:
                    message.targetSex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("actType"))
                throw $util.ProtocolError("missing required 'actType'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            if (!message.hasOwnProperty("position"))
                throw $util.ProtocolError("missing required 'position'", { instance: message });
            return message;
        };

        /**
         * Decodes a RoomActionBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomActionBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomActionBroadcast} RoomActionBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomActionBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomActionBroadcast;
    })();

    RoomResult.HandleRoomReportBroadcast = (function() {

        /**
         * Properties of a HandleRoomReportBroadcast.
         * @memberof RoomResult
         * @interface IHandleRoomReportBroadcast
         * @property {string} roomId HandleRoomReportBroadcast roomId
         * @property {number} handType HandleRoomReportBroadcast handType
         */

        /**
         * Constructs a new HandleRoomReportBroadcast.
         * @memberof RoomResult
         * @classdesc Represents a HandleRoomReportBroadcast.
         * @implements IHandleRoomReportBroadcast
         * @constructor
         * @param {RoomResult.IHandleRoomReportBroadcast=} [properties] Properties to set
         */
        function HandleRoomReportBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HandleRoomReportBroadcast roomId.
         * @member {string} roomId
         * @memberof RoomResult.HandleRoomReportBroadcast
         * @instance
         */
        HandleRoomReportBroadcast.prototype.roomId = "";

        /**
         * HandleRoomReportBroadcast handType.
         * @member {number} handType
         * @memberof RoomResult.HandleRoomReportBroadcast
         * @instance
         */
        HandleRoomReportBroadcast.prototype.handType = 0;

        /**
         * Decodes a HandleRoomReportBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.HandleRoomReportBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.HandleRoomReportBroadcast} HandleRoomReportBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HandleRoomReportBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.HandleRoomReportBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.handType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("handType"))
                throw $util.ProtocolError("missing required 'handType'", { instance: message });
            return message;
        };

        /**
         * Decodes a HandleRoomReportBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.HandleRoomReportBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.HandleRoomReportBroadcast} HandleRoomReportBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HandleRoomReportBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return HandleRoomReportBroadcast;
    })();

    RoomResult.RoomState = (function() {

        /**
         * Properties of a RoomState.
         * @memberof RoomResult
         * @interface IRoomState
         * @property {Array.<number>|null} [status] RoomState status
         */

        /**
         * Constructs a new RoomState.
         * @memberof RoomResult
         * @classdesc Represents a RoomState.
         * @implements IRoomState
         * @constructor
         * @param {RoomResult.IRoomState=} [properties] Properties to set
         */
        function RoomState(properties) {
            this.status = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomState status.
         * @member {Array.<number>} status
         * @memberof RoomResult.RoomState
         * @instance
         */
        RoomState.prototype.status = $util.emptyArray;

        /**
         * Decodes a RoomState message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomState} RoomState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.status && message.status.length))
                        message.status = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.status.push(reader.int32());
                    } else
                        message.status.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoomState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomState} RoomState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomState;
    })();

    RoomResult.RoomName = (function() {

        /**
         * Properties of a RoomName.
         * @memberof RoomResult
         * @interface IRoomName
         * @property {string} name RoomName name
         */

        /**
         * Constructs a new RoomName.
         * @memberof RoomResult
         * @classdesc Represents a RoomName.
         * @implements IRoomName
         * @constructor
         * @param {RoomResult.IRoomName=} [properties] Properties to set
         */
        function RoomName(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomName name.
         * @member {string} name
         * @memberof RoomResult.RoomName
         * @instance
         */
        RoomName.prototype.name = "";

        /**
         * Decodes a RoomName message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomName} RoomName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomName.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomName();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };

        /**
         * Decodes a RoomName message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomName} RoomName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomName.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomName;
    })();

    RoomResult.LivePushInfo = (function() {

        /**
         * Properties of a LivePushInfo.
         * @memberof RoomResult
         * @interface ILivePushInfo
         * @property {boolean} open LivePushInfo open
         * @property {Array.<string>|null} [userIds] LivePushInfo userIds
         */

        /**
         * Constructs a new LivePushInfo.
         * @memberof RoomResult
         * @classdesc Represents a LivePushInfo.
         * @implements ILivePushInfo
         * @constructor
         * @param {RoomResult.ILivePushInfo=} [properties] Properties to set
         */
        function LivePushInfo(properties) {
            this.userIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LivePushInfo open.
         * @member {boolean} open
         * @memberof RoomResult.LivePushInfo
         * @instance
         */
        LivePushInfo.prototype.open = false;

        /**
         * LivePushInfo userIds.
         * @member {Array.<string>} userIds
         * @memberof RoomResult.LivePushInfo
         * @instance
         */
        LivePushInfo.prototype.userIds = $util.emptyArray;

        /**
         * Decodes a LivePushInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.LivePushInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.LivePushInfo} LivePushInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LivePushInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.LivePushInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.open = reader.bool();
                    break;
                case 2:
                    if (!(message.userIds && message.userIds.length))
                        message.userIds = [];
                    message.userIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("open"))
                throw $util.ProtocolError("missing required 'open'", { instance: message });
            return message;
        };

        /**
         * Decodes a LivePushInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.LivePushInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.LivePushInfo} LivePushInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LivePushInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LivePushInfo;
    })();

    RoomResult.RecreationBroadcast = (function() {

        /**
         * Properties of a RecreationBroadcast.
         * @memberof RoomResult
         * @interface IRecreationBroadcast
         * @property {string} roomId RecreationBroadcast roomId
         * @property {string} userId RecreationBroadcast userId
         * @property {string} recreationId RecreationBroadcast recreationId
         * @property {Array.<number>|null} [results] RecreationBroadcast results
         */

        /**
         * Constructs a new RecreationBroadcast.
         * @memberof RoomResult
         * @classdesc Represents a RecreationBroadcast.
         * @implements IRecreationBroadcast
         * @constructor
         * @param {RoomResult.IRecreationBroadcast=} [properties] Properties to set
         */
        function RecreationBroadcast(properties) {
            this.results = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecreationBroadcast roomId.
         * @member {string} roomId
         * @memberof RoomResult.RecreationBroadcast
         * @instance
         */
        RecreationBroadcast.prototype.roomId = "";

        /**
         * RecreationBroadcast userId.
         * @member {string} userId
         * @memberof RoomResult.RecreationBroadcast
         * @instance
         */
        RecreationBroadcast.prototype.userId = "";

        /**
         * RecreationBroadcast recreationId.
         * @member {string} recreationId
         * @memberof RoomResult.RecreationBroadcast
         * @instance
         */
        RecreationBroadcast.prototype.recreationId = "";

        /**
         * RecreationBroadcast results.
         * @member {Array.<number>} results
         * @memberof RoomResult.RecreationBroadcast
         * @instance
         */
        RecreationBroadcast.prototype.results = $util.emptyArray;

        /**
         * Decodes a RecreationBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RecreationBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RecreationBroadcast} RecreationBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecreationBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RecreationBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.recreationId = reader.string();
                    break;
                case 4:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.results.push(reader.int32());
                    } else
                        message.results.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("recreationId"))
                throw $util.ProtocolError("missing required 'recreationId'", { instance: message });
            return message;
        };

        /**
         * Decodes a RecreationBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RecreationBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RecreationBroadcast} RecreationBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecreationBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RecreationBroadcast;
    })();

    RoomResult.EnterRoomList = (function() {

        /**
         * Properties of an EnterRoomList.
         * @memberof RoomResult
         * @interface IEnterRoomList
         * @property {Array.<string>|null} [roomIds] EnterRoomList roomIds
         */

        /**
         * Constructs a new EnterRoomList.
         * @memberof RoomResult
         * @classdesc Represents an EnterRoomList.
         * @implements IEnterRoomList
         * @constructor
         * @param {RoomResult.IEnterRoomList=} [properties] Properties to set
         */
        function EnterRoomList(properties) {
            this.roomIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterRoomList roomIds.
         * @member {Array.<string>} roomIds
         * @memberof RoomResult.EnterRoomList
         * @instance
         */
        EnterRoomList.prototype.roomIds = $util.emptyArray;

        /**
         * Decodes an EnterRoomList message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.EnterRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.EnterRoomList} EnterRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterRoomList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.EnterRoomList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.roomIds && message.roomIds.length))
                        message.roomIds = [];
                    message.roomIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterRoomList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.EnterRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.EnterRoomList} EnterRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterRoomList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return EnterRoomList;
    })();

    RoomResult.RoomInvite = (function() {

        /**
         * Properties of a RoomInvite.
         * @memberof RoomResult
         * @interface IRoomInvite
         * @property {UserResult.IUserBase} inviter RoomInvite inviter
         * @property {string|null} [constellation] RoomInvite constellation
         * @property {string|null} [roomId] RoomInvite roomId
         * @property {number|null} [roomType] RoomInvite roomType
         * @property {UserResult.IUserBase|null} [boyBase] RoomInvite boyBase
         * @property {UserResult.IUserBase|null} [girlBase] RoomInvite girlBase
         */

        /**
         * Constructs a new RoomInvite.
         * @memberof RoomResult
         * @classdesc Represents a RoomInvite.
         * @implements IRoomInvite
         * @constructor
         * @param {RoomResult.IRoomInvite=} [properties] Properties to set
         */
        function RoomInvite(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomInvite inviter.
         * @member {UserResult.IUserBase} inviter
         * @memberof RoomResult.RoomInvite
         * @instance
         */
        RoomInvite.prototype.inviter = null;

        /**
         * RoomInvite constellation.
         * @member {string} constellation
         * @memberof RoomResult.RoomInvite
         * @instance
         */
        RoomInvite.prototype.constellation = "";

        /**
         * RoomInvite roomId.
         * @member {string} roomId
         * @memberof RoomResult.RoomInvite
         * @instance
         */
        RoomInvite.prototype.roomId = "";

        /**
         * RoomInvite roomType.
         * @member {number} roomType
         * @memberof RoomResult.RoomInvite
         * @instance
         */
        RoomInvite.prototype.roomType = 0;

        /**
         * RoomInvite boyBase.
         * @member {UserResult.IUserBase|null|undefined} boyBase
         * @memberof RoomResult.RoomInvite
         * @instance
         */
        RoomInvite.prototype.boyBase = null;

        /**
         * RoomInvite girlBase.
         * @member {UserResult.IUserBase|null|undefined} girlBase
         * @memberof RoomResult.RoomInvite
         * @instance
         */
        RoomInvite.prototype.girlBase = null;

        /**
         * Decodes a RoomInvite message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomInvite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomInvite} RoomInvite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomInvite.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomInvite();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.inviter = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.constellation = reader.string();
                    break;
                case 3:
                    message.roomId = reader.string();
                    break;
                case 4:
                    message.roomType = reader.int32();
                    break;
                case 5:
                    message.boyBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.girlBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("inviter"))
                throw $util.ProtocolError("missing required 'inviter'", { instance: message });
            return message;
        };

        /**
         * Decodes a RoomInvite message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomInvite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomInvite} RoomInvite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomInvite.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomInvite;
    })();

    RoomResult.BreakInvite = (function() {

        /**
         * Properties of a BreakInvite.
         * @memberof RoomResult
         * @interface IBreakInvite
         * @property {number} reason BreakInvite reason
         * @property {string} targetId BreakInvite targetId
         */

        /**
         * Constructs a new BreakInvite.
         * @memberof RoomResult
         * @classdesc Represents a BreakInvite.
         * @implements IBreakInvite
         * @constructor
         * @param {RoomResult.IBreakInvite=} [properties] Properties to set
         */
        function BreakInvite(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreakInvite reason.
         * @member {number} reason
         * @memberof RoomResult.BreakInvite
         * @instance
         */
        BreakInvite.prototype.reason = 0;

        /**
         * BreakInvite targetId.
         * @member {string} targetId
         * @memberof RoomResult.BreakInvite
         * @instance
         */
        BreakInvite.prototype.targetId = "";

        /**
         * Decodes a BreakInvite message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.BreakInvite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.BreakInvite} BreakInvite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreakInvite.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.BreakInvite();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.int32();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("reason"))
                throw $util.ProtocolError("missing required 'reason'", { instance: message });
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            return message;
        };

        /**
         * Decodes a BreakInvite message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.BreakInvite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.BreakInvite} BreakInvite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreakInvite.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return BreakInvite;
    })();

    RoomResult.RoomOpenInfo = (function() {

        /**
         * Properties of a RoomOpenInfo.
         * @memberof RoomResult
         * @interface IRoomOpenInfo
         * @property {string} roomName RoomOpenInfo roomName
         * @property {number} roomType RoomOpenInfo roomType
         * @property {UserResult.IUserBase|null} [anchorData] RoomOpenInfo anchorData
         * @property {number|null} [logoTime] RoomOpenInfo logoTime
         * @property {Array.<string>|null} [bgs] RoomOpenInfo bgs
         * @property {Array.<RoomResult.IHallData>|null} [halls] RoomOpenInfo halls
         * @property {string|null} [notic] RoomOpenInfo notic
         */

        /**
         * Constructs a new RoomOpenInfo.
         * @memberof RoomResult
         * @classdesc Represents a RoomOpenInfo.
         * @implements IRoomOpenInfo
         * @constructor
         * @param {RoomResult.IRoomOpenInfo=} [properties] Properties to set
         */
        function RoomOpenInfo(properties) {
            this.bgs = [];
            this.halls = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomOpenInfo roomName.
         * @member {string} roomName
         * @memberof RoomResult.RoomOpenInfo
         * @instance
         */
        RoomOpenInfo.prototype.roomName = "";

        /**
         * RoomOpenInfo roomType.
         * @member {number} roomType
         * @memberof RoomResult.RoomOpenInfo
         * @instance
         */
        RoomOpenInfo.prototype.roomType = 0;

        /**
         * RoomOpenInfo anchorData.
         * @member {UserResult.IUserBase|null|undefined} anchorData
         * @memberof RoomResult.RoomOpenInfo
         * @instance
         */
        RoomOpenInfo.prototype.anchorData = null;

        /**
         * RoomOpenInfo logoTime.
         * @member {number} logoTime
         * @memberof RoomResult.RoomOpenInfo
         * @instance
         */
        RoomOpenInfo.prototype.logoTime = 0;

        /**
         * RoomOpenInfo bgs.
         * @member {Array.<string>} bgs
         * @memberof RoomResult.RoomOpenInfo
         * @instance
         */
        RoomOpenInfo.prototype.bgs = $util.emptyArray;

        /**
         * RoomOpenInfo halls.
         * @member {Array.<RoomResult.IHallData>} halls
         * @memberof RoomResult.RoomOpenInfo
         * @instance
         */
        RoomOpenInfo.prototype.halls = $util.emptyArray;

        /**
         * RoomOpenInfo notic.
         * @member {string} notic
         * @memberof RoomResult.RoomOpenInfo
         * @instance
         */
        RoomOpenInfo.prototype.notic = "";

        /**
         * Decodes a RoomOpenInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomOpenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomOpenInfo} RoomOpenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomOpenInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomOpenInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomName = reader.string();
                    break;
                case 2:
                    message.roomType = reader.int32();
                    break;
                case 3:
                    message.anchorData = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.logoTime = reader.int32();
                    break;
                case 5:
                    if (!(message.bgs && message.bgs.length))
                        message.bgs = [];
                    message.bgs.push(reader.string());
                    break;
                case 6:
                    if (!(message.halls && message.halls.length))
                        message.halls = [];
                    message.halls.push($root.RoomResult.HallData.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.notic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomName"))
                throw $util.ProtocolError("missing required 'roomName'", { instance: message });
            if (!message.hasOwnProperty("roomType"))
                throw $util.ProtocolError("missing required 'roomType'", { instance: message });
            return message;
        };

        /**
         * Decodes a RoomOpenInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomOpenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomOpenInfo} RoomOpenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomOpenInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomOpenInfo;
    })();

    RoomResult.HallData = (function() {

        /**
         * Properties of a HallData.
         * @memberof RoomResult
         * @interface IHallData
         * @property {string} roomName HallData roomName
         * @property {number} roomType HallData roomType
         * @property {UserResult.IUserBase|null} [anchorData] HallData anchorData
         * @property {number} logoTime HallData logoTime
         * @property {Array.<string>|null} [bgs] HallData bgs
         * @property {string} roomId HallData roomId
         */

        /**
         * Constructs a new HallData.
         * @memberof RoomResult
         * @classdesc Represents a HallData.
         * @implements IHallData
         * @constructor
         * @param {RoomResult.IHallData=} [properties] Properties to set
         */
        function HallData(properties) {
            this.bgs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HallData roomName.
         * @member {string} roomName
         * @memberof RoomResult.HallData
         * @instance
         */
        HallData.prototype.roomName = "";

        /**
         * HallData roomType.
         * @member {number} roomType
         * @memberof RoomResult.HallData
         * @instance
         */
        HallData.prototype.roomType = 0;

        /**
         * HallData anchorData.
         * @member {UserResult.IUserBase|null|undefined} anchorData
         * @memberof RoomResult.HallData
         * @instance
         */
        HallData.prototype.anchorData = null;

        /**
         * HallData logoTime.
         * @member {number} logoTime
         * @memberof RoomResult.HallData
         * @instance
         */
        HallData.prototype.logoTime = 0;

        /**
         * HallData bgs.
         * @member {Array.<string>} bgs
         * @memberof RoomResult.HallData
         * @instance
         */
        HallData.prototype.bgs = $util.emptyArray;

        /**
         * HallData roomId.
         * @member {string} roomId
         * @memberof RoomResult.HallData
         * @instance
         */
        HallData.prototype.roomId = "";

        /**
         * Decodes a HallData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.HallData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.HallData} HallData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HallData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.HallData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomName = reader.string();
                    break;
                case 2:
                    message.roomType = reader.int32();
                    break;
                case 3:
                    message.anchorData = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.logoTime = reader.int32();
                    break;
                case 5:
                    if (!(message.bgs && message.bgs.length))
                        message.bgs = [];
                    message.bgs.push(reader.string());
                    break;
                case 6:
                    message.roomId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomName"))
                throw $util.ProtocolError("missing required 'roomName'", { instance: message });
            if (!message.hasOwnProperty("roomType"))
                throw $util.ProtocolError("missing required 'roomType'", { instance: message });
            if (!message.hasOwnProperty("logoTime"))
                throw $util.ProtocolError("missing required 'logoTime'", { instance: message });
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            return message;
        };

        /**
         * Decodes a HallData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.HallData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.HallData} HallData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HallData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return HallData;
    })();

    RoomResult.ManagerList = (function() {

        /**
         * Properties of a ManagerList.
         * @memberof RoomResult
         * @interface IManagerList
         * @property {Array.<RoomResult.IManagerInfo>|null} [list] ManagerList list
         * @property {number} num ManagerList num
         */

        /**
         * Constructs a new ManagerList.
         * @memberof RoomResult
         * @classdesc Represents a ManagerList.
         * @implements IManagerList
         * @constructor
         * @param {RoomResult.IManagerList=} [properties] Properties to set
         */
        function ManagerList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ManagerList list.
         * @member {Array.<RoomResult.IManagerInfo>} list
         * @memberof RoomResult.ManagerList
         * @instance
         */
        ManagerList.prototype.list = $util.emptyArray;

        /**
         * ManagerList num.
         * @member {number} num
         * @memberof RoomResult.ManagerList
         * @instance
         */
        ManagerList.prototype.num = 0;

        /**
         * Decodes a ManagerList message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.ManagerList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.ManagerList} ManagerList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ManagerList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.ManagerList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RoomResult.ManagerInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.num = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            return message;
        };

        /**
         * Decodes a ManagerList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.ManagerList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.ManagerList} ManagerList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ManagerList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ManagerList;
    })();

    RoomResult.ManagerInfo = (function() {

        /**
         * Properties of a ManagerInfo.
         * @memberof RoomResult
         * @interface IManagerInfo
         * @property {UserResult.IUserBase} base ManagerInfo base
         * @property {number|null} [jobId] ManagerInfo jobId
         */

        /**
         * Constructs a new ManagerInfo.
         * @memberof RoomResult
         * @classdesc Represents a ManagerInfo.
         * @implements IManagerInfo
         * @constructor
         * @param {RoomResult.IManagerInfo=} [properties] Properties to set
         */
        function ManagerInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ManagerInfo base.
         * @member {UserResult.IUserBase} base
         * @memberof RoomResult.ManagerInfo
         * @instance
         */
        ManagerInfo.prototype.base = null;

        /**
         * ManagerInfo jobId.
         * @member {number} jobId
         * @memberof RoomResult.ManagerInfo
         * @instance
         */
        ManagerInfo.prototype.jobId = 0;

        /**
         * Decodes a ManagerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.ManagerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.ManagerInfo} ManagerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ManagerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.ManagerInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.jobId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("base"))
                throw $util.ProtocolError("missing required 'base'", { instance: message });
            return message;
        };

        /**
         * Decodes a ManagerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.ManagerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.ManagerInfo} ManagerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ManagerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ManagerInfo;
    })();

    RoomResult.ChangeRoomType = (function() {

        /**
         * Properties of a ChangeRoomType.
         * @memberof RoomResult
         * @interface IChangeRoomType
         * @property {number} type ChangeRoomType type
         */

        /**
         * Constructs a new ChangeRoomType.
         * @memberof RoomResult
         * @classdesc Represents a ChangeRoomType.
         * @implements IChangeRoomType
         * @constructor
         * @param {RoomResult.IChangeRoomType=} [properties] Properties to set
         */
        function ChangeRoomType(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeRoomType type.
         * @member {number} type
         * @memberof RoomResult.ChangeRoomType
         * @instance
         */
        ChangeRoomType.prototype.type = 0;

        /**
         * Decodes a ChangeRoomType message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.ChangeRoomType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.ChangeRoomType} ChangeRoomType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeRoomType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.ChangeRoomType();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a ChangeRoomType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.ChangeRoomType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.ChangeRoomType} ChangeRoomType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeRoomType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ChangeRoomType;
    })();

    RoomResult.KickData = (function() {

        /**
         * Properties of a KickData.
         * @memberof RoomResult
         * @interface IKickData
         * @property {UserResult.IUserBase} kickUser KickData kickUser
         * @property {number} remainTime KickData remainTime
         */

        /**
         * Constructs a new KickData.
         * @memberof RoomResult
         * @classdesc Represents a KickData.
         * @implements IKickData
         * @constructor
         * @param {RoomResult.IKickData=} [properties] Properties to set
         */
        function KickData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KickData kickUser.
         * @member {UserResult.IUserBase} kickUser
         * @memberof RoomResult.KickData
         * @instance
         */
        KickData.prototype.kickUser = null;

        /**
         * KickData remainTime.
         * @member {number} remainTime
         * @memberof RoomResult.KickData
         * @instance
         */
        KickData.prototype.remainTime = 0;

        /**
         * Decodes a KickData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.KickData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.KickData} KickData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KickData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.KickData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.kickUser = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.remainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("kickUser"))
                throw $util.ProtocolError("missing required 'kickUser'", { instance: message });
            if (!message.hasOwnProperty("remainTime"))
                throw $util.ProtocolError("missing required 'remainTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a KickData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.KickData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.KickData} KickData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KickData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return KickData;
    })();

    RoomResult.ChangeOnlineIndex = (function() {

        /**
         * Properties of a ChangeOnlineIndex.
         * @memberof RoomResult
         * @interface IChangeOnlineIndex
         * @property {string} userId ChangeOnlineIndex userId
         * @property {number} index ChangeOnlineIndex index
         */

        /**
         * Constructs a new ChangeOnlineIndex.
         * @memberof RoomResult
         * @classdesc Represents a ChangeOnlineIndex.
         * @implements IChangeOnlineIndex
         * @constructor
         * @param {RoomResult.IChangeOnlineIndex=} [properties] Properties to set
         */
        function ChangeOnlineIndex(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeOnlineIndex userId.
         * @member {string} userId
         * @memberof RoomResult.ChangeOnlineIndex
         * @instance
         */
        ChangeOnlineIndex.prototype.userId = "";

        /**
         * ChangeOnlineIndex index.
         * @member {number} index
         * @memberof RoomResult.ChangeOnlineIndex
         * @instance
         */
        ChangeOnlineIndex.prototype.index = 0;

        /**
         * Decodes a ChangeOnlineIndex message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.ChangeOnlineIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.ChangeOnlineIndex} ChangeOnlineIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeOnlineIndex.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.ChangeOnlineIndex();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };

        /**
         * Decodes a ChangeOnlineIndex message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.ChangeOnlineIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.ChangeOnlineIndex} ChangeOnlineIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeOnlineIndex.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ChangeOnlineIndex;
    })();

    RoomResult.SyncDragonBallData = (function() {

        /**
         * Properties of a SyncDragonBallData.
         * @memberof RoomResult
         * @interface ISyncDragonBallData
         * @property {number} position SyncDragonBallData position
         * @property {Array.<number>|null} [dragonBalls] SyncDragonBallData dragonBalls
         */

        /**
         * Constructs a new SyncDragonBallData.
         * @memberof RoomResult
         * @classdesc Represents a SyncDragonBallData.
         * @implements ISyncDragonBallData
         * @constructor
         * @param {RoomResult.ISyncDragonBallData=} [properties] Properties to set
         */
        function SyncDragonBallData(properties) {
            this.dragonBalls = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncDragonBallData position.
         * @member {number} position
         * @memberof RoomResult.SyncDragonBallData
         * @instance
         */
        SyncDragonBallData.prototype.position = 0;

        /**
         * SyncDragonBallData dragonBalls.
         * @member {Array.<number>} dragonBalls
         * @memberof RoomResult.SyncDragonBallData
         * @instance
         */
        SyncDragonBallData.prototype.dragonBalls = $util.emptyArray;

        /**
         * Decodes a SyncDragonBallData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.SyncDragonBallData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.SyncDragonBallData} SyncDragonBallData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncDragonBallData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.SyncDragonBallData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.int32();
                    break;
                case 2:
                    if (!(message.dragonBalls && message.dragonBalls.length))
                        message.dragonBalls = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.dragonBalls.push(reader.int32());
                    } else
                        message.dragonBalls.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("position"))
                throw $util.ProtocolError("missing required 'position'", { instance: message });
            return message;
        };

        /**
         * Decodes a SyncDragonBallData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.SyncDragonBallData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.SyncDragonBallData} SyncDragonBallData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncDragonBallData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SyncDragonBallData;
    })();

    RoomResult.SyncHatData = (function() {

        /**
         * Properties of a SyncHatData.
         * @memberof RoomResult
         * @interface ISyncHatData
         * @property {number} type SyncHatData type
         * @property {UserResult.IUserBase|null} [userBase] SyncHatData userBase
         * @property {UserResult.IUserBase|null} [cpUserBase] SyncHatData cpUserBase
         * @property {string|null} [hatId] SyncHatData hatId
         * @property {number|null} [hatStatus] SyncHatData hatStatus
         * @property {number|null} [stoleHeartValue] SyncHatData stoleHeartValue
         * @property {boolean|null} [isFirst] SyncHatData isFirst
         * @property {string|null} [roomId] SyncHatData roomId
         * @property {string|null} [cpHatId] SyncHatData cpHatId
         */

        /**
         * Constructs a new SyncHatData.
         * @memberof RoomResult
         * @classdesc Represents a SyncHatData.
         * @implements ISyncHatData
         * @constructor
         * @param {RoomResult.ISyncHatData=} [properties] Properties to set
         */
        function SyncHatData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncHatData type.
         * @member {number} type
         * @memberof RoomResult.SyncHatData
         * @instance
         */
        SyncHatData.prototype.type = 0;

        /**
         * SyncHatData userBase.
         * @member {UserResult.IUserBase|null|undefined} userBase
         * @memberof RoomResult.SyncHatData
         * @instance
         */
        SyncHatData.prototype.userBase = null;

        /**
         * SyncHatData cpUserBase.
         * @member {UserResult.IUserBase|null|undefined} cpUserBase
         * @memberof RoomResult.SyncHatData
         * @instance
         */
        SyncHatData.prototype.cpUserBase = null;

        /**
         * SyncHatData hatId.
         * @member {string} hatId
         * @memberof RoomResult.SyncHatData
         * @instance
         */
        SyncHatData.prototype.hatId = "";

        /**
         * SyncHatData hatStatus.
         * @member {number} hatStatus
         * @memberof RoomResult.SyncHatData
         * @instance
         */
        SyncHatData.prototype.hatStatus = 0;

        /**
         * SyncHatData stoleHeartValue.
         * @member {number} stoleHeartValue
         * @memberof RoomResult.SyncHatData
         * @instance
         */
        SyncHatData.prototype.stoleHeartValue = 0;

        /**
         * SyncHatData isFirst.
         * @member {boolean} isFirst
         * @memberof RoomResult.SyncHatData
         * @instance
         */
        SyncHatData.prototype.isFirst = false;

        /**
         * SyncHatData roomId.
         * @member {string} roomId
         * @memberof RoomResult.SyncHatData
         * @instance
         */
        SyncHatData.prototype.roomId = "";

        /**
         * SyncHatData cpHatId.
         * @member {string} cpHatId
         * @memberof RoomResult.SyncHatData
         * @instance
         */
        SyncHatData.prototype.cpHatId = "";

        /**
         * Decodes a SyncHatData message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.SyncHatData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.SyncHatData} SyncHatData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncHatData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.SyncHatData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.userBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.cpUserBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.hatId = reader.string();
                    break;
                case 5:
                    message.hatStatus = reader.int32();
                    break;
                case 6:
                    message.stoleHeartValue = reader.int32();
                    break;
                case 7:
                    message.isFirst = reader.bool();
                    break;
                case 8:
                    message.roomId = reader.string();
                    break;
                case 9:
                    message.cpHatId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a SyncHatData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.SyncHatData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.SyncHatData} SyncHatData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncHatData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SyncHatData;
    })();

    RoomResult.HeartRankList = (function() {

        /**
         * Properties of a HeartRankList.
         * @memberof RoomResult
         * @interface IHeartRankList
         * @property {Array.<UserResult.IUserBase>|null} [contributeUser] HeartRankList contributeUser
         * @property {Array.<number>|null} [contributeValue] HeartRankList contributeValue
         */

        /**
         * Constructs a new HeartRankList.
         * @memberof RoomResult
         * @classdesc Represents a HeartRankList.
         * @implements IHeartRankList
         * @constructor
         * @param {RoomResult.IHeartRankList=} [properties] Properties to set
         */
        function HeartRankList(properties) {
            this.contributeUser = [];
            this.contributeValue = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeartRankList contributeUser.
         * @member {Array.<UserResult.IUserBase>} contributeUser
         * @memberof RoomResult.HeartRankList
         * @instance
         */
        HeartRankList.prototype.contributeUser = $util.emptyArray;

        /**
         * HeartRankList contributeValue.
         * @member {Array.<number>} contributeValue
         * @memberof RoomResult.HeartRankList
         * @instance
         */
        HeartRankList.prototype.contributeValue = $util.emptyArray;

        /**
         * Decodes a HeartRankList message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.HeartRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.HeartRankList} HeartRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.HeartRankList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contributeUser && message.contributeUser.length))
                        message.contributeUser = [];
                    message.contributeUser.push($root.UserResult.UserBase.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.contributeValue && message.contributeValue.length))
                        message.contributeValue = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.contributeValue.push(reader.int32());
                    } else
                        message.contributeValue.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeartRankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.HeartRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.HeartRankList} HeartRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartRankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return HeartRankList;
    })();

    RoomResult.RecommendVideoRoom = (function() {

        /**
         * Properties of a RecommendVideoRoom.
         * @memberof RoomResult
         * @interface IRecommendVideoRoom
         * @property {string} roomId RecommendVideoRoom roomId
         * @property {UserResult.IUserBase} base RecommendVideoRoom base
         */

        /**
         * Constructs a new RecommendVideoRoom.
         * @memberof RoomResult
         * @classdesc Represents a RecommendVideoRoom.
         * @implements IRecommendVideoRoom
         * @constructor
         * @param {RoomResult.IRecommendVideoRoom=} [properties] Properties to set
         */
        function RecommendVideoRoom(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecommendVideoRoom roomId.
         * @member {string} roomId
         * @memberof RoomResult.RecommendVideoRoom
         * @instance
         */
        RecommendVideoRoom.prototype.roomId = "";

        /**
         * RecommendVideoRoom base.
         * @member {UserResult.IUserBase} base
         * @memberof RoomResult.RecommendVideoRoom
         * @instance
         */
        RecommendVideoRoom.prototype.base = null;

        /**
         * Decodes a RecommendVideoRoom message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RecommendVideoRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RecommendVideoRoom} RecommendVideoRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecommendVideoRoom.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RecommendVideoRoom();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("base"))
                throw $util.ProtocolError("missing required 'base'", { instance: message });
            return message;
        };

        /**
         * Decodes a RecommendVideoRoom message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RecommendVideoRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RecommendVideoRoom} RecommendVideoRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecommendVideoRoom.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RecommendVideoRoom;
    })();

    RoomResult.modifyGroupBroadcast = (function() {

        /**
         * Properties of a modifyGroupBroadcast.
         * @memberof RoomResult
         * @interface ImodifyGroupBroadcast
         * @property {string} roomId modifyGroupBroadcast roomId
         * @property {string} groupId modifyGroupBroadcast groupId
         */

        /**
         * Constructs a new modifyGroupBroadcast.
         * @memberof RoomResult
         * @classdesc Represents a modifyGroupBroadcast.
         * @implements ImodifyGroupBroadcast
         * @constructor
         * @param {RoomResult.ImodifyGroupBroadcast=} [properties] Properties to set
         */
        function modifyGroupBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * modifyGroupBroadcast roomId.
         * @member {string} roomId
         * @memberof RoomResult.modifyGroupBroadcast
         * @instance
         */
        modifyGroupBroadcast.prototype.roomId = "";

        /**
         * modifyGroupBroadcast groupId.
         * @member {string} groupId
         * @memberof RoomResult.modifyGroupBroadcast
         * @instance
         */
        modifyGroupBroadcast.prototype.groupId = "";

        /**
         * Decodes a modifyGroupBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.modifyGroupBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.modifyGroupBroadcast} modifyGroupBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        modifyGroupBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.modifyGroupBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.groupId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("groupId"))
                throw $util.ProtocolError("missing required 'groupId'", { instance: message });
            return message;
        };

        /**
         * Decodes a modifyGroupBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.modifyGroupBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.modifyGroupBroadcast} modifyGroupBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        modifyGroupBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return modifyGroupBroadcast;
    })();

    RoomResult.RoomMicQues = (function() {

        /**
         * Properties of a RoomMicQues.
         * @memberof RoomResult
         * @interface IRoomMicQues
         * @property {Array.<UserResult.IUserBase>|null} [micQues] RoomMicQues micQues
         * @property {Array.<number>|null} [cardType] RoomMicQues cardType
         */

        /**
         * Constructs a new RoomMicQues.
         * @memberof RoomResult
         * @classdesc Represents a RoomMicQues.
         * @implements IRoomMicQues
         * @constructor
         * @param {RoomResult.IRoomMicQues=} [properties] Properties to set
         */
        function RoomMicQues(properties) {
            this.micQues = [];
            this.cardType = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomMicQues micQues.
         * @member {Array.<UserResult.IUserBase>} micQues
         * @memberof RoomResult.RoomMicQues
         * @instance
         */
        RoomMicQues.prototype.micQues = $util.emptyArray;

        /**
         * RoomMicQues cardType.
         * @member {Array.<number>} cardType
         * @memberof RoomResult.RoomMicQues
         * @instance
         */
        RoomMicQues.prototype.cardType = $util.emptyArray;

        /**
         * Decodes a RoomMicQues message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomMicQues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomMicQues} RoomMicQues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomMicQues.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomMicQues();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.micQues && message.micQues.length))
                        message.micQues = [];
                    message.micQues.push($root.UserResult.UserBase.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.cardType && message.cardType.length))
                        message.cardType = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.cardType.push(reader.int32());
                    } else
                        message.cardType.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoomMicQues message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomMicQues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomMicQues} RoomMicQues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomMicQues.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomMicQues;
    })();

    RoomResult.LiveflowYellowBroadcast = (function() {

        /**
         * Properties of a LiveflowYellowBroadcast.
         * @memberof RoomResult
         * @interface ILiveflowYellowBroadcast
         * @property {string} roomId LiveflowYellowBroadcast roomId
         * @property {number|null} [level] LiveflowYellowBroadcast level
         */

        /**
         * Constructs a new LiveflowYellowBroadcast.
         * @memberof RoomResult
         * @classdesc Represents a LiveflowYellowBroadcast.
         * @implements ILiveflowYellowBroadcast
         * @constructor
         * @param {RoomResult.ILiveflowYellowBroadcast=} [properties] Properties to set
         */
        function LiveflowYellowBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveflowYellowBroadcast roomId.
         * @member {string} roomId
         * @memberof RoomResult.LiveflowYellowBroadcast
         * @instance
         */
        LiveflowYellowBroadcast.prototype.roomId = "";

        /**
         * LiveflowYellowBroadcast level.
         * @member {number} level
         * @memberof RoomResult.LiveflowYellowBroadcast
         * @instance
         */
        LiveflowYellowBroadcast.prototype.level = 0;

        /**
         * Decodes a LiveflowYellowBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.LiveflowYellowBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.LiveflowYellowBroadcast} LiveflowYellowBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveflowYellowBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.LiveflowYellowBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.level = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveflowYellowBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.LiveflowYellowBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.LiveflowYellowBroadcast} LiveflowYellowBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveflowYellowBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveflowYellowBroadcast;
    })();

    RoomResult.BaseRoomInfoList = (function() {

        /**
         * Properties of a BaseRoomInfoList.
         * @memberof RoomResult
         * @interface IBaseRoomInfoList
         * @property {Array.<RoomResult.IBaseRoomInfo>|null} [infos] BaseRoomInfoList infos
         */

        /**
         * Constructs a new BaseRoomInfoList.
         * @memberof RoomResult
         * @classdesc Represents a BaseRoomInfoList.
         * @implements IBaseRoomInfoList
         * @constructor
         * @param {RoomResult.IBaseRoomInfoList=} [properties] Properties to set
         */
        function BaseRoomInfoList(properties) {
            this.infos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BaseRoomInfoList infos.
         * @member {Array.<RoomResult.IBaseRoomInfo>} infos
         * @memberof RoomResult.BaseRoomInfoList
         * @instance
         */
        BaseRoomInfoList.prototype.infos = $util.emptyArray;

        /**
         * Decodes a BaseRoomInfoList message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.BaseRoomInfoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.BaseRoomInfoList} BaseRoomInfoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseRoomInfoList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.BaseRoomInfoList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.RoomResult.BaseRoomInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BaseRoomInfoList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.BaseRoomInfoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.BaseRoomInfoList} BaseRoomInfoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseRoomInfoList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return BaseRoomInfoList;
    })();

    RoomResult.BaseRoomInfo = (function() {

        /**
         * Properties of a BaseRoomInfo.
         * @memberof RoomResult
         * @interface IBaseRoomInfo
         * @property {string} roomId BaseRoomInfo roomId
         * @property {string|null} [roomName] BaseRoomInfo roomName
         * @property {string|null} [createId] BaseRoomInfo createId
         * @property {UserResult.IUserBase|null} [base] BaseRoomInfo base
         * @property {boolean|null} [password] BaseRoomInfo password
         * @property {number|null} [roomType] BaseRoomInfo roomType
         * @property {number|null} [logoTime] BaseRoomInfo logoTime
         * @property {boolean|null} [isLive] BaseRoomInfo isLive
         */

        /**
         * Constructs a new BaseRoomInfo.
         * @memberof RoomResult
         * @classdesc Represents a BaseRoomInfo.
         * @implements IBaseRoomInfo
         * @constructor
         * @param {RoomResult.IBaseRoomInfo=} [properties] Properties to set
         */
        function BaseRoomInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BaseRoomInfo roomId.
         * @member {string} roomId
         * @memberof RoomResult.BaseRoomInfo
         * @instance
         */
        BaseRoomInfo.prototype.roomId = "";

        /**
         * BaseRoomInfo roomName.
         * @member {string} roomName
         * @memberof RoomResult.BaseRoomInfo
         * @instance
         */
        BaseRoomInfo.prototype.roomName = "";

        /**
         * BaseRoomInfo createId.
         * @member {string} createId
         * @memberof RoomResult.BaseRoomInfo
         * @instance
         */
        BaseRoomInfo.prototype.createId = "";

        /**
         * BaseRoomInfo base.
         * @member {UserResult.IUserBase|null|undefined} base
         * @memberof RoomResult.BaseRoomInfo
         * @instance
         */
        BaseRoomInfo.prototype.base = null;

        /**
         * BaseRoomInfo password.
         * @member {boolean} password
         * @memberof RoomResult.BaseRoomInfo
         * @instance
         */
        BaseRoomInfo.prototype.password = false;

        /**
         * BaseRoomInfo roomType.
         * @member {number} roomType
         * @memberof RoomResult.BaseRoomInfo
         * @instance
         */
        BaseRoomInfo.prototype.roomType = 0;

        /**
         * BaseRoomInfo logoTime.
         * @member {number} logoTime
         * @memberof RoomResult.BaseRoomInfo
         * @instance
         */
        BaseRoomInfo.prototype.logoTime = 0;

        /**
         * BaseRoomInfo isLive.
         * @member {boolean} isLive
         * @memberof RoomResult.BaseRoomInfo
         * @instance
         */
        BaseRoomInfo.prototype.isLive = false;

        /**
         * Decodes a BaseRoomInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.BaseRoomInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.BaseRoomInfo} BaseRoomInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseRoomInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.BaseRoomInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.roomName = reader.string();
                    break;
                case 3:
                    message.createId = reader.string();
                    break;
                case 5:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.password = reader.bool();
                    break;
                case 7:
                    message.roomType = reader.int32();
                    break;
                case 9:
                    message.logoTime = reader.int32();
                    break;
                case 10:
                    message.isLive = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            return message;
        };

        /**
         * Decodes a BaseRoomInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.BaseRoomInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.BaseRoomInfo} BaseRoomInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseRoomInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return BaseRoomInfo;
    })();

    RoomResult.SyncMicTime = (function() {

        /**
         * Properties of a SyncMicTime.
         * @memberof RoomResult
         * @interface ISyncMicTime
         * @property {number} position SyncMicTime position
         * @property {number|Long} micOverTime SyncMicTime micOverTime
         */

        /**
         * Constructs a new SyncMicTime.
         * @memberof RoomResult
         * @classdesc Represents a SyncMicTime.
         * @implements ISyncMicTime
         * @constructor
         * @param {RoomResult.ISyncMicTime=} [properties] Properties to set
         */
        function SyncMicTime(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncMicTime position.
         * @member {number} position
         * @memberof RoomResult.SyncMicTime
         * @instance
         */
        SyncMicTime.prototype.position = 0;

        /**
         * SyncMicTime micOverTime.
         * @member {number|Long} micOverTime
         * @memberof RoomResult.SyncMicTime
         * @instance
         */
        SyncMicTime.prototype.micOverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a SyncMicTime message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.SyncMicTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.SyncMicTime} SyncMicTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncMicTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.SyncMicTime();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.int32();
                    break;
                case 2:
                    message.micOverTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("position"))
                throw $util.ProtocolError("missing required 'position'", { instance: message });
            if (!message.hasOwnProperty("micOverTime"))
                throw $util.ProtocolError("missing required 'micOverTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a SyncMicTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.SyncMicTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.SyncMicTime} SyncMicTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncMicTime.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SyncMicTime;
    })();

    RoomResult.CrossRoomPk = (function() {

        /**
         * Properties of a CrossRoomPk.
         * @memberof RoomResult
         * @interface ICrossRoomPk
         * @property {number} pk CrossRoomPk pk
         */

        /**
         * Constructs a new CrossRoomPk.
         * @memberof RoomResult
         * @classdesc Represents a CrossRoomPk.
         * @implements ICrossRoomPk
         * @constructor
         * @param {RoomResult.ICrossRoomPk=} [properties] Properties to set
         */
        function CrossRoomPk(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomPk pk.
         * @member {number} pk
         * @memberof RoomResult.CrossRoomPk
         * @instance
         */
        CrossRoomPk.prototype.pk = 0;

        /**
         * Decodes a CrossRoomPk message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.CrossRoomPk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.CrossRoomPk} CrossRoomPk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomPk.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.CrossRoomPk();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pk = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("pk"))
                throw $util.ProtocolError("missing required 'pk'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomPk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.CrossRoomPk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.CrossRoomPk} CrossRoomPk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomPk.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomPk;
    })();

    RoomResult.CrossRoomBase = (function() {

        /**
         * Properties of a CrossRoomBase.
         * @memberof RoomResult
         * @interface ICrossRoomBase
         * @property {number} pk CrossRoomBase pk
         * @property {number|Long|null} [startTime] CrossRoomBase startTime
         * @property {number|Long|null} [endTime] CrossRoomBase endTime
         * @property {number|Long|null} [remainTime] CrossRoomBase remainTime
         * @property {number|Long|null} [addDuration] CrossRoomBase addDuration
         * @property {number|null} [addRatio] CrossRoomBase addRatio
         * @property {RoomResult.ICrossRoomInfo|null} [info] CrossRoomBase info
         * @property {RoomResult.ICrossRoomInfo|null} [pkInfo] CrossRoomBase pkInfo
         */

        /**
         * Constructs a new CrossRoomBase.
         * @memberof RoomResult
         * @classdesc Represents a CrossRoomBase.
         * @implements ICrossRoomBase
         * @constructor
         * @param {RoomResult.ICrossRoomBase=} [properties] Properties to set
         */
        function CrossRoomBase(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomBase pk.
         * @member {number} pk
         * @memberof RoomResult.CrossRoomBase
         * @instance
         */
        CrossRoomBase.prototype.pk = 0;

        /**
         * CrossRoomBase startTime.
         * @member {number|Long} startTime
         * @memberof RoomResult.CrossRoomBase
         * @instance
         */
        CrossRoomBase.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomBase endTime.
         * @member {number|Long} endTime
         * @memberof RoomResult.CrossRoomBase
         * @instance
         */
        CrossRoomBase.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomBase remainTime.
         * @member {number|Long} remainTime
         * @memberof RoomResult.CrossRoomBase
         * @instance
         */
        CrossRoomBase.prototype.remainTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomBase addDuration.
         * @member {number|Long} addDuration
         * @memberof RoomResult.CrossRoomBase
         * @instance
         */
        CrossRoomBase.prototype.addDuration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomBase addRatio.
         * @member {number} addRatio
         * @memberof RoomResult.CrossRoomBase
         * @instance
         */
        CrossRoomBase.prototype.addRatio = 0;

        /**
         * CrossRoomBase info.
         * @member {RoomResult.ICrossRoomInfo|null|undefined} info
         * @memberof RoomResult.CrossRoomBase
         * @instance
         */
        CrossRoomBase.prototype.info = null;

        /**
         * CrossRoomBase pkInfo.
         * @member {RoomResult.ICrossRoomInfo|null|undefined} pkInfo
         * @memberof RoomResult.CrossRoomBase
         * @instance
         */
        CrossRoomBase.prototype.pkInfo = null;

        /**
         * Decodes a CrossRoomBase message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.CrossRoomBase
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.CrossRoomBase} CrossRoomBase
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomBase.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.CrossRoomBase();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pk = reader.int32();
                    break;
                case 2:
                    message.startTime = reader.int64();
                    break;
                case 3:
                    message.endTime = reader.int64();
                    break;
                case 4:
                    message.remainTime = reader.int64();
                    break;
                case 5:
                    message.addDuration = reader.int64();
                    break;
                case 6:
                    message.addRatio = reader.double();
                    break;
                case 7:
                    message.info = $root.RoomResult.CrossRoomInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.pkInfo = $root.RoomResult.CrossRoomInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("pk"))
                throw $util.ProtocolError("missing required 'pk'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomBase message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.CrossRoomBase
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.CrossRoomBase} CrossRoomBase
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomBase.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomBase;
    })();

    RoomResult.CrossRoomInfo = (function() {

        /**
         * Properties of a CrossRoomInfo.
         * @memberof RoomResult
         * @interface ICrossRoomInfo
         * @property {RoomResult.IBaseRoomInfo|null} [room] CrossRoomInfo room
         * @property {number} star CrossRoomInfo star
         * @property {number|Long} pkScore CrossRoomInfo pkScore
         * @property {Array.<RoomResult.ICrossRoomMvpInfo>|null} [mvps] CrossRoomInfo mvps
         * @property {UserResult.IUserBase|null} [mvpUser] CrossRoomInfo mvpUser
         */

        /**
         * Constructs a new CrossRoomInfo.
         * @memberof RoomResult
         * @classdesc Represents a CrossRoomInfo.
         * @implements ICrossRoomInfo
         * @constructor
         * @param {RoomResult.ICrossRoomInfo=} [properties] Properties to set
         */
        function CrossRoomInfo(properties) {
            this.mvps = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomInfo room.
         * @member {RoomResult.IBaseRoomInfo|null|undefined} room
         * @memberof RoomResult.CrossRoomInfo
         * @instance
         */
        CrossRoomInfo.prototype.room = null;

        /**
         * CrossRoomInfo star.
         * @member {number} star
         * @memberof RoomResult.CrossRoomInfo
         * @instance
         */
        CrossRoomInfo.prototype.star = 0;

        /**
         * CrossRoomInfo pkScore.
         * @member {number|Long} pkScore
         * @memberof RoomResult.CrossRoomInfo
         * @instance
         */
        CrossRoomInfo.prototype.pkScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomInfo mvps.
         * @member {Array.<RoomResult.ICrossRoomMvpInfo>} mvps
         * @memberof RoomResult.CrossRoomInfo
         * @instance
         */
        CrossRoomInfo.prototype.mvps = $util.emptyArray;

        /**
         * CrossRoomInfo mvpUser.
         * @member {UserResult.IUserBase|null|undefined} mvpUser
         * @memberof RoomResult.CrossRoomInfo
         * @instance
         */
        CrossRoomInfo.prototype.mvpUser = null;

        /**
         * Decodes a CrossRoomInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.CrossRoomInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.CrossRoomInfo} CrossRoomInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.CrossRoomInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room = $root.RoomResult.BaseRoomInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.star = reader.int32();
                    break;
                case 3:
                    message.pkScore = reader.int64();
                    break;
                case 4:
                    if (!(message.mvps && message.mvps.length))
                        message.mvps = [];
                    message.mvps.push($root.RoomResult.CrossRoomMvpInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.mvpUser = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("star"))
                throw $util.ProtocolError("missing required 'star'", { instance: message });
            if (!message.hasOwnProperty("pkScore"))
                throw $util.ProtocolError("missing required 'pkScore'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.CrossRoomInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.CrossRoomInfo} CrossRoomInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomInfo;
    })();

    RoomResult.CrossRoomMvpInfo = (function() {

        /**
         * Properties of a CrossRoomMvpInfo.
         * @memberof RoomResult
         * @interface ICrossRoomMvpInfo
         * @property {UserResult.IUserBase} user CrossRoomMvpInfo user
         * @property {number} rank CrossRoomMvpInfo rank
         * @property {number|Long} score CrossRoomMvpInfo score
         */

        /**
         * Constructs a new CrossRoomMvpInfo.
         * @memberof RoomResult
         * @classdesc Represents a CrossRoomMvpInfo.
         * @implements ICrossRoomMvpInfo
         * @constructor
         * @param {RoomResult.ICrossRoomMvpInfo=} [properties] Properties to set
         */
        function CrossRoomMvpInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomMvpInfo user.
         * @member {UserResult.IUserBase} user
         * @memberof RoomResult.CrossRoomMvpInfo
         * @instance
         */
        CrossRoomMvpInfo.prototype.user = null;

        /**
         * CrossRoomMvpInfo rank.
         * @member {number} rank
         * @memberof RoomResult.CrossRoomMvpInfo
         * @instance
         */
        CrossRoomMvpInfo.prototype.rank = 0;

        /**
         * CrossRoomMvpInfo score.
         * @member {number|Long} score
         * @memberof RoomResult.CrossRoomMvpInfo
         * @instance
         */
        CrossRoomMvpInfo.prototype.score = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a CrossRoomMvpInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.CrossRoomMvpInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.CrossRoomMvpInfo} CrossRoomMvpInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomMvpInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.CrossRoomMvpInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.user = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.rank = reader.int32();
                    break;
                case 3:
                    message.score = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("user"))
                throw $util.ProtocolError("missing required 'user'", { instance: message });
            if (!message.hasOwnProperty("rank"))
                throw $util.ProtocolError("missing required 'rank'", { instance: message });
            if (!message.hasOwnProperty("score"))
                throw $util.ProtocolError("missing required 'score'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomMvpInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.CrossRoomMvpInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.CrossRoomMvpInfo} CrossRoomMvpInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomMvpInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomMvpInfo;
    })();

    RoomResult.CrossRoomPkLog = (function() {

        /**
         * Properties of a CrossRoomPkLog.
         * @memberof RoomResult
         * @interface ICrossRoomPkLog
         * @property {string} id CrossRoomPkLog id
         * @property {RoomResult.IBaseRoomInfo} room CrossRoomPkLog room
         * @property {Array.<UserResult.IUserBase>|null} [mvps] CrossRoomPkLog mvps
         * @property {number|Long} pkScore CrossRoomPkLog pkScore
         * @property {number} isWin CrossRoomPkLog isWin
         * @property {string} time CrossRoomPkLog time
         */

        /**
         * Constructs a new CrossRoomPkLog.
         * @memberof RoomResult
         * @classdesc Represents a CrossRoomPkLog.
         * @implements ICrossRoomPkLog
         * @constructor
         * @param {RoomResult.ICrossRoomPkLog=} [properties] Properties to set
         */
        function CrossRoomPkLog(properties) {
            this.mvps = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomPkLog id.
         * @member {string} id
         * @memberof RoomResult.CrossRoomPkLog
         * @instance
         */
        CrossRoomPkLog.prototype.id = "";

        /**
         * CrossRoomPkLog room.
         * @member {RoomResult.IBaseRoomInfo} room
         * @memberof RoomResult.CrossRoomPkLog
         * @instance
         */
        CrossRoomPkLog.prototype.room = null;

        /**
         * CrossRoomPkLog mvps.
         * @member {Array.<UserResult.IUserBase>} mvps
         * @memberof RoomResult.CrossRoomPkLog
         * @instance
         */
        CrossRoomPkLog.prototype.mvps = $util.emptyArray;

        /**
         * CrossRoomPkLog pkScore.
         * @member {number|Long} pkScore
         * @memberof RoomResult.CrossRoomPkLog
         * @instance
         */
        CrossRoomPkLog.prototype.pkScore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CrossRoomPkLog isWin.
         * @member {number} isWin
         * @memberof RoomResult.CrossRoomPkLog
         * @instance
         */
        CrossRoomPkLog.prototype.isWin = 0;

        /**
         * CrossRoomPkLog time.
         * @member {string} time
         * @memberof RoomResult.CrossRoomPkLog
         * @instance
         */
        CrossRoomPkLog.prototype.time = "";

        /**
         * Decodes a CrossRoomPkLog message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.CrossRoomPkLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.CrossRoomPkLog} CrossRoomPkLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomPkLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.CrossRoomPkLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.room = $root.RoomResult.BaseRoomInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.mvps && message.mvps.length))
                        message.mvps = [];
                    message.mvps.push($root.UserResult.UserBase.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.pkScore = reader.int64();
                    break;
                case 5:
                    message.isWin = reader.int32();
                    break;
                case 6:
                    message.time = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("room"))
                throw $util.ProtocolError("missing required 'room'", { instance: message });
            if (!message.hasOwnProperty("pkScore"))
                throw $util.ProtocolError("missing required 'pkScore'", { instance: message });
            if (!message.hasOwnProperty("isWin"))
                throw $util.ProtocolError("missing required 'isWin'", { instance: message });
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a CrossRoomPkLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.CrossRoomPkLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.CrossRoomPkLog} CrossRoomPkLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomPkLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomPkLog;
    })();

    RoomResult.CrossRoomPkLogList = (function() {

        /**
         * Properties of a CrossRoomPkLogList.
         * @memberof RoomResult
         * @interface ICrossRoomPkLogList
         * @property {Array.<RoomResult.ICrossRoomPkLog>|null} [list] CrossRoomPkLogList list
         */

        /**
         * Constructs a new CrossRoomPkLogList.
         * @memberof RoomResult
         * @classdesc Represents a CrossRoomPkLogList.
         * @implements ICrossRoomPkLogList
         * @constructor
         * @param {RoomResult.ICrossRoomPkLogList=} [properties] Properties to set
         */
        function CrossRoomPkLogList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrossRoomPkLogList list.
         * @member {Array.<RoomResult.ICrossRoomPkLog>} list
         * @memberof RoomResult.CrossRoomPkLogList
         * @instance
         */
        CrossRoomPkLogList.prototype.list = $util.emptyArray;

        /**
         * Decodes a CrossRoomPkLogList message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.CrossRoomPkLogList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.CrossRoomPkLogList} CrossRoomPkLogList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomPkLogList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.CrossRoomPkLogList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RoomResult.CrossRoomPkLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrossRoomPkLogList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.CrossRoomPkLogList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.CrossRoomPkLogList} CrossRoomPkLogList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrossRoomPkLogList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CrossRoomPkLogList;
    })();

    RoomResult.RoomStatusList = (function() {

        /**
         * Properties of a RoomStatusList.
         * @memberof RoomResult
         * @interface IRoomStatusList
         * @property {Array.<RoomResult.IRoomStatus>|null} [list] RoomStatusList list
         */

        /**
         * Constructs a new RoomStatusList.
         * @memberof RoomResult
         * @classdesc Represents a RoomStatusList.
         * @implements IRoomStatusList
         * @constructor
         * @param {RoomResult.IRoomStatusList=} [properties] Properties to set
         */
        function RoomStatusList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomStatusList list.
         * @member {Array.<RoomResult.IRoomStatus>} list
         * @memberof RoomResult.RoomStatusList
         * @instance
         */
        RoomStatusList.prototype.list = $util.emptyArray;

        /**
         * Decodes a RoomStatusList message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomStatusList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomStatusList} RoomStatusList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomStatusList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomStatusList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RoomResult.RoomStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoomStatusList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomStatusList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomStatusList} RoomStatusList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomStatusList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomStatusList;
    })();

    RoomResult.RoomStatus = (function() {

        /**
         * Properties of a RoomStatus.
         * @memberof RoomResult
         * @interface IRoomStatus
         * @property {string} roomId RoomStatus roomId
         * @property {boolean} isLive RoomStatus isLive
         * @property {boolean} hasPwd RoomStatus hasPwd
         * @property {boolean} fmicIsMananger RoomStatus fmicIsMananger
         * @property {boolean} isOnMic RoomStatus isOnMic
         */

        /**
         * Constructs a new RoomStatus.
         * @memberof RoomResult
         * @classdesc Represents a RoomStatus.
         * @implements IRoomStatus
         * @constructor
         * @param {RoomResult.IRoomStatus=} [properties] Properties to set
         */
        function RoomStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomStatus roomId.
         * @member {string} roomId
         * @memberof RoomResult.RoomStatus
         * @instance
         */
        RoomStatus.prototype.roomId = "";

        /**
         * RoomStatus isLive.
         * @member {boolean} isLive
         * @memberof RoomResult.RoomStatus
         * @instance
         */
        RoomStatus.prototype.isLive = false;

        /**
         * RoomStatus hasPwd.
         * @member {boolean} hasPwd
         * @memberof RoomResult.RoomStatus
         * @instance
         */
        RoomStatus.prototype.hasPwd = false;

        /**
         * RoomStatus fmicIsMananger.
         * @member {boolean} fmicIsMananger
         * @memberof RoomResult.RoomStatus
         * @instance
         */
        RoomStatus.prototype.fmicIsMananger = false;

        /**
         * RoomStatus isOnMic.
         * @member {boolean} isOnMic
         * @memberof RoomResult.RoomStatus
         * @instance
         */
        RoomStatus.prototype.isOnMic = false;

        /**
         * Decodes a RoomStatus message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomStatus} RoomStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.isLive = reader.bool();
                    break;
                case 3:
                    message.hasPwd = reader.bool();
                    break;
                case 4:
                    message.fmicIsMananger = reader.bool();
                    break;
                case 5:
                    message.isOnMic = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("isLive"))
                throw $util.ProtocolError("missing required 'isLive'", { instance: message });
            if (!message.hasOwnProperty("hasPwd"))
                throw $util.ProtocolError("missing required 'hasPwd'", { instance: message });
            if (!message.hasOwnProperty("fmicIsMananger"))
                throw $util.ProtocolError("missing required 'fmicIsMananger'", { instance: message });
            if (!message.hasOwnProperty("isOnMic"))
                throw $util.ProtocolError("missing required 'isOnMic'", { instance: message });
            return message;
        };

        /**
         * Decodes a RoomStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomStatus} RoomStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomStatus;
    })();

    RoomResult.RoomUserInfo = (function() {

        /**
         * Properties of a RoomUserInfo.
         * @memberof RoomResult
         * @interface IRoomUserInfo
         * @property {string|null} [roomId] RoomUserInfo roomId
         * @property {boolean|null} [isLive] RoomUserInfo isLive
         * @property {number|null} [micPosition] RoomUserInfo micPosition
         * @property {number|null} [jobId] RoomUserInfo jobId
         */

        /**
         * Constructs a new RoomUserInfo.
         * @memberof RoomResult
         * @classdesc Represents a RoomUserInfo.
         * @implements IRoomUserInfo
         * @constructor
         * @param {RoomResult.IRoomUserInfo=} [properties] Properties to set
         */
        function RoomUserInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomUserInfo roomId.
         * @member {string} roomId
         * @memberof RoomResult.RoomUserInfo
         * @instance
         */
        RoomUserInfo.prototype.roomId = "";

        /**
         * RoomUserInfo isLive.
         * @member {boolean} isLive
         * @memberof RoomResult.RoomUserInfo
         * @instance
         */
        RoomUserInfo.prototype.isLive = false;

        /**
         * RoomUserInfo micPosition.
         * @member {number} micPosition
         * @memberof RoomResult.RoomUserInfo
         * @instance
         */
        RoomUserInfo.prototype.micPosition = 0;

        /**
         * RoomUserInfo jobId.
         * @member {number} jobId
         * @memberof RoomResult.RoomUserInfo
         * @instance
         */
        RoomUserInfo.prototype.jobId = 0;

        /**
         * Decodes a RoomUserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RoomResult.RoomUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RoomResult.RoomUserInfo} RoomUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomUserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RoomResult.RoomUserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.isLive = reader.bool();
                    break;
                case 3:
                    message.micPosition = reader.int32();
                    break;
                case 4:
                    message.jobId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoomUserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RoomResult.RoomUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RoomResult.RoomUserInfo} RoomUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomUserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomUserInfo;
    })();

    return RoomResult;
})();

export const PublicChatResult = $root.PublicChatResult = (() => {

    /**
     * Namespace PublicChatResult.
     * @exports PublicChatResult
     * @namespace
     */
    const PublicChatResult = {};

    PublicChatResult.PublicChatMessageList = (function() {

        /**
         * Properties of a PublicChatMessageList.
         * @memberof PublicChatResult
         * @interface IPublicChatMessageList
         * @property {Array.<PublicChatResult.IPublicChatMessage>|null} [list] PublicChatMessageList list
         */

        /**
         * Constructs a new PublicChatMessageList.
         * @memberof PublicChatResult
         * @classdesc Represents a PublicChatMessageList.
         * @implements IPublicChatMessageList
         * @constructor
         * @param {PublicChatResult.IPublicChatMessageList=} [properties] Properties to set
         */
        function PublicChatMessageList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublicChatMessageList list.
         * @member {Array.<PublicChatResult.IPublicChatMessage>} list
         * @memberof PublicChatResult.PublicChatMessageList
         * @instance
         */
        PublicChatMessageList.prototype.list = $util.emptyArray;

        /**
         * Decodes a PublicChatMessageList message from the specified reader or buffer.
         * @function decode
         * @memberof PublicChatResult.PublicChatMessageList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PublicChatResult.PublicChatMessageList} PublicChatMessageList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicChatMessageList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublicChatResult.PublicChatMessageList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.PublicChatResult.PublicChatMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublicChatMessageList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PublicChatResult.PublicChatMessageList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PublicChatResult.PublicChatMessageList} PublicChatMessageList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicChatMessageList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return PublicChatMessageList;
    })();

    PublicChatResult.PublicChatMessage = (function() {

        /**
         * Properties of a PublicChatMessage.
         * @memberof PublicChatResult
         * @interface IPublicChatMessage
         * @property {string} id PublicChatMessage id
         * @property {string} userId PublicChatMessage userId
         * @property {string|null} [userNickName] PublicChatMessage userNickName
         * @property {string} message PublicChatMessage message
         * @property {string|null} [currentRoomId] PublicChatMessage currentRoomId
         * @property {number|Long|null} [createTime] PublicChatMessage createTime
         * @property {UserResult.IUserBase|null} [userBase] PublicChatMessage userBase
         */

        /**
         * Constructs a new PublicChatMessage.
         * @memberof PublicChatResult
         * @classdesc Represents a PublicChatMessage.
         * @implements IPublicChatMessage
         * @constructor
         * @param {PublicChatResult.IPublicChatMessage=} [properties] Properties to set
         */
        function PublicChatMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublicChatMessage id.
         * @member {string} id
         * @memberof PublicChatResult.PublicChatMessage
         * @instance
         */
        PublicChatMessage.prototype.id = "";

        /**
         * PublicChatMessage userId.
         * @member {string} userId
         * @memberof PublicChatResult.PublicChatMessage
         * @instance
         */
        PublicChatMessage.prototype.userId = "";

        /**
         * PublicChatMessage userNickName.
         * @member {string} userNickName
         * @memberof PublicChatResult.PublicChatMessage
         * @instance
         */
        PublicChatMessage.prototype.userNickName = "";

        /**
         * PublicChatMessage message.
         * @member {string} message
         * @memberof PublicChatResult.PublicChatMessage
         * @instance
         */
        PublicChatMessage.prototype.message = "";

        /**
         * PublicChatMessage currentRoomId.
         * @member {string} currentRoomId
         * @memberof PublicChatResult.PublicChatMessage
         * @instance
         */
        PublicChatMessage.prototype.currentRoomId = "";

        /**
         * PublicChatMessage createTime.
         * @member {number|Long} createTime
         * @memberof PublicChatResult.PublicChatMessage
         * @instance
         */
        PublicChatMessage.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PublicChatMessage userBase.
         * @member {UserResult.IUserBase|null|undefined} userBase
         * @memberof PublicChatResult.PublicChatMessage
         * @instance
         */
        PublicChatMessage.prototype.userBase = null;

        /**
         * Decodes a PublicChatMessage message from the specified reader or buffer.
         * @function decode
         * @memberof PublicChatResult.PublicChatMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PublicChatResult.PublicChatMessage} PublicChatMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicChatMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublicChatResult.PublicChatMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.userNickName = reader.string();
                    break;
                case 4:
                    message.message = reader.string();
                    break;
                case 5:
                    message.currentRoomId = reader.string();
                    break;
                case 6:
                    message.createTime = reader.int64();
                    break;
                case 7:
                    message.userBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("message"))
                throw $util.ProtocolError("missing required 'message'", { instance: message });
            return message;
        };

        /**
         * Decodes a PublicChatMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PublicChatResult.PublicChatMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PublicChatResult.PublicChatMessage} PublicChatMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicChatMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return PublicChatMessage;
    })();

    return PublicChatResult;
})();

export const CardResult = $root.CardResult = (() => {

    /**
     * Namespace CardResult.
     * @exports CardResult
     * @namespace
     */
    const CardResult = {};

    CardResult.CardInfo = (function() {

        /**
         * Properties of a CardInfo.
         * @memberof CardResult
         * @interface ICardInfo
         * @property {string} userId CardInfo userId
         * @property {string} roomId CardInfo roomId
         * @property {string|null} [roomName] CardInfo roomName
         * @property {number|null} [type] CardInfo type
         * @property {number|Long|null} [totalContribute] CardInfo totalContribute
         * @property {number|null} [remainDays] CardInfo remainDays
         * @property {number|Long|null} [keepContribute] CardInfo keepContribute
         * @property {boolean|null} [isLive] CardInfo isLive
         * @property {number|Long|null} [weekContribute] CardInfo weekContribute
         * @property {UserResult.IUserBase|null} [userBase] CardInfo userBase
         * @property {number|null} [upType] CardInfo upType
         * @property {number|Long|null} [upContribute] CardInfo upContribute
         */

        /**
         * Constructs a new CardInfo.
         * @memberof CardResult
         * @classdesc Represents a CardInfo.
         * @implements ICardInfo
         * @constructor
         * @param {CardResult.ICardInfo=} [properties] Properties to set
         */
        function CardInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardInfo userId.
         * @member {string} userId
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.userId = "";

        /**
         * CardInfo roomId.
         * @member {string} roomId
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.roomId = "";

        /**
         * CardInfo roomName.
         * @member {string} roomName
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.roomName = "";

        /**
         * CardInfo type.
         * @member {number} type
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.type = 0;

        /**
         * CardInfo totalContribute.
         * @member {number|Long} totalContribute
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.totalContribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CardInfo remainDays.
         * @member {number} remainDays
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.remainDays = 0;

        /**
         * CardInfo keepContribute.
         * @member {number|Long} keepContribute
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.keepContribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CardInfo isLive.
         * @member {boolean} isLive
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.isLive = false;

        /**
         * CardInfo weekContribute.
         * @member {number|Long} weekContribute
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.weekContribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CardInfo userBase.
         * @member {UserResult.IUserBase|null|undefined} userBase
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.userBase = null;

        /**
         * CardInfo upType.
         * @member {number} upType
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.upType = 0;

        /**
         * CardInfo upContribute.
         * @member {number|Long} upContribute
         * @memberof CardResult.CardInfo
         * @instance
         */
        CardInfo.prototype.upContribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a CardInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CardResult.CardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CardResult.CardInfo} CardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CardResult.CardInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.roomId = reader.string();
                    break;
                case 3:
                    message.roomName = reader.string();
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                case 5:
                    message.totalContribute = reader.int64();
                    break;
                case 6:
                    message.remainDays = reader.int32();
                    break;
                case 7:
                    message.keepContribute = reader.int64();
                    break;
                case 8:
                    message.isLive = reader.bool();
                    break;
                case 9:
                    message.weekContribute = reader.int64();
                    break;
                case 10:
                    message.userBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.upType = reader.int32();
                    break;
                case 12:
                    message.upContribute = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            return message;
        };

        /**
         * Decodes a CardInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CardResult.CardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CardResult.CardInfo} CardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CardInfo;
    })();

    CardResult.UserCardList = (function() {

        /**
         * Properties of a UserCardList.
         * @memberof CardResult
         * @interface IUserCardList
         * @property {Array.<CardResult.ICardInfo>|null} [list] UserCardList list
         */

        /**
         * Constructs a new UserCardList.
         * @memberof CardResult
         * @classdesc Represents a UserCardList.
         * @implements IUserCardList
         * @constructor
         * @param {CardResult.IUserCardList=} [properties] Properties to set
         */
        function UserCardList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserCardList list.
         * @member {Array.<CardResult.ICardInfo>} list
         * @memberof CardResult.UserCardList
         * @instance
         */
        UserCardList.prototype.list = $util.emptyArray;

        /**
         * Decodes a UserCardList message from the specified reader or buffer.
         * @function decode
         * @memberof CardResult.UserCardList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CardResult.UserCardList} UserCardList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCardList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CardResult.UserCardList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.CardResult.CardInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserCardList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CardResult.UserCardList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CardResult.UserCardList} UserCardList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCardList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserCardList;
    })();

    CardResult.RoomCardList = (function() {

        /**
         * Properties of a RoomCardList.
         * @memberof CardResult
         * @interface IRoomCardList
         * @property {Array.<CardResult.ICardInfo>|null} [list] RoomCardList list
         * @property {number|null} [starLimit] RoomCardList starLimit
         */

        /**
         * Constructs a new RoomCardList.
         * @memberof CardResult
         * @classdesc Represents a RoomCardList.
         * @implements IRoomCardList
         * @constructor
         * @param {CardResult.IRoomCardList=} [properties] Properties to set
         */
        function RoomCardList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomCardList list.
         * @member {Array.<CardResult.ICardInfo>} list
         * @memberof CardResult.RoomCardList
         * @instance
         */
        RoomCardList.prototype.list = $util.emptyArray;

        /**
         * RoomCardList starLimit.
         * @member {number} starLimit
         * @memberof CardResult.RoomCardList
         * @instance
         */
        RoomCardList.prototype.starLimit = 0;

        /**
         * Decodes a RoomCardList message from the specified reader or buffer.
         * @function decode
         * @memberof CardResult.RoomCardList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CardResult.RoomCardList} RoomCardList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomCardList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CardResult.RoomCardList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.CardResult.CardInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.starLimit = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoomCardList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CardResult.RoomCardList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CardResult.RoomCardList} RoomCardList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomCardList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoomCardList;
    })();

    CardResult.CardType = (function() {

        /**
         * Properties of a CardType.
         * @memberof CardResult
         * @interface ICardType
         * @property {number|null} [type] CardType type
         */

        /**
         * Constructs a new CardType.
         * @memberof CardResult
         * @classdesc Represents a CardType.
         * @implements ICardType
         * @constructor
         * @param {CardResult.ICardType=} [properties] Properties to set
         */
        function CardType(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardType type.
         * @member {number} type
         * @memberof CardResult.CardType
         * @instance
         */
        CardType.prototype.type = 0;

        /**
         * Decodes a CardType message from the specified reader or buffer.
         * @function decode
         * @memberof CardResult.CardType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CardResult.CardType} CardType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CardResult.CardType();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CardResult.CardType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CardResult.CardType} CardType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CardType;
    })();

    CardResult.CardUpLevelBroadcast = (function() {

        /**
         * Properties of a CardUpLevelBroadcast.
         * @memberof CardResult
         * @interface ICardUpLevelBroadcast
         * @property {string|null} [userId] CardUpLevelBroadcast userId
         * @property {string|null} [nickName] CardUpLevelBroadcast nickName
         * @property {number|null} [contributeLv] CardUpLevelBroadcast contributeLv
         * @property {number|null} [type] CardUpLevelBroadcast type
         * @property {number|null} [sex] CardUpLevelBroadcast sex
         * @property {number|null} [status] CardUpLevelBroadcast status
         */

        /**
         * Constructs a new CardUpLevelBroadcast.
         * @memberof CardResult
         * @classdesc Represents a CardUpLevelBroadcast.
         * @implements ICardUpLevelBroadcast
         * @constructor
         * @param {CardResult.ICardUpLevelBroadcast=} [properties] Properties to set
         */
        function CardUpLevelBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardUpLevelBroadcast userId.
         * @member {string} userId
         * @memberof CardResult.CardUpLevelBroadcast
         * @instance
         */
        CardUpLevelBroadcast.prototype.userId = "";

        /**
         * CardUpLevelBroadcast nickName.
         * @member {string} nickName
         * @memberof CardResult.CardUpLevelBroadcast
         * @instance
         */
        CardUpLevelBroadcast.prototype.nickName = "";

        /**
         * CardUpLevelBroadcast contributeLv.
         * @member {number} contributeLv
         * @memberof CardResult.CardUpLevelBroadcast
         * @instance
         */
        CardUpLevelBroadcast.prototype.contributeLv = 0;

        /**
         * CardUpLevelBroadcast type.
         * @member {number} type
         * @memberof CardResult.CardUpLevelBroadcast
         * @instance
         */
        CardUpLevelBroadcast.prototype.type = 0;

        /**
         * CardUpLevelBroadcast sex.
         * @member {number} sex
         * @memberof CardResult.CardUpLevelBroadcast
         * @instance
         */
        CardUpLevelBroadcast.prototype.sex = 0;

        /**
         * CardUpLevelBroadcast status.
         * @member {number} status
         * @memberof CardResult.CardUpLevelBroadcast
         * @instance
         */
        CardUpLevelBroadcast.prototype.status = 0;

        /**
         * Decodes a CardUpLevelBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof CardResult.CardUpLevelBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CardResult.CardUpLevelBroadcast} CardUpLevelBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardUpLevelBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CardResult.CardUpLevelBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.nickName = reader.string();
                    break;
                case 3:
                    message.contributeLv = reader.int32();
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                case 5:
                    message.sex = reader.int32();
                    break;
                case 6:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardUpLevelBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CardResult.CardUpLevelBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CardResult.CardUpLevelBroadcast} CardUpLevelBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardUpLevelBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CardUpLevelBroadcast;
    })();

    return CardResult;
})();

export const CommentResult = $root.CommentResult = (() => {

    /**
     * Namespace CommentResult.
     * @exports CommentResult
     * @namespace
     */
    const CommentResult = {};

    CommentResult.CommentMixtureVOs = (function() {

        /**
         * Properties of a CommentMixtureVOs.
         * @memberof CommentResult
         * @interface ICommentMixtureVOs
         * @property {Array.<CommentResult.ICommentMixtureVO>|null} [commentMixtureVO] CommentMixtureVOs commentMixtureVO
         * @property {CommentResult.ICommentMixtureVO|null} [parentCommentMixtureVO] CommentMixtureVOs parentCommentMixtureVO
         */

        /**
         * Constructs a new CommentMixtureVOs.
         * @memberof CommentResult
         * @classdesc Represents a CommentMixtureVOs.
         * @implements ICommentMixtureVOs
         * @constructor
         * @param {CommentResult.ICommentMixtureVOs=} [properties] Properties to set
         */
        function CommentMixtureVOs(properties) {
            this.commentMixtureVO = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommentMixtureVOs commentMixtureVO.
         * @member {Array.<CommentResult.ICommentMixtureVO>} commentMixtureVO
         * @memberof CommentResult.CommentMixtureVOs
         * @instance
         */
        CommentMixtureVOs.prototype.commentMixtureVO = $util.emptyArray;

        /**
         * CommentMixtureVOs parentCommentMixtureVO.
         * @member {CommentResult.ICommentMixtureVO|null|undefined} parentCommentMixtureVO
         * @memberof CommentResult.CommentMixtureVOs
         * @instance
         */
        CommentMixtureVOs.prototype.parentCommentMixtureVO = null;

        /**
         * Decodes a CommentMixtureVOs message from the specified reader or buffer.
         * @function decode
         * @memberof CommentResult.CommentMixtureVOs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommentResult.CommentMixtureVOs} CommentMixtureVOs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommentMixtureVOs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommentResult.CommentMixtureVOs();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.commentMixtureVO && message.commentMixtureVO.length))
                        message.commentMixtureVO = [];
                    message.commentMixtureVO.push($root.CommentResult.CommentMixtureVO.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.parentCommentMixtureVO = $root.CommentResult.CommentMixtureVO.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommentMixtureVOs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommentResult.CommentMixtureVOs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommentResult.CommentMixtureVOs} CommentMixtureVOs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommentMixtureVOs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CommentMixtureVOs;
    })();

    CommentResult.CommentMixtureVO = (function() {

        /**
         * Properties of a CommentMixtureVO.
         * @memberof CommentResult
         * @interface ICommentMixtureVO
         * @property {UserResult.IUserBase|null} [userInfo] CommentMixtureVO userInfo
         * @property {CommentResult.ICommentVO|null} [commentVO] CommentMixtureVO commentVO
         * @property {UserResult.IUserBase|null} [beReplyUserInfo] CommentMixtureVO beReplyUserInfo
         */

        /**
         * Constructs a new CommentMixtureVO.
         * @memberof CommentResult
         * @classdesc Represents a CommentMixtureVO.
         * @implements ICommentMixtureVO
         * @constructor
         * @param {CommentResult.ICommentMixtureVO=} [properties] Properties to set
         */
        function CommentMixtureVO(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommentMixtureVO userInfo.
         * @member {UserResult.IUserBase|null|undefined} userInfo
         * @memberof CommentResult.CommentMixtureVO
         * @instance
         */
        CommentMixtureVO.prototype.userInfo = null;

        /**
         * CommentMixtureVO commentVO.
         * @member {CommentResult.ICommentVO|null|undefined} commentVO
         * @memberof CommentResult.CommentMixtureVO
         * @instance
         */
        CommentMixtureVO.prototype.commentVO = null;

        /**
         * CommentMixtureVO beReplyUserInfo.
         * @member {UserResult.IUserBase|null|undefined} beReplyUserInfo
         * @memberof CommentResult.CommentMixtureVO
         * @instance
         */
        CommentMixtureVO.prototype.beReplyUserInfo = null;

        /**
         * Decodes a CommentMixtureVO message from the specified reader or buffer.
         * @function decode
         * @memberof CommentResult.CommentMixtureVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommentResult.CommentMixtureVO} CommentMixtureVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommentMixtureVO.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommentResult.CommentMixtureVO();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userInfo = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.commentVO = $root.CommentResult.CommentVO.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.beReplyUserInfo = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommentMixtureVO message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommentResult.CommentMixtureVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommentResult.CommentMixtureVO} CommentMixtureVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommentMixtureVO.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CommentMixtureVO;
    })();

    CommentResult.CommentVO = (function() {

        /**
         * Properties of a CommentVO.
         * @memberof CommentResult
         * @interface ICommentVO
         * @property {string} id CommentVO id
         * @property {string} userId CommentVO userId
         * @property {string|null} [word] CommentVO word
         * @property {string|null} [voice] CommentVO voice
         * @property {Array.<string>|null} [pics] CommentVO pics
         * @property {number|null} [likes] CommentVO likes
         * @property {number|null} [comments] CommentVO comments
         * @property {boolean|null} [isLike] CommentVO isLike
         * @property {string|null} [issueTime] CommentVO issueTime
         * @property {number|null} [version] CommentVO version
         * @property {Array.<CommentResult.ICommentVO>|null} [CommentVO] CommentVO CommentVO
         * @property {string|null} [beRepliedCommentId] CommentVO beRepliedCommentId
         */

        /**
         * Constructs a new CommentVO.
         * @memberof CommentResult
         * @classdesc Represents a CommentVO.
         * @implements ICommentVO
         * @constructor
         * @param {CommentResult.ICommentVO=} [properties] Properties to set
         */
        function CommentVO(properties) {
            this.pics = [];
            this.CommentVO = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommentVO id.
         * @member {string} id
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.id = "";

        /**
         * CommentVO userId.
         * @member {string} userId
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.userId = "";

        /**
         * CommentVO word.
         * @member {string} word
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.word = "";

        /**
         * CommentVO voice.
         * @member {string} voice
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.voice = "";

        /**
         * CommentVO pics.
         * @member {Array.<string>} pics
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.pics = $util.emptyArray;

        /**
         * CommentVO likes.
         * @member {number} likes
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.likes = 0;

        /**
         * CommentVO comments.
         * @member {number} comments
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.comments = 0;

        /**
         * CommentVO isLike.
         * @member {boolean} isLike
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.isLike = false;

        /**
         * CommentVO issueTime.
         * @member {string} issueTime
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.issueTime = "";

        /**
         * CommentVO version.
         * @member {number} version
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.version = 0;

        /**
         * CommentVO CommentVO.
         * @member {Array.<CommentResult.ICommentVO>} CommentVO
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.CommentVO = $util.emptyArray;

        /**
         * CommentVO beRepliedCommentId.
         * @member {string} beRepliedCommentId
         * @memberof CommentResult.CommentVO
         * @instance
         */
        CommentVO.prototype.beRepliedCommentId = "";

        /**
         * Decodes a CommentVO message from the specified reader or buffer.
         * @function decode
         * @memberof CommentResult.CommentVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommentResult.CommentVO} CommentVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommentVO.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommentResult.CommentVO();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.word = reader.string();
                    break;
                case 4:
                    message.voice = reader.string();
                    break;
                case 5:
                    if (!(message.pics && message.pics.length))
                        message.pics = [];
                    message.pics.push(reader.string());
                    break;
                case 6:
                    message.likes = reader.int32();
                    break;
                case 7:
                    message.comments = reader.int32();
                    break;
                case 8:
                    message.isLike = reader.bool();
                    break;
                case 9:
                    message.issueTime = reader.string();
                    break;
                case 10:
                    message.version = reader.int32();
                    break;
                case 11:
                    if (!(message.CommentVO && message.CommentVO.length))
                        message.CommentVO = [];
                    message.CommentVO.push($root.CommentResult.CommentVO.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.beRepliedCommentId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            return message;
        };

        /**
         * Decodes a CommentVO message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommentResult.CommentVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommentResult.CommentVO} CommentVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommentVO.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CommentVO;
    })();

    return CommentResult;
})();

export const CommonResult = $root.CommonResult = (() => {

    /**
     * Namespace CommonResult.
     * @exports CommonResult
     * @namespace
     */
    const CommonResult = {};

    CommonResult.StringResult = (function() {

        /**
         * Properties of a StringResult.
         * @memberof CommonResult
         * @interface IStringResult
         * @property {string} data StringResult data
         */

        /**
         * Constructs a new StringResult.
         * @memberof CommonResult
         * @classdesc Represents a StringResult.
         * @implements IStringResult
         * @constructor
         * @param {CommonResult.IStringResult=} [properties] Properties to set
         */
        function StringResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StringResult data.
         * @member {string} data
         * @memberof CommonResult.StringResult
         * @instance
         */
        StringResult.prototype.data = "";

        /**
         * Decodes a StringResult message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.StringResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.StringResult} StringResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.StringResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("data"))
                throw $util.ProtocolError("missing required 'data'", { instance: message });
            return message;
        };

        /**
         * Decodes a StringResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.StringResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.StringResult} StringResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return StringResult;
    })();

    CommonResult.StringArrayResult = (function() {

        /**
         * Properties of a StringArrayResult.
         * @memberof CommonResult
         * @interface IStringArrayResult
         * @property {Array.<string>|null} [datas] StringArrayResult datas
         */

        /**
         * Constructs a new StringArrayResult.
         * @memberof CommonResult
         * @classdesc Represents a StringArrayResult.
         * @implements IStringArrayResult
         * @constructor
         * @param {CommonResult.IStringArrayResult=} [properties] Properties to set
         */
        function StringArrayResult(properties) {
            this.datas = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StringArrayResult datas.
         * @member {Array.<string>} datas
         * @memberof CommonResult.StringArrayResult
         * @instance
         */
        StringArrayResult.prototype.datas = $util.emptyArray;

        /**
         * Decodes a StringArrayResult message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.StringArrayResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.StringArrayResult} StringArrayResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringArrayResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.StringArrayResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.datas && message.datas.length))
                        message.datas = [];
                    message.datas.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StringArrayResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.StringArrayResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.StringArrayResult} StringArrayResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringArrayResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return StringArrayResult;
    })();

    CommonResult.IntResult = (function() {

        /**
         * Properties of an IntResult.
         * @memberof CommonResult
         * @interface IIntResult
         * @property {number} data IntResult data
         */

        /**
         * Constructs a new IntResult.
         * @memberof CommonResult
         * @classdesc Represents an IntResult.
         * @implements IIntResult
         * @constructor
         * @param {CommonResult.IIntResult=} [properties] Properties to set
         */
        function IntResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IntResult data.
         * @member {number} data
         * @memberof CommonResult.IntResult
         * @instance
         */
        IntResult.prototype.data = 0;

        /**
         * Decodes an IntResult message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.IntResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.IntResult} IntResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.IntResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("data"))
                throw $util.ProtocolError("missing required 'data'", { instance: message });
            return message;
        };

        /**
         * Decodes an IntResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.IntResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.IntResult} IntResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return IntResult;
    })();

    CommonResult.LongResult = (function() {

        /**
         * Properties of a LongResult.
         * @memberof CommonResult
         * @interface ILongResult
         * @property {number|Long} data LongResult data
         */

        /**
         * Constructs a new LongResult.
         * @memberof CommonResult
         * @classdesc Represents a LongResult.
         * @implements ILongResult
         * @constructor
         * @param {CommonResult.ILongResult=} [properties] Properties to set
         */
        function LongResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LongResult data.
         * @member {number|Long} data
         * @memberof CommonResult.LongResult
         * @instance
         */
        LongResult.prototype.data = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a LongResult message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.LongResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.LongResult} LongResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LongResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.LongResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("data"))
                throw $util.ProtocolError("missing required 'data'", { instance: message });
            return message;
        };

        /**
         * Decodes a LongResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.LongResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.LongResult} LongResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LongResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LongResult;
    })();

    CommonResult.FloatResult = (function() {

        /**
         * Properties of a FloatResult.
         * @memberof CommonResult
         * @interface IFloatResult
         * @property {number} data FloatResult data
         */

        /**
         * Constructs a new FloatResult.
         * @memberof CommonResult
         * @classdesc Represents a FloatResult.
         * @implements IFloatResult
         * @constructor
         * @param {CommonResult.IFloatResult=} [properties] Properties to set
         */
        function FloatResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FloatResult data.
         * @member {number} data
         * @memberof CommonResult.FloatResult
         * @instance
         */
        FloatResult.prototype.data = 0;

        /**
         * Decodes a FloatResult message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.FloatResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.FloatResult} FloatResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.FloatResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("data"))
                throw $util.ProtocolError("missing required 'data'", { instance: message });
            return message;
        };

        /**
         * Decodes a FloatResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.FloatResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.FloatResult} FloatResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FloatResult;
    })();

    CommonResult.DoubleResult = (function() {

        /**
         * Properties of a DoubleResult.
         * @memberof CommonResult
         * @interface IDoubleResult
         * @property {number} data DoubleResult data
         */

        /**
         * Constructs a new DoubleResult.
         * @memberof CommonResult
         * @classdesc Represents a DoubleResult.
         * @implements IDoubleResult
         * @constructor
         * @param {CommonResult.IDoubleResult=} [properties] Properties to set
         */
        function DoubleResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DoubleResult data.
         * @member {number} data
         * @memberof CommonResult.DoubleResult
         * @instance
         */
        DoubleResult.prototype.data = 0;

        /**
         * Decodes a DoubleResult message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.DoubleResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.DoubleResult} DoubleResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DoubleResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.DoubleResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("data"))
                throw $util.ProtocolError("missing required 'data'", { instance: message });
            return message;
        };

        /**
         * Decodes a DoubleResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.DoubleResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.DoubleResult} DoubleResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DoubleResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return DoubleResult;
    })();

    CommonResult.BoolResult = (function() {

        /**
         * Properties of a BoolResult.
         * @memberof CommonResult
         * @interface IBoolResult
         * @property {boolean} data BoolResult data
         */

        /**
         * Constructs a new BoolResult.
         * @memberof CommonResult
         * @classdesc Represents a BoolResult.
         * @implements IBoolResult
         * @constructor
         * @param {CommonResult.IBoolResult=} [properties] Properties to set
         */
        function BoolResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BoolResult data.
         * @member {boolean} data
         * @memberof CommonResult.BoolResult
         * @instance
         */
        BoolResult.prototype.data = false;

        /**
         * Decodes a BoolResult message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.BoolResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.BoolResult} BoolResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoolResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.BoolResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("data"))
                throw $util.ProtocolError("missing required 'data'", { instance: message });
            return message;
        };

        /**
         * Decodes a BoolResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.BoolResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.BoolResult} BoolResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoolResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return BoolResult;
    })();

    CommonResult.IntDatas = (function() {

        /**
         * Properties of an IntDatas.
         * @memberof CommonResult
         * @interface IIntDatas
         * @property {Array.<number>|null} [datas] IntDatas datas
         */

        /**
         * Constructs a new IntDatas.
         * @memberof CommonResult
         * @classdesc Represents an IntDatas.
         * @implements IIntDatas
         * @constructor
         * @param {CommonResult.IIntDatas=} [properties] Properties to set
         */
        function IntDatas(properties) {
            this.datas = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IntDatas datas.
         * @member {Array.<number>} datas
         * @memberof CommonResult.IntDatas
         * @instance
         */
        IntDatas.prototype.datas = $util.emptyArray;

        /**
         * Decodes an IntDatas message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.IntDatas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.IntDatas} IntDatas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntDatas.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.IntDatas();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.datas && message.datas.length))
                        message.datas = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.datas.push(reader.int32());
                    } else
                        message.datas.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IntDatas message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.IntDatas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.IntDatas} IntDatas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntDatas.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return IntDatas;
    })();

    CommonResult.FloatDatas = (function() {

        /**
         * Properties of a FloatDatas.
         * @memberof CommonResult
         * @interface IFloatDatas
         * @property {Array.<number>|null} [data] FloatDatas data
         */

        /**
         * Constructs a new FloatDatas.
         * @memberof CommonResult
         * @classdesc Represents a FloatDatas.
         * @implements IFloatDatas
         * @constructor
         * @param {CommonResult.IFloatDatas=} [properties] Properties to set
         */
        function FloatDatas(properties) {
            this.data = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FloatDatas data.
         * @member {Array.<number>} data
         * @memberof CommonResult.FloatDatas
         * @instance
         */
        FloatDatas.prototype.data = $util.emptyArray;

        /**
         * Decodes a FloatDatas message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.FloatDatas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.FloatDatas} FloatDatas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatDatas.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.FloatDatas();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.data && message.data.length))
                        message.data = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.data.push(reader.double());
                    } else
                        message.data.push(reader.double());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FloatDatas message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.FloatDatas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.FloatDatas} FloatDatas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatDatas.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FloatDatas;
    })();

    CommonResult.DoubleDatas = (function() {

        /**
         * Properties of a DoubleDatas.
         * @memberof CommonResult
         * @interface IDoubleDatas
         * @property {Array.<number>|null} [data] DoubleDatas data
         */

        /**
         * Constructs a new DoubleDatas.
         * @memberof CommonResult
         * @classdesc Represents a DoubleDatas.
         * @implements IDoubleDatas
         * @constructor
         * @param {CommonResult.IDoubleDatas=} [properties] Properties to set
         */
        function DoubleDatas(properties) {
            this.data = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DoubleDatas data.
         * @member {Array.<number>} data
         * @memberof CommonResult.DoubleDatas
         * @instance
         */
        DoubleDatas.prototype.data = $util.emptyArray;

        /**
         * Decodes a DoubleDatas message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.DoubleDatas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.DoubleDatas} DoubleDatas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DoubleDatas.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.DoubleDatas();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.data && message.data.length))
                        message.data = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.data.push(reader.double());
                    } else
                        message.data.push(reader.double());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DoubleDatas message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.DoubleDatas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.DoubleDatas} DoubleDatas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DoubleDatas.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return DoubleDatas;
    })();

    CommonResult.IdNums = (function() {

        /**
         * Properties of an IdNums.
         * @memberof CommonResult
         * @interface IIdNums
         * @property {Array.<number>|null} [ids] IdNums ids
         * @property {Array.<number>|null} [nums] IdNums nums
         */

        /**
         * Constructs a new IdNums.
         * @memberof CommonResult
         * @classdesc Represents an IdNums.
         * @implements IIdNums
         * @constructor
         * @param {CommonResult.IIdNums=} [properties] Properties to set
         */
        function IdNums(properties) {
            this.ids = [];
            this.nums = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdNums ids.
         * @member {Array.<number>} ids
         * @memberof CommonResult.IdNums
         * @instance
         */
        IdNums.prototype.ids = $util.emptyArray;

        /**
         * IdNums nums.
         * @member {Array.<number>} nums
         * @memberof CommonResult.IdNums
         * @instance
         */
        IdNums.prototype.nums = $util.emptyArray;

        /**
         * Decodes an IdNums message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.IdNums
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.IdNums} IdNums
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdNums.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.IdNums();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ids.push(reader.int32());
                    } else
                        message.ids.push(reader.int32());
                    break;
                case 2:
                    if (!(message.nums && message.nums.length))
                        message.nums = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.nums.push(reader.int32());
                    } else
                        message.nums.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdNums message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.IdNums
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.IdNums} IdNums
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdNums.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return IdNums;
    })();

    CommonResult.SearchData = (function() {

        /**
         * Properties of a SearchData.
         * @memberof CommonResult
         * @interface ISearchData
         * @property {Array.<CommonResult.ISearchVo>|null} [datas] SearchData datas
         */

        /**
         * Constructs a new SearchData.
         * @memberof CommonResult
         * @classdesc Represents a SearchData.
         * @implements ISearchData
         * @constructor
         * @param {CommonResult.ISearchData=} [properties] Properties to set
         */
        function SearchData(properties) {
            this.datas = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchData datas.
         * @member {Array.<CommonResult.ISearchVo>} datas
         * @memberof CommonResult.SearchData
         * @instance
         */
        SearchData.prototype.datas = $util.emptyArray;

        /**
         * Decodes a SearchData message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.SearchData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.SearchData} SearchData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.SearchData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.datas && message.datas.length))
                        message.datas = [];
                    message.datas.push($root.CommonResult.SearchVo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.SearchData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.SearchData} SearchData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SearchData;
    })();

    CommonResult.SearchVo = (function() {

        /**
         * Properties of a SearchVo.
         * @memberof CommonResult
         * @interface ISearchVo
         * @property {number} type SearchVo type
         * @property {string} id SearchVo id
         * @property {string} name SearchVo name
         * @property {number} logoTime SearchVo logoTime
         * @property {string|null} [gameId] SearchVo gameId
         * @property {string|null} [unionId] SearchVo unionId
         * @property {boolean|null} [password] SearchVo password
         * @property {number|null} [onlineNum] SearchVo onlineNum
         * @property {number|null} [jobId] SearchVo jobId
         * @property {number|null} [unionType] SearchVo unionType
         */

        /**
         * Constructs a new SearchVo.
         * @memberof CommonResult
         * @classdesc Represents a SearchVo.
         * @implements ISearchVo
         * @constructor
         * @param {CommonResult.ISearchVo=} [properties] Properties to set
         */
        function SearchVo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchVo type.
         * @member {number} type
         * @memberof CommonResult.SearchVo
         * @instance
         */
        SearchVo.prototype.type = 0;

        /**
         * SearchVo id.
         * @member {string} id
         * @memberof CommonResult.SearchVo
         * @instance
         */
        SearchVo.prototype.id = "";

        /**
         * SearchVo name.
         * @member {string} name
         * @memberof CommonResult.SearchVo
         * @instance
         */
        SearchVo.prototype.name = "";

        /**
         * SearchVo logoTime.
         * @member {number} logoTime
         * @memberof CommonResult.SearchVo
         * @instance
         */
        SearchVo.prototype.logoTime = 0;

        /**
         * SearchVo gameId.
         * @member {string} gameId
         * @memberof CommonResult.SearchVo
         * @instance
         */
        SearchVo.prototype.gameId = "";

        /**
         * SearchVo unionId.
         * @member {string} unionId
         * @memberof CommonResult.SearchVo
         * @instance
         */
        SearchVo.prototype.unionId = "";

        /**
         * SearchVo password.
         * @member {boolean} password
         * @memberof CommonResult.SearchVo
         * @instance
         */
        SearchVo.prototype.password = false;

        /**
         * SearchVo onlineNum.
         * @member {number} onlineNum
         * @memberof CommonResult.SearchVo
         * @instance
         */
        SearchVo.prototype.onlineNum = 0;

        /**
         * SearchVo jobId.
         * @member {number} jobId
         * @memberof CommonResult.SearchVo
         * @instance
         */
        SearchVo.prototype.jobId = 0;

        /**
         * SearchVo unionType.
         * @member {number} unionType
         * @memberof CommonResult.SearchVo
         * @instance
         */
        SearchVo.prototype.unionType = 0;

        /**
         * Decodes a SearchVo message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.SearchVo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.SearchVo} SearchVo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchVo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.SearchVo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.logoTime = reader.int32();
                    break;
                case 5:
                    message.gameId = reader.string();
                    break;
                case 6:
                    message.unionId = reader.string();
                    break;
                case 7:
                    message.password = reader.bool();
                    break;
                case 8:
                    message.onlineNum = reader.int32();
                    break;
                case 9:
                    message.jobId = reader.int32();
                    break;
                case 10:
                    message.unionType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("logoTime"))
                throw $util.ProtocolError("missing required 'logoTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a SearchVo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.SearchVo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.SearchVo} SearchVo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchVo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SearchVo;
    })();

    CommonResult.CommonBroadcast = (function() {

        /**
         * Properties of a CommonBroadcast.
         * @memberof CommonResult
         * @interface ICommonBroadcast
         * @property {number} type CommonBroadcast type
         * @property {Array.<string>|null} [params] CommonBroadcast params
         */

        /**
         * Constructs a new CommonBroadcast.
         * @memberof CommonResult
         * @classdesc Represents a CommonBroadcast.
         * @implements ICommonBroadcast
         * @constructor
         * @param {CommonResult.ICommonBroadcast=} [properties] Properties to set
         */
        function CommonBroadcast(properties) {
            this.params = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonBroadcast type.
         * @member {number} type
         * @memberof CommonResult.CommonBroadcast
         * @instance
         */
        CommonBroadcast.prototype.type = 0;

        /**
         * CommonBroadcast params.
         * @member {Array.<string>} params
         * @memberof CommonResult.CommonBroadcast
         * @instance
         */
        CommonBroadcast.prototype.params = $util.emptyArray;

        /**
         * Decodes a CommonBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.CommonBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.CommonBroadcast} CommonBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.CommonBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a CommonBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.CommonBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.CommonBroadcast} CommonBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return CommonBroadcast;
    })();

    CommonResult.UploadLogBroadcast = (function() {

        /**
         * Properties of an UploadLogBroadcast.
         * @memberof CommonResult
         * @interface IUploadLogBroadcast
         * @property {number} type UploadLogBroadcast type
         * @property {Array.<string>|null} [params] UploadLogBroadcast params
         */

        /**
         * Constructs a new UploadLogBroadcast.
         * @memberof CommonResult
         * @classdesc Represents an UploadLogBroadcast.
         * @implements IUploadLogBroadcast
         * @constructor
         * @param {CommonResult.IUploadLogBroadcast=} [properties] Properties to set
         */
        function UploadLogBroadcast(properties) {
            this.params = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UploadLogBroadcast type.
         * @member {number} type
         * @memberof CommonResult.UploadLogBroadcast
         * @instance
         */
        UploadLogBroadcast.prototype.type = 0;

        /**
         * UploadLogBroadcast params.
         * @member {Array.<string>} params
         * @memberof CommonResult.UploadLogBroadcast
         * @instance
         */
        UploadLogBroadcast.prototype.params = $util.emptyArray;

        /**
         * Decodes an UploadLogBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.UploadLogBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.UploadLogBroadcast} UploadLogBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadLogBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.UploadLogBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes an UploadLogBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.UploadLogBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.UploadLogBroadcast} UploadLogBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadLogBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UploadLogBroadcast;
    })();

    CommonResult.KeyValuesResult = (function() {

        /**
         * Properties of a KeyValuesResult.
         * @memberof CommonResult
         * @interface IKeyValuesResult
         * @property {Array.<string>|null} [keys] KeyValuesResult keys
         * @property {Array.<string>|null} [values] KeyValuesResult values
         */

        /**
         * Constructs a new KeyValuesResult.
         * @memberof CommonResult
         * @classdesc Represents a KeyValuesResult.
         * @implements IKeyValuesResult
         * @constructor
         * @param {CommonResult.IKeyValuesResult=} [properties] Properties to set
         */
        function KeyValuesResult(properties) {
            this.keys = [];
            this.values = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyValuesResult keys.
         * @member {Array.<string>} keys
         * @memberof CommonResult.KeyValuesResult
         * @instance
         */
        KeyValuesResult.prototype.keys = $util.emptyArray;

        /**
         * KeyValuesResult values.
         * @member {Array.<string>} values
         * @memberof CommonResult.KeyValuesResult
         * @instance
         */
        KeyValuesResult.prototype.values = $util.emptyArray;

        /**
         * Decodes a KeyValuesResult message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.KeyValuesResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.KeyValuesResult} KeyValuesResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValuesResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.KeyValuesResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push(reader.string());
                    break;
                case 2:
                    if (!(message.values && message.values.length))
                        message.values = [];
                    message.values.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyValuesResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.KeyValuesResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.KeyValuesResult} KeyValuesResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValuesResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return KeyValuesResult;
    })();

    CommonResult.SearchRoomList = (function() {

        /**
         * Properties of a SearchRoomList.
         * @memberof CommonResult
         * @interface ISearchRoomList
         * @property {Array.<CommonResult.ISearchRoomVo>|null} [vos] SearchRoomList vos
         */

        /**
         * Constructs a new SearchRoomList.
         * @memberof CommonResult
         * @classdesc Represents a SearchRoomList.
         * @implements ISearchRoomList
         * @constructor
         * @param {CommonResult.ISearchRoomList=} [properties] Properties to set
         */
        function SearchRoomList(properties) {
            this.vos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchRoomList vos.
         * @member {Array.<CommonResult.ISearchRoomVo>} vos
         * @memberof CommonResult.SearchRoomList
         * @instance
         */
        SearchRoomList.prototype.vos = $util.emptyArray;

        /**
         * Decodes a SearchRoomList message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.SearchRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.SearchRoomList} SearchRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchRoomList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.SearchRoomList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.vos && message.vos.length))
                        message.vos = [];
                    message.vos.push($root.CommonResult.SearchRoomVo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchRoomList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.SearchRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.SearchRoomList} SearchRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchRoomList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SearchRoomList;
    })();

    CommonResult.SearchRoomVo = (function() {

        /**
         * Properties of a SearchRoomVo.
         * @memberof CommonResult
         * @interface ISearchRoomVo
         * @property {string} roomId SearchRoomVo roomId
         * @property {string} roomName SearchRoomVo roomName
         * @property {string|null} [createId] SearchRoomVo createId
         * @property {number|null} [onlineNum] SearchRoomVo onlineNum
         * @property {string|null} [nickName] SearchRoomVo nickName
         * @property {number|null} [logoTime] SearchRoomVo logoTime
         * @property {number|null} [sex] SearchRoomVo sex
         * @property {number|null} [age] SearchRoomVo age
         * @property {number|null} [vipLv] SearchRoomVo vipLv
         * @property {string|null} [gameId] SearchRoomVo gameId
         * @property {string|null} [os] SearchRoomVo os
         * @property {string|null} [zone] SearchRoomVo zone
         * @property {number} type SearchRoomVo type
         */

        /**
         * Constructs a new SearchRoomVo.
         * @memberof CommonResult
         * @classdesc Represents a SearchRoomVo.
         * @implements ISearchRoomVo
         * @constructor
         * @param {CommonResult.ISearchRoomVo=} [properties] Properties to set
         */
        function SearchRoomVo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchRoomVo roomId.
         * @member {string} roomId
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.roomId = "";

        /**
         * SearchRoomVo roomName.
         * @member {string} roomName
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.roomName = "";

        /**
         * SearchRoomVo createId.
         * @member {string} createId
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.createId = "";

        /**
         * SearchRoomVo onlineNum.
         * @member {number} onlineNum
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.onlineNum = 0;

        /**
         * SearchRoomVo nickName.
         * @member {string} nickName
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.nickName = "";

        /**
         * SearchRoomVo logoTime.
         * @member {number} logoTime
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.logoTime = 0;

        /**
         * SearchRoomVo sex.
         * @member {number} sex
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.sex = 0;

        /**
         * SearchRoomVo age.
         * @member {number} age
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.age = 0;

        /**
         * SearchRoomVo vipLv.
         * @member {number} vipLv
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.vipLv = 0;

        /**
         * SearchRoomVo gameId.
         * @member {string} gameId
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.gameId = "";

        /**
         * SearchRoomVo os.
         * @member {string} os
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.os = "";

        /**
         * SearchRoomVo zone.
         * @member {string} zone
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.zone = "";

        /**
         * SearchRoomVo type.
         * @member {number} type
         * @memberof CommonResult.SearchRoomVo
         * @instance
         */
        SearchRoomVo.prototype.type = 0;

        /**
         * Decodes a SearchRoomVo message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.SearchRoomVo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.SearchRoomVo} SearchRoomVo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchRoomVo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.SearchRoomVo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.roomName = reader.string();
                    break;
                case 3:
                    message.createId = reader.string();
                    break;
                case 4:
                    message.onlineNum = reader.int32();
                    break;
                case 5:
                    message.nickName = reader.string();
                    break;
                case 6:
                    message.logoTime = reader.int32();
                    break;
                case 7:
                    message.sex = reader.int32();
                    break;
                case 8:
                    message.age = reader.int32();
                    break;
                case 9:
                    message.vipLv = reader.int32();
                    break;
                case 10:
                    message.gameId = reader.string();
                    break;
                case 11:
                    message.os = reader.string();
                    break;
                case 12:
                    message.zone = reader.string();
                    break;
                case 13:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("roomId"))
                throw $util.ProtocolError("missing required 'roomId'", { instance: message });
            if (!message.hasOwnProperty("roomName"))
                throw $util.ProtocolError("missing required 'roomName'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a SearchRoomVo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.SearchRoomVo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.SearchRoomVo} SearchRoomVo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchRoomVo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SearchRoomVo;
    })();

    CommonResult.KeyValueResult = (function() {

        /**
         * Properties of a KeyValueResult.
         * @memberof CommonResult
         * @interface IKeyValueResult
         * @property {string} key KeyValueResult key
         * @property {string} value KeyValueResult value
         */

        /**
         * Constructs a new KeyValueResult.
         * @memberof CommonResult
         * @classdesc Represents a KeyValueResult.
         * @implements IKeyValueResult
         * @constructor
         * @param {CommonResult.IKeyValueResult=} [properties] Properties to set
         */
        function KeyValueResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyValueResult key.
         * @member {string} key
         * @memberof CommonResult.KeyValueResult
         * @instance
         */
        KeyValueResult.prototype.key = "";

        /**
         * KeyValueResult value.
         * @member {string} value
         * @memberof CommonResult.KeyValueResult
         * @instance
         */
        KeyValueResult.prototype.value = "";

        /**
         * Decodes a KeyValueResult message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.KeyValueResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.KeyValueResult} KeyValueResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValueResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.KeyValueResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes a KeyValueResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.KeyValueResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.KeyValueResult} KeyValueResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValueResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return KeyValueResult;
    })();

    CommonResult.KeyValueData = (function() {

        /**
         * Properties of a KeyValueData.
         * @memberof CommonResult
         * @interface IKeyValueData
         * @property {Array.<CommonResult.IKeyValueResult>|null} [data] KeyValueData data
         */

        /**
         * Constructs a new KeyValueData.
         * @memberof CommonResult
         * @classdesc Represents a KeyValueData.
         * @implements IKeyValueData
         * @constructor
         * @param {CommonResult.IKeyValueData=} [properties] Properties to set
         */
        function KeyValueData(properties) {
            this.data = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyValueData data.
         * @member {Array.<CommonResult.IKeyValueResult>} data
         * @memberof CommonResult.KeyValueData
         * @instance
         */
        KeyValueData.prototype.data = $util.emptyArray;

        /**
         * Decodes a KeyValueData message from the specified reader or buffer.
         * @function decode
         * @memberof CommonResult.KeyValueData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CommonResult.KeyValueData} KeyValueData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValueData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommonResult.KeyValueData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.data && message.data.length))
                        message.data = [];
                    message.data.push($root.CommonResult.KeyValueResult.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyValueData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CommonResult.KeyValueData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CommonResult.KeyValueData} KeyValueData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValueData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return KeyValueData;
    })();

    return CommonResult;
})();

export const ErrorResult = $root.ErrorResult = (() => {

    /**
     * Namespace ErrorResult.
     * @exports ErrorResult
     * @namespace
     */
    const ErrorResult = {};

    ErrorResult.Info = (function() {

        /**
         * Properties of an Info.
         * @memberof ErrorResult
         * @interface IInfo
         * @property {string} errorCode Info errorCode
         * @property {string} description Info description
         */

        /**
         * Constructs a new Info.
         * @memberof ErrorResult
         * @classdesc Represents an Info.
         * @implements IInfo
         * @constructor
         * @param {ErrorResult.IInfo=} [properties] Properties to set
         */
        function Info(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Info errorCode.
         * @member {string} errorCode
         * @memberof ErrorResult.Info
         * @instance
         */
        Info.prototype.errorCode = "";

        /**
         * Info description.
         * @member {string} description
         * @memberof ErrorResult.Info
         * @instance
         */
        Info.prototype.description = "";

        /**
         * Decodes an Info message from the specified reader or buffer.
         * @function decode
         * @memberof ErrorResult.Info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ErrorResult.Info} Info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Info.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ErrorResult.Info();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errorCode = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("errorCode"))
                throw $util.ProtocolError("missing required 'errorCode'", { instance: message });
            if (!message.hasOwnProperty("description"))
                throw $util.ProtocolError("missing required 'description'", { instance: message });
            return message;
        };

        /**
         * Decodes an Info message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ErrorResult.Info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ErrorResult.Info} Info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Info.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Info;
    })();

    return ErrorResult;
})();

export const FishResult = $root.FishResult = (() => {

    /**
     * Namespace FishResult.
     * @exports FishResult
     * @namespace
     */
    const FishResult = {};

    FishResult.FishData = (function() {

        /**
         * Properties of a FishData.
         * @memberof FishResult
         * @interface IFishData
         * @property {number} step FishData step
         * @property {number|null} [stepRemain] FishData stepRemain
         * @property {number|null} [balance] FishData balance
         * @property {Array.<number>|null} [betResults] FishData betResults
         * @property {FishResult.IAllBetData|null} [allBetData] FishData allBetData
         * @property {FishResult.IRoundData|null} [roundData] FishData roundData
         * @property {UserResult.IUserBase|null} [user] FishData user
         */

        /**
         * Constructs a new FishData.
         * @memberof FishResult
         * @classdesc Represents a FishData.
         * @implements IFishData
         * @constructor
         * @param {FishResult.IFishData=} [properties] Properties to set
         */
        function FishData(properties) {
            this.betResults = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FishData step.
         * @member {number} step
         * @memberof FishResult.FishData
         * @instance
         */
        FishData.prototype.step = 0;

        /**
         * FishData stepRemain.
         * @member {number} stepRemain
         * @memberof FishResult.FishData
         * @instance
         */
        FishData.prototype.stepRemain = 0;

        /**
         * FishData balance.
         * @member {number} balance
         * @memberof FishResult.FishData
         * @instance
         */
        FishData.prototype.balance = 0;

        /**
         * FishData betResults.
         * @member {Array.<number>} betResults
         * @memberof FishResult.FishData
         * @instance
         */
        FishData.prototype.betResults = $util.emptyArray;

        /**
         * FishData allBetData.
         * @member {FishResult.IAllBetData|null|undefined} allBetData
         * @memberof FishResult.FishData
         * @instance
         */
        FishData.prototype.allBetData = null;

        /**
         * FishData roundData.
         * @member {FishResult.IRoundData|null|undefined} roundData
         * @memberof FishResult.FishData
         * @instance
         */
        FishData.prototype.roundData = null;

        /**
         * FishData user.
         * @member {UserResult.IUserBase|null|undefined} user
         * @memberof FishResult.FishData
         * @instance
         */
        FishData.prototype.user = null;

        /**
         * Decodes a FishData message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.FishData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.FishData} FishData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FishData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.FishData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.step = reader.int32();
                    break;
                case 2:
                    message.stepRemain = reader.int32();
                    break;
                case 3:
                    message.balance = reader.int32();
                    break;
                case 4:
                    if (!(message.betResults && message.betResults.length))
                        message.betResults = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.betResults.push(reader.int32());
                    } else
                        message.betResults.push(reader.int32());
                    break;
                case 5:
                    message.allBetData = $root.FishResult.AllBetData.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.roundData = $root.FishResult.RoundData.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.user = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("step"))
                throw $util.ProtocolError("missing required 'step'", { instance: message });
            return message;
        };

        /**
         * Decodes a FishData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.FishData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.FishData} FishData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FishData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FishData;
    })();

    FishResult.RoundData = (function() {

        /**
         * Properties of a RoundData.
         * @memberof FishResult
         * @interface IRoundData
         * @property {number} blueNum RoundData blueNum
         * @property {number} redNum RoundData redNum
         * @property {Array.<number>|null} [blueDatas] RoundData blueDatas
         * @property {Array.<number>|null} [redDatas] RoundData redDatas
         * @property {number} stepTime RoundData stepTime
         */

        /**
         * Constructs a new RoundData.
         * @memberof FishResult
         * @classdesc Represents a RoundData.
         * @implements IRoundData
         * @constructor
         * @param {FishResult.IRoundData=} [properties] Properties to set
         */
        function RoundData(properties) {
            this.blueDatas = [];
            this.redDatas = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoundData blueNum.
         * @member {number} blueNum
         * @memberof FishResult.RoundData
         * @instance
         */
        RoundData.prototype.blueNum = 0;

        /**
         * RoundData redNum.
         * @member {number} redNum
         * @memberof FishResult.RoundData
         * @instance
         */
        RoundData.prototype.redNum = 0;

        /**
         * RoundData blueDatas.
         * @member {Array.<number>} blueDatas
         * @memberof FishResult.RoundData
         * @instance
         */
        RoundData.prototype.blueDatas = $util.emptyArray;

        /**
         * RoundData redDatas.
         * @member {Array.<number>} redDatas
         * @memberof FishResult.RoundData
         * @instance
         */
        RoundData.prototype.redDatas = $util.emptyArray;

        /**
         * RoundData stepTime.
         * @member {number} stepTime
         * @memberof FishResult.RoundData
         * @instance
         */
        RoundData.prototype.stepTime = 0;

        /**
         * Decodes a RoundData message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.RoundData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.RoundData} RoundData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoundData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.RoundData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blueNum = reader.int32();
                    break;
                case 2:
                    message.redNum = reader.int32();
                    break;
                case 3:
                    if (!(message.blueDatas && message.blueDatas.length))
                        message.blueDatas = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.blueDatas.push(reader.double());
                    } else
                        message.blueDatas.push(reader.double());
                    break;
                case 4:
                    if (!(message.redDatas && message.redDatas.length))
                        message.redDatas = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.redDatas.push(reader.double());
                    } else
                        message.redDatas.push(reader.double());
                    break;
                case 5:
                    message.stepTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("blueNum"))
                throw $util.ProtocolError("missing required 'blueNum'", { instance: message });
            if (!message.hasOwnProperty("redNum"))
                throw $util.ProtocolError("missing required 'redNum'", { instance: message });
            if (!message.hasOwnProperty("stepTime"))
                throw $util.ProtocolError("missing required 'stepTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a RoundData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.RoundData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.RoundData} RoundData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoundData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RoundData;
    })();

    FishResult.AllBetData = (function() {

        /**
         * Properties of an AllBetData.
         * @memberof FishResult
         * @interface IAllBetData
         * @property {Array.<FishResult.IBetData>|null} [betDatas] AllBetData betDatas
         * @property {FishResult.IMyBetData} myBetData AllBetData myBetData
         */

        /**
         * Constructs a new AllBetData.
         * @memberof FishResult
         * @classdesc Represents an AllBetData.
         * @implements IAllBetData
         * @constructor
         * @param {FishResult.IAllBetData=} [properties] Properties to set
         */
        function AllBetData(properties) {
            this.betDatas = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AllBetData betDatas.
         * @member {Array.<FishResult.IBetData>} betDatas
         * @memberof FishResult.AllBetData
         * @instance
         */
        AllBetData.prototype.betDatas = $util.emptyArray;

        /**
         * AllBetData myBetData.
         * @member {FishResult.IMyBetData} myBetData
         * @memberof FishResult.AllBetData
         * @instance
         */
        AllBetData.prototype.myBetData = null;

        /**
         * Decodes an AllBetData message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.AllBetData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.AllBetData} AllBetData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllBetData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.AllBetData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.betDatas && message.betDatas.length))
                        message.betDatas = [];
                    message.betDatas.push($root.FishResult.BetData.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.myBetData = $root.FishResult.MyBetData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("myBetData"))
                throw $util.ProtocolError("missing required 'myBetData'", { instance: message });
            return message;
        };

        /**
         * Decodes an AllBetData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.AllBetData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.AllBetData} AllBetData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllBetData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return AllBetData;
    })();

    FishResult.MyBetData = (function() {

        /**
         * Properties of a MyBetData.
         * @memberof FishResult
         * @interface IMyBetData
         * @property {Array.<FishResult.IBetData>|null} [betDatas] MyBetData betDatas
         */

        /**
         * Constructs a new MyBetData.
         * @memberof FishResult
         * @classdesc Represents a MyBetData.
         * @implements IMyBetData
         * @constructor
         * @param {FishResult.IMyBetData=} [properties] Properties to set
         */
        function MyBetData(properties) {
            this.betDatas = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MyBetData betDatas.
         * @member {Array.<FishResult.IBetData>} betDatas
         * @memberof FishResult.MyBetData
         * @instance
         */
        MyBetData.prototype.betDatas = $util.emptyArray;

        /**
         * Decodes a MyBetData message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.MyBetData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.MyBetData} MyBetData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyBetData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.MyBetData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.betDatas && message.betDatas.length))
                        message.betDatas = [];
                    message.betDatas.push($root.FishResult.BetData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MyBetData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.MyBetData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.MyBetData} MyBetData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyBetData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MyBetData;
    })();

    FishResult.BetData = (function() {

        /**
         * Properties of a BetData.
         * @memberof FishResult
         * @interface IBetData
         * @property {number} total BetData total
         * @property {Array.<number>|null} [betCounts] BetData betCounts
         */

        /**
         * Constructs a new BetData.
         * @memberof FishResult
         * @classdesc Represents a BetData.
         * @implements IBetData
         * @constructor
         * @param {FishResult.IBetData=} [properties] Properties to set
         */
        function BetData(properties) {
            this.betCounts = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BetData total.
         * @member {number} total
         * @memberof FishResult.BetData
         * @instance
         */
        BetData.prototype.total = 0;

        /**
         * BetData betCounts.
         * @member {Array.<number>} betCounts
         * @memberof FishResult.BetData
         * @instance
         */
        BetData.prototype.betCounts = $util.emptyArray;

        /**
         * Decodes a BetData message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.BetData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.BetData} BetData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BetData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.BetData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.total = reader.int32();
                    break;
                case 2:
                    if (!(message.betCounts && message.betCounts.length))
                        message.betCounts = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.betCounts.push(reader.int32());
                    } else
                        message.betCounts.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("total"))
                throw $util.ProtocolError("missing required 'total'", { instance: message });
            return message;
        };

        /**
         * Decodes a BetData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.BetData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.BetData} BetData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BetData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return BetData;
    })();

    FishResult.UserBetDetail = (function() {

        /**
         * Properties of a UserBetDetail.
         * @memberof FishResult
         * @interface IUserBetDetail
         * @property {Array.<FishResult.IUserBetData>|null} [betDatas] UserBetDetail betDatas
         */

        /**
         * Constructs a new UserBetDetail.
         * @memberof FishResult
         * @classdesc Represents a UserBetDetail.
         * @implements IUserBetDetail
         * @constructor
         * @param {FishResult.IUserBetDetail=} [properties] Properties to set
         */
        function UserBetDetail(properties) {
            this.betDatas = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserBetDetail betDatas.
         * @member {Array.<FishResult.IUserBetData>} betDatas
         * @memberof FishResult.UserBetDetail
         * @instance
         */
        UserBetDetail.prototype.betDatas = $util.emptyArray;

        /**
         * Decodes a UserBetDetail message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.UserBetDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.UserBetDetail} UserBetDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBetDetail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.UserBetDetail();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.betDatas && message.betDatas.length))
                        message.betDatas = [];
                    message.betDatas.push($root.FishResult.UserBetData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserBetDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.UserBetDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.UserBetDetail} UserBetDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBetDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserBetDetail;
    })();

    FishResult.UserBetData = (function() {

        /**
         * Properties of a UserBetData.
         * @memberof FishResult
         * @interface IUserBetData
         * @property {Array.<UserResult.IUserBase>|null} [users] UserBetData users
         * @property {Array.<number>|null} [betTotal] UserBetData betTotal
         */

        /**
         * Constructs a new UserBetData.
         * @memberof FishResult
         * @classdesc Represents a UserBetData.
         * @implements IUserBetData
         * @constructor
         * @param {FishResult.IUserBetData=} [properties] Properties to set
         */
        function UserBetData(properties) {
            this.users = [];
            this.betTotal = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserBetData users.
         * @member {Array.<UserResult.IUserBase>} users
         * @memberof FishResult.UserBetData
         * @instance
         */
        UserBetData.prototype.users = $util.emptyArray;

        /**
         * UserBetData betTotal.
         * @member {Array.<number>} betTotal
         * @memberof FishResult.UserBetData
         * @instance
         */
        UserBetData.prototype.betTotal = $util.emptyArray;

        /**
         * Decodes a UserBetData message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.UserBetData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.UserBetData} UserBetData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBetData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.UserBetData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.users && message.users.length))
                        message.users = [];
                    message.users.push($root.UserResult.UserBase.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.betTotal && message.betTotal.length))
                        message.betTotal = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.betTotal.push(reader.int32());
                    } else
                        message.betTotal.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserBetData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.UserBetData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.UserBetData} UserBetData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBetData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserBetData;
    })();

    FishResult.MyBetLog = (function() {

        /**
         * Properties of a MyBetLog.
         * @memberof FishResult
         * @interface IMyBetLog
         * @property {Array.<FishResult.IBetLog>|null} [logs] MyBetLog logs
         */

        /**
         * Constructs a new MyBetLog.
         * @memberof FishResult
         * @classdesc Represents a MyBetLog.
         * @implements IMyBetLog
         * @constructor
         * @param {FishResult.IMyBetLog=} [properties] Properties to set
         */
        function MyBetLog(properties) {
            this.logs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MyBetLog logs.
         * @member {Array.<FishResult.IBetLog>} logs
         * @memberof FishResult.MyBetLog
         * @instance
         */
        MyBetLog.prototype.logs = $util.emptyArray;

        /**
         * Decodes a MyBetLog message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.MyBetLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.MyBetLog} MyBetLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyBetLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.MyBetLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logs && message.logs.length))
                        message.logs = [];
                    message.logs.push($root.FishResult.BetLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MyBetLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.MyBetLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.MyBetLog} MyBetLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyBetLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MyBetLog;
    })();

    FishResult.BetLog = (function() {

        /**
         * Properties of a BetLog.
         * @memberof FishResult
         * @interface IBetLog
         * @property {number} betIndex BetLog betIndex
         * @property {number} result BetLog result
         * @property {number} betTotal BetLog betTotal
         * @property {number|Long} logTime BetLog logTime
         */

        /**
         * Constructs a new BetLog.
         * @memberof FishResult
         * @classdesc Represents a BetLog.
         * @implements IBetLog
         * @constructor
         * @param {FishResult.IBetLog=} [properties] Properties to set
         */
        function BetLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BetLog betIndex.
         * @member {number} betIndex
         * @memberof FishResult.BetLog
         * @instance
         */
        BetLog.prototype.betIndex = 0;

        /**
         * BetLog result.
         * @member {number} result
         * @memberof FishResult.BetLog
         * @instance
         */
        BetLog.prototype.result = 0;

        /**
         * BetLog betTotal.
         * @member {number} betTotal
         * @memberof FishResult.BetLog
         * @instance
         */
        BetLog.prototype.betTotal = 0;

        /**
         * BetLog logTime.
         * @member {number|Long} logTime
         * @memberof FishResult.BetLog
         * @instance
         */
        BetLog.prototype.logTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a BetLog message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.BetLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.BetLog} BetLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BetLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.BetLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.betIndex = reader.int32();
                    break;
                case 2:
                    message.result = reader.int32();
                    break;
                case 3:
                    message.betTotal = reader.int32();
                    break;
                case 4:
                    message.logTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("betIndex"))
                throw $util.ProtocolError("missing required 'betIndex'", { instance: message });
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            if (!message.hasOwnProperty("betTotal"))
                throw $util.ProtocolError("missing required 'betTotal'", { instance: message });
            if (!message.hasOwnProperty("logTime"))
                throw $util.ProtocolError("missing required 'logTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a BetLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.BetLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.BetLog} BetLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BetLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return BetLog;
    })();

    FishResult.SyncSendGift = (function() {

        /**
         * Properties of a SyncSendGift.
         * @memberof FishResult
         * @interface ISyncSendGift
         * @property {UserResult.IUserBase} sendUser SyncSendGift sendUser
         * @property {number} hitNum SyncSendGift hitNum
         */

        /**
         * Constructs a new SyncSendGift.
         * @memberof FishResult
         * @classdesc Represents a SyncSendGift.
         * @implements ISyncSendGift
         * @constructor
         * @param {FishResult.ISyncSendGift=} [properties] Properties to set
         */
        function SyncSendGift(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncSendGift sendUser.
         * @member {UserResult.IUserBase} sendUser
         * @memberof FishResult.SyncSendGift
         * @instance
         */
        SyncSendGift.prototype.sendUser = null;

        /**
         * SyncSendGift hitNum.
         * @member {number} hitNum
         * @memberof FishResult.SyncSendGift
         * @instance
         */
        SyncSendGift.prototype.hitNum = 0;

        /**
         * Decodes a SyncSendGift message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.SyncSendGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.SyncSendGift} SyncSendGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncSendGift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.SyncSendGift();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sendUser = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.hitNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("sendUser"))
                throw $util.ProtocolError("missing required 'sendUser'", { instance: message });
            if (!message.hasOwnProperty("hitNum"))
                throw $util.ProtocolError("missing required 'hitNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a SyncSendGift message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.SyncSendGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.SyncSendGift} SyncSendGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncSendGift.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SyncSendGift;
    })();

    FishResult.SyncFishData = (function() {

        /**
         * Properties of a SyncFishData.
         * @memberof FishResult
         * @interface ISyncFishData
         * @property {number} step SyncFishData step
         * @property {number} stepRemain SyncFishData stepRemain
         * @property {FishResult.IRoundData|null} [roundData] SyncFishData roundData
         */

        /**
         * Constructs a new SyncFishData.
         * @memberof FishResult
         * @classdesc Represents a SyncFishData.
         * @implements ISyncFishData
         * @constructor
         * @param {FishResult.ISyncFishData=} [properties] Properties to set
         */
        function SyncFishData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncFishData step.
         * @member {number} step
         * @memberof FishResult.SyncFishData
         * @instance
         */
        SyncFishData.prototype.step = 0;

        /**
         * SyncFishData stepRemain.
         * @member {number} stepRemain
         * @memberof FishResult.SyncFishData
         * @instance
         */
        SyncFishData.prototype.stepRemain = 0;

        /**
         * SyncFishData roundData.
         * @member {FishResult.IRoundData|null|undefined} roundData
         * @memberof FishResult.SyncFishData
         * @instance
         */
        SyncFishData.prototype.roundData = null;

        /**
         * Decodes a SyncFishData message from the specified reader or buffer.
         * @function decode
         * @memberof FishResult.SyncFishData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FishResult.SyncFishData} SyncFishData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncFishData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishResult.SyncFishData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.step = reader.int32();
                    break;
                case 2:
                    message.stepRemain = reader.int32();
                    break;
                case 3:
                    message.roundData = $root.FishResult.RoundData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("step"))
                throw $util.ProtocolError("missing required 'step'", { instance: message });
            if (!message.hasOwnProperty("stepRemain"))
                throw $util.ProtocolError("missing required 'stepRemain'", { instance: message });
            return message;
        };

        /**
         * Decodes a SyncFishData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FishResult.SyncFishData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FishResult.SyncFishData} SyncFishData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncFishData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SyncFishData;
    })();

    return FishResult;
})();

export const GroupResult = $root.GroupResult = (() => {

    /**
     * Namespace GroupResult.
     * @exports GroupResult
     * @namespace
     */
    const GroupResult = {};

    GroupResult.GroupMembers = (function() {

        /**
         * Properties of a GroupMembers.
         * @memberof GroupResult
         * @interface IGroupMembers
         * @property {Array.<GroupResult.IGroupMember>|null} [members] GroupMembers members
         */

        /**
         * Constructs a new GroupMembers.
         * @memberof GroupResult
         * @classdesc Represents a GroupMembers.
         * @implements IGroupMembers
         * @constructor
         * @param {GroupResult.IGroupMembers=} [properties] Properties to set
         */
        function GroupMembers(properties) {
            this.members = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMembers members.
         * @member {Array.<GroupResult.IGroupMember>} members
         * @memberof GroupResult.GroupMembers
         * @instance
         */
        GroupMembers.prototype.members = $util.emptyArray;

        /**
         * Decodes a GroupMembers message from the specified reader or buffer.
         * @function decode
         * @memberof GroupResult.GroupMembers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GroupResult.GroupMembers} GroupMembers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMembers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupResult.GroupMembers();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.GroupResult.GroupMember.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupMembers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GroupResult.GroupMembers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GroupResult.GroupMembers} GroupMembers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMembers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return GroupMembers;
    })();

    GroupResult.GroupMember = (function() {

        /**
         * Properties of a GroupMember.
         * @memberof GroupResult
         * @interface IGroupMember
         * @property {UserResult.IUserBase} info GroupMember info
         * @property {number|Long} enterTime GroupMember enterTime
         * @property {number} jobId GroupMember jobId
         * @property {number|null} [roomStatus] GroupMember roomStatus
         * @property {string|null} [roomId] GroupMember roomId
         * @property {number|null} [roomType] GroupMember roomType
         */

        /**
         * Constructs a new GroupMember.
         * @memberof GroupResult
         * @classdesc Represents a GroupMember.
         * @implements IGroupMember
         * @constructor
         * @param {GroupResult.IGroupMember=} [properties] Properties to set
         */
        function GroupMember(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMember info.
         * @member {UserResult.IUserBase} info
         * @memberof GroupResult.GroupMember
         * @instance
         */
        GroupMember.prototype.info = null;

        /**
         * GroupMember enterTime.
         * @member {number|Long} enterTime
         * @memberof GroupResult.GroupMember
         * @instance
         */
        GroupMember.prototype.enterTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupMember jobId.
         * @member {number} jobId
         * @memberof GroupResult.GroupMember
         * @instance
         */
        GroupMember.prototype.jobId = 0;

        /**
         * GroupMember roomStatus.
         * @member {number} roomStatus
         * @memberof GroupResult.GroupMember
         * @instance
         */
        GroupMember.prototype.roomStatus = 0;

        /**
         * GroupMember roomId.
         * @member {string} roomId
         * @memberof GroupResult.GroupMember
         * @instance
         */
        GroupMember.prototype.roomId = "";

        /**
         * GroupMember roomType.
         * @member {number} roomType
         * @memberof GroupResult.GroupMember
         * @instance
         */
        GroupMember.prototype.roomType = 0;

        /**
         * Decodes a GroupMember message from the specified reader or buffer.
         * @function decode
         * @memberof GroupResult.GroupMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GroupResult.GroupMember} GroupMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupResult.GroupMember();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.info = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.enterTime = reader.int64();
                    break;
                case 3:
                    message.jobId = reader.int32();
                    break;
                case 4:
                    message.roomStatus = reader.int32();
                    break;
                case 5:
                    message.roomId = reader.string();
                    break;
                case 6:
                    message.roomType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("info"))
                throw $util.ProtocolError("missing required 'info'", { instance: message });
            if (!message.hasOwnProperty("enterTime"))
                throw $util.ProtocolError("missing required 'enterTime'", { instance: message });
            if (!message.hasOwnProperty("jobId"))
                throw $util.ProtocolError("missing required 'jobId'", { instance: message });
            return message;
        };

        /**
         * Decodes a GroupMember message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GroupResult.GroupMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GroupResult.GroupMember} GroupMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMember.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return GroupMember;
    })();

    GroupResult.Group = (function() {

        /**
         * Properties of a Group.
         * @memberof GroupResult
         * @interface IGroup
         * @property {string} groupId Group groupId
         * @property {string} owner Group owner
         * @property {string|null} [groupName] Group groupName
         * @property {string|null} [notice] Group notice
         * @property {number} memberCount Group memberCount
         * @property {boolean|null} [noticeRedPoint] Group noticeRedPoint
         * @property {number|null} [jobId] Group jobId
         * @property {number|Long} logoTime Group logoTime
         */

        /**
         * Constructs a new Group.
         * @memberof GroupResult
         * @classdesc Represents a Group.
         * @implements IGroup
         * @constructor
         * @param {GroupResult.IGroup=} [properties] Properties to set
         */
        function Group(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Group groupId.
         * @member {string} groupId
         * @memberof GroupResult.Group
         * @instance
         */
        Group.prototype.groupId = "";

        /**
         * Group owner.
         * @member {string} owner
         * @memberof GroupResult.Group
         * @instance
         */
        Group.prototype.owner = "";

        /**
         * Group groupName.
         * @member {string} groupName
         * @memberof GroupResult.Group
         * @instance
         */
        Group.prototype.groupName = "";

        /**
         * Group notice.
         * @member {string} notice
         * @memberof GroupResult.Group
         * @instance
         */
        Group.prototype.notice = "";

        /**
         * Group memberCount.
         * @member {number} memberCount
         * @memberof GroupResult.Group
         * @instance
         */
        Group.prototype.memberCount = 0;

        /**
         * Group noticeRedPoint.
         * @member {boolean} noticeRedPoint
         * @memberof GroupResult.Group
         * @instance
         */
        Group.prototype.noticeRedPoint = false;

        /**
         * Group jobId.
         * @member {number} jobId
         * @memberof GroupResult.Group
         * @instance
         */
        Group.prototype.jobId = 0;

        /**
         * Group logoTime.
         * @member {number|Long} logoTime
         * @memberof GroupResult.Group
         * @instance
         */
        Group.prototype.logoTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a Group message from the specified reader or buffer.
         * @function decode
         * @memberof GroupResult.Group
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GroupResult.Group} Group
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Group.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupResult.Group();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.string();
                    break;
                case 2:
                    message.owner = reader.string();
                    break;
                case 3:
                    message.groupName = reader.string();
                    break;
                case 4:
                    message.notice = reader.string();
                    break;
                case 5:
                    message.memberCount = reader.int32();
                    break;
                case 6:
                    message.noticeRedPoint = reader.bool();
                    break;
                case 7:
                    message.jobId = reader.int32();
                    break;
                case 8:
                    message.logoTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupId"))
                throw $util.ProtocolError("missing required 'groupId'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("memberCount"))
                throw $util.ProtocolError("missing required 'memberCount'", { instance: message });
            if (!message.hasOwnProperty("logoTime"))
                throw $util.ProtocolError("missing required 'logoTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a Group message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GroupResult.Group
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GroupResult.Group} Group
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Group.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Group;
    })();

    GroupResult.ModifyGroupBroadcast = (function() {

        /**
         * Properties of a ModifyGroupBroadcast.
         * @memberof GroupResult
         * @interface IModifyGroupBroadcast
         * @property {string} groupId ModifyGroupBroadcast groupId
         * @property {UserResult.IUserBase} user ModifyGroupBroadcast user
         * @property {number} type ModifyGroupBroadcast type
         * @property {string|null} [info] ModifyGroupBroadcast info
         * @property {UserResult.IUserBase|null} [target] ModifyGroupBroadcast target
         */

        /**
         * Constructs a new ModifyGroupBroadcast.
         * @memberof GroupResult
         * @classdesc Represents a ModifyGroupBroadcast.
         * @implements IModifyGroupBroadcast
         * @constructor
         * @param {GroupResult.IModifyGroupBroadcast=} [properties] Properties to set
         */
        function ModifyGroupBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyGroupBroadcast groupId.
         * @member {string} groupId
         * @memberof GroupResult.ModifyGroupBroadcast
         * @instance
         */
        ModifyGroupBroadcast.prototype.groupId = "";

        /**
         * ModifyGroupBroadcast user.
         * @member {UserResult.IUserBase} user
         * @memberof GroupResult.ModifyGroupBroadcast
         * @instance
         */
        ModifyGroupBroadcast.prototype.user = null;

        /**
         * ModifyGroupBroadcast type.
         * @member {number} type
         * @memberof GroupResult.ModifyGroupBroadcast
         * @instance
         */
        ModifyGroupBroadcast.prototype.type = 0;

        /**
         * ModifyGroupBroadcast info.
         * @member {string} info
         * @memberof GroupResult.ModifyGroupBroadcast
         * @instance
         */
        ModifyGroupBroadcast.prototype.info = "";

        /**
         * ModifyGroupBroadcast target.
         * @member {UserResult.IUserBase|null|undefined} target
         * @memberof GroupResult.ModifyGroupBroadcast
         * @instance
         */
        ModifyGroupBroadcast.prototype.target = null;

        /**
         * Decodes a ModifyGroupBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof GroupResult.ModifyGroupBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GroupResult.ModifyGroupBroadcast} ModifyGroupBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyGroupBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupResult.ModifyGroupBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.string();
                    break;
                case 2:
                    message.user = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.info = reader.string();
                    break;
                case 5:
                    message.target = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupId"))
                throw $util.ProtocolError("missing required 'groupId'", { instance: message });
            if (!message.hasOwnProperty("user"))
                throw $util.ProtocolError("missing required 'user'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a ModifyGroupBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GroupResult.ModifyGroupBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GroupResult.ModifyGroupBroadcast} ModifyGroupBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyGroupBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ModifyGroupBroadcast;
    })();

    GroupResult.GroupMemberChangeBroadcast = (function() {

        /**
         * Properties of a GroupMemberChangeBroadcast.
         * @memberof GroupResult
         * @interface IGroupMemberChangeBroadcast
         * @property {string} groupId GroupMemberChangeBroadcast groupId
         * @property {number} action GroupMemberChangeBroadcast action
         * @property {Array.<UserResult.IUserBase>|null} [info] GroupMemberChangeBroadcast info
         * @property {number} memberCount GroupMemberChangeBroadcast memberCount
         * @property {UserResult.IUserBase|null} [operator] GroupMemberChangeBroadcast operator
         */

        /**
         * Constructs a new GroupMemberChangeBroadcast.
         * @memberof GroupResult
         * @classdesc Represents a GroupMemberChangeBroadcast.
         * @implements IGroupMemberChangeBroadcast
         * @constructor
         * @param {GroupResult.IGroupMemberChangeBroadcast=} [properties] Properties to set
         */
        function GroupMemberChangeBroadcast(properties) {
            this.info = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMemberChangeBroadcast groupId.
         * @member {string} groupId
         * @memberof GroupResult.GroupMemberChangeBroadcast
         * @instance
         */
        GroupMemberChangeBroadcast.prototype.groupId = "";

        /**
         * GroupMemberChangeBroadcast action.
         * @member {number} action
         * @memberof GroupResult.GroupMemberChangeBroadcast
         * @instance
         */
        GroupMemberChangeBroadcast.prototype.action = 0;

        /**
         * GroupMemberChangeBroadcast info.
         * @member {Array.<UserResult.IUserBase>} info
         * @memberof GroupResult.GroupMemberChangeBroadcast
         * @instance
         */
        GroupMemberChangeBroadcast.prototype.info = $util.emptyArray;

        /**
         * GroupMemberChangeBroadcast memberCount.
         * @member {number} memberCount
         * @memberof GroupResult.GroupMemberChangeBroadcast
         * @instance
         */
        GroupMemberChangeBroadcast.prototype.memberCount = 0;

        /**
         * GroupMemberChangeBroadcast operator.
         * @member {UserResult.IUserBase|null|undefined} operator
         * @memberof GroupResult.GroupMemberChangeBroadcast
         * @instance
         */
        GroupMemberChangeBroadcast.prototype.operator = null;

        /**
         * Decodes a GroupMemberChangeBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof GroupResult.GroupMemberChangeBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GroupResult.GroupMemberChangeBroadcast} GroupMemberChangeBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMemberChangeBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupResult.GroupMemberChangeBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.string();
                    break;
                case 2:
                    message.action = reader.int32();
                    break;
                case 3:
                    if (!(message.info && message.info.length))
                        message.info = [];
                    message.info.push($root.UserResult.UserBase.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.memberCount = reader.int32();
                    break;
                case 5:
                    message.operator = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupId"))
                throw $util.ProtocolError("missing required 'groupId'", { instance: message });
            if (!message.hasOwnProperty("action"))
                throw $util.ProtocolError("missing required 'action'", { instance: message });
            if (!message.hasOwnProperty("memberCount"))
                throw $util.ProtocolError("missing required 'memberCount'", { instance: message });
            return message;
        };

        /**
         * Decodes a GroupMemberChangeBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GroupResult.GroupMemberChangeBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GroupResult.GroupMemberChangeBroadcast} GroupMemberChangeBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMemberChangeBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return GroupMemberChangeBroadcast;
    })();

    GroupResult.InviteResult = (function() {

        /**
         * Properties of an InviteResult.
         * @memberof GroupResult
         * @interface IInviteResult
         * @property {string} groupId InviteResult groupId
         * @property {Array.<string>|null} [needAgrees] InviteResult needAgrees
         * @property {Array.<string>|null} [enters] InviteResult enters
         */

        /**
         * Constructs a new InviteResult.
         * @memberof GroupResult
         * @classdesc Represents an InviteResult.
         * @implements IInviteResult
         * @constructor
         * @param {GroupResult.IInviteResult=} [properties] Properties to set
         */
        function InviteResult(properties) {
            this.needAgrees = [];
            this.enters = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InviteResult groupId.
         * @member {string} groupId
         * @memberof GroupResult.InviteResult
         * @instance
         */
        InviteResult.prototype.groupId = "";

        /**
         * InviteResult needAgrees.
         * @member {Array.<string>} needAgrees
         * @memberof GroupResult.InviteResult
         * @instance
         */
        InviteResult.prototype.needAgrees = $util.emptyArray;

        /**
         * InviteResult enters.
         * @member {Array.<string>} enters
         * @memberof GroupResult.InviteResult
         * @instance
         */
        InviteResult.prototype.enters = $util.emptyArray;

        /**
         * Decodes an InviteResult message from the specified reader or buffer.
         * @function decode
         * @memberof GroupResult.InviteResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GroupResult.InviteResult} InviteResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupResult.InviteResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.string();
                    break;
                case 2:
                    if (!(message.needAgrees && message.needAgrees.length))
                        message.needAgrees = [];
                    message.needAgrees.push(reader.string());
                    break;
                case 3:
                    if (!(message.enters && message.enters.length))
                        message.enters = [];
                    message.enters.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupId"))
                throw $util.ProtocolError("missing required 'groupId'", { instance: message });
            return message;
        };

        /**
         * Decodes an InviteResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GroupResult.InviteResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GroupResult.InviteResult} InviteResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return InviteResult;
    })();

    GroupResult.Groups = (function() {

        /**
         * Properties of a Groups.
         * @memberof GroupResult
         * @interface IGroups
         * @property {Array.<GroupResult.IGroupInfo>|null} [infos] Groups infos
         */

        /**
         * Constructs a new Groups.
         * @memberof GroupResult
         * @classdesc Represents a Groups.
         * @implements IGroups
         * @constructor
         * @param {GroupResult.IGroups=} [properties] Properties to set
         */
        function Groups(properties) {
            this.infos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Groups infos.
         * @member {Array.<GroupResult.IGroupInfo>} infos
         * @memberof GroupResult.Groups
         * @instance
         */
        Groups.prototype.infos = $util.emptyArray;

        /**
         * Decodes a Groups message from the specified reader or buffer.
         * @function decode
         * @memberof GroupResult.Groups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GroupResult.Groups} Groups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Groups.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupResult.Groups();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.GroupResult.GroupInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Groups message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GroupResult.Groups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GroupResult.Groups} Groups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Groups.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Groups;
    })();

    GroupResult.GroupInfo = (function() {

        /**
         * Properties of a GroupInfo.
         * @memberof GroupResult
         * @interface IGroupInfo
         * @property {string} groupId GroupInfo groupId
         * @property {string} owner GroupInfo owner
         * @property {string|null} [groupName] GroupInfo groupName
         * @property {string|null} [notice] GroupInfo notice
         * @property {number} memberCount GroupInfo memberCount
         * @property {number|Long} logoTime GroupInfo logoTime
         */

        /**
         * Constructs a new GroupInfo.
         * @memberof GroupResult
         * @classdesc Represents a GroupInfo.
         * @implements IGroupInfo
         * @constructor
         * @param {GroupResult.IGroupInfo=} [properties] Properties to set
         */
        function GroupInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupInfo groupId.
         * @member {string} groupId
         * @memberof GroupResult.GroupInfo
         * @instance
         */
        GroupInfo.prototype.groupId = "";

        /**
         * GroupInfo owner.
         * @member {string} owner
         * @memberof GroupResult.GroupInfo
         * @instance
         */
        GroupInfo.prototype.owner = "";

        /**
         * GroupInfo groupName.
         * @member {string} groupName
         * @memberof GroupResult.GroupInfo
         * @instance
         */
        GroupInfo.prototype.groupName = "";

        /**
         * GroupInfo notice.
         * @member {string} notice
         * @memberof GroupResult.GroupInfo
         * @instance
         */
        GroupInfo.prototype.notice = "";

        /**
         * GroupInfo memberCount.
         * @member {number} memberCount
         * @memberof GroupResult.GroupInfo
         * @instance
         */
        GroupInfo.prototype.memberCount = 0;

        /**
         * GroupInfo logoTime.
         * @member {number|Long} logoTime
         * @memberof GroupResult.GroupInfo
         * @instance
         */
        GroupInfo.prototype.logoTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a GroupInfo message from the specified reader or buffer.
         * @function decode
         * @memberof GroupResult.GroupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GroupResult.GroupInfo} GroupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupResult.GroupInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.string();
                    break;
                case 2:
                    message.owner = reader.string();
                    break;
                case 3:
                    message.groupName = reader.string();
                    break;
                case 4:
                    message.notice = reader.string();
                    break;
                case 5:
                    message.memberCount = reader.int32();
                    break;
                case 6:
                    message.logoTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupId"))
                throw $util.ProtocolError("missing required 'groupId'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("memberCount"))
                throw $util.ProtocolError("missing required 'memberCount'", { instance: message });
            if (!message.hasOwnProperty("logoTime"))
                throw $util.ProtocolError("missing required 'logoTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a GroupInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GroupResult.GroupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GroupResult.GroupInfo} GroupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return GroupInfo;
    })();

    GroupResult.DealGroupMemberBroadcast = (function() {

        /**
         * Properties of a DealGroupMemberBroadcast.
         * @memberof GroupResult
         * @interface IDealGroupMemberBroadcast
         * @property {string} groupId DealGroupMemberBroadcast groupId
         * @property {string} userId DealGroupMemberBroadcast userId
         * @property {number} dealType DealGroupMemberBroadcast dealType
         * @property {UserResult.IUserBase} handler DealGroupMemberBroadcast handler
         */

        /**
         * Constructs a new DealGroupMemberBroadcast.
         * @memberof GroupResult
         * @classdesc Represents a DealGroupMemberBroadcast.
         * @implements IDealGroupMemberBroadcast
         * @constructor
         * @param {GroupResult.IDealGroupMemberBroadcast=} [properties] Properties to set
         */
        function DealGroupMemberBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DealGroupMemberBroadcast groupId.
         * @member {string} groupId
         * @memberof GroupResult.DealGroupMemberBroadcast
         * @instance
         */
        DealGroupMemberBroadcast.prototype.groupId = "";

        /**
         * DealGroupMemberBroadcast userId.
         * @member {string} userId
         * @memberof GroupResult.DealGroupMemberBroadcast
         * @instance
         */
        DealGroupMemberBroadcast.prototype.userId = "";

        /**
         * DealGroupMemberBroadcast dealType.
         * @member {number} dealType
         * @memberof GroupResult.DealGroupMemberBroadcast
         * @instance
         */
        DealGroupMemberBroadcast.prototype.dealType = 0;

        /**
         * DealGroupMemberBroadcast handler.
         * @member {UserResult.IUserBase} handler
         * @memberof GroupResult.DealGroupMemberBroadcast
         * @instance
         */
        DealGroupMemberBroadcast.prototype.handler = null;

        /**
         * Decodes a DealGroupMemberBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof GroupResult.DealGroupMemberBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GroupResult.DealGroupMemberBroadcast} DealGroupMemberBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DealGroupMemberBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupResult.DealGroupMemberBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.dealType = reader.int32();
                    break;
                case 4:
                    message.handler = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupId"))
                throw $util.ProtocolError("missing required 'groupId'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("dealType"))
                throw $util.ProtocolError("missing required 'dealType'", { instance: message });
            if (!message.hasOwnProperty("handler"))
                throw $util.ProtocolError("missing required 'handler'", { instance: message });
            return message;
        };

        /**
         * Decodes a DealGroupMemberBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GroupResult.DealGroupMemberBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GroupResult.DealGroupMemberBroadcast} DealGroupMemberBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DealGroupMemberBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return DealGroupMemberBroadcast;
    })();

    GroupResult.GroupBreakBroadcast = (function() {

        /**
         * Properties of a GroupBreakBroadcast.
         * @memberof GroupResult
         * @interface IGroupBreakBroadcast
         * @property {string} groupId GroupBreakBroadcast groupId
         */

        /**
         * Constructs a new GroupBreakBroadcast.
         * @memberof GroupResult
         * @classdesc Represents a GroupBreakBroadcast.
         * @implements IGroupBreakBroadcast
         * @constructor
         * @param {GroupResult.IGroupBreakBroadcast=} [properties] Properties to set
         */
        function GroupBreakBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupBreakBroadcast groupId.
         * @member {string} groupId
         * @memberof GroupResult.GroupBreakBroadcast
         * @instance
         */
        GroupBreakBroadcast.prototype.groupId = "";

        /**
         * Decodes a GroupBreakBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof GroupResult.GroupBreakBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GroupResult.GroupBreakBroadcast} GroupBreakBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupBreakBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupResult.GroupBreakBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupId"))
                throw $util.ProtocolError("missing required 'groupId'", { instance: message });
            return message;
        };

        /**
         * Decodes a GroupBreakBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GroupResult.GroupBreakBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GroupResult.GroupBreakBroadcast} GroupBreakBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupBreakBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return GroupBreakBroadcast;
    })();

    return GroupResult;
})();

export const GuardianResult = $root.GuardianResult = (() => {

    /**
     * Namespace GuardianResult.
     * @exports GuardianResult
     * @namespace
     */
    const GuardianResult = {};

    GuardianResult.Guardians = (function() {

        /**
         * Properties of a Guardians.
         * @memberof GuardianResult
         * @interface IGuardians
         * @property {Array.<GuardianResult.IGuardian>|null} [list] Guardians list
         * @property {string|null} [guardianName] Guardians guardianName
         * @property {number|null} [memberCount] Guardians memberCount
         */

        /**
         * Constructs a new Guardians.
         * @memberof GuardianResult
         * @classdesc Represents a Guardians.
         * @implements IGuardians
         * @constructor
         * @param {GuardianResult.IGuardians=} [properties] Properties to set
         */
        function Guardians(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Guardians list.
         * @member {Array.<GuardianResult.IGuardian>} list
         * @memberof GuardianResult.Guardians
         * @instance
         */
        Guardians.prototype.list = $util.emptyArray;

        /**
         * Guardians guardianName.
         * @member {string} guardianName
         * @memberof GuardianResult.Guardians
         * @instance
         */
        Guardians.prototype.guardianName = "";

        /**
         * Guardians memberCount.
         * @member {number} memberCount
         * @memberof GuardianResult.Guardians
         * @instance
         */
        Guardians.prototype.memberCount = 0;

        /**
         * Decodes a Guardians message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.Guardians
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.Guardians} Guardians
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Guardians.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.Guardians();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.GuardianResult.Guardian.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.guardianName = reader.string();
                    break;
                case 3:
                    message.memberCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Guardians message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.Guardians
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.Guardians} Guardians
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Guardians.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Guardians;
    })();

    GuardianResult.GuardianInfo = (function() {

        /**
         * Properties of a GuardianInfo.
         * @memberof GuardianResult
         * @interface IGuardianInfo
         * @property {string|null} [guardianName] GuardianInfo guardianName
         * @property {string|null} [lastUpdateNameDate] GuardianInfo lastUpdateNameDate
         * @property {number} memberCount GuardianInfo memberCount
         */

        /**
         * Constructs a new GuardianInfo.
         * @memberof GuardianResult
         * @classdesc Represents a GuardianInfo.
         * @implements IGuardianInfo
         * @constructor
         * @param {GuardianResult.IGuardianInfo=} [properties] Properties to set
         */
        function GuardianInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuardianInfo guardianName.
         * @member {string} guardianName
         * @memberof GuardianResult.GuardianInfo
         * @instance
         */
        GuardianInfo.prototype.guardianName = "";

        /**
         * GuardianInfo lastUpdateNameDate.
         * @member {string} lastUpdateNameDate
         * @memberof GuardianResult.GuardianInfo
         * @instance
         */
        GuardianInfo.prototype.lastUpdateNameDate = "";

        /**
         * GuardianInfo memberCount.
         * @member {number} memberCount
         * @memberof GuardianResult.GuardianInfo
         * @instance
         */
        GuardianInfo.prototype.memberCount = 0;

        /**
         * Decodes a GuardianInfo message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.GuardianInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.GuardianInfo} GuardianInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuardianInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.GuardianInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guardianName = reader.string();
                    break;
                case 2:
                    message.lastUpdateNameDate = reader.string();
                    break;
                case 3:
                    message.memberCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("memberCount"))
                throw $util.ProtocolError("missing required 'memberCount'", { instance: message });
            return message;
        };

        /**
         * Decodes a GuardianInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.GuardianInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.GuardianInfo} GuardianInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuardianInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return GuardianInfo;
    })();

    GuardianResult.MyGuardInfo = (function() {

        /**
         * Properties of a MyGuardInfo.
         * @memberof GuardianResult
         * @interface IMyGuardInfo
         * @property {string} targetId MyGuardInfo targetId
         * @property {GuardianResult.IGuardian|null} [info] MyGuardInfo info
         * @property {string|null} [overPercent] MyGuardInfo overPercent
         * @property {string|null} [guardedDays] MyGuardInfo guardedDays
         * @property {string|null} [expireDays] MyGuardInfo expireDays
         * @property {number|null} [signDays] MyGuardInfo signDays
         * @property {boolean|null} [signed] MyGuardInfo signed
         * @property {Array.<GuardianResult.ITask>|null} [tasks] MyGuardInfo tasks
         * @property {boolean} isGuardian MyGuardInfo isGuardian
         */

        /**
         * Constructs a new MyGuardInfo.
         * @memberof GuardianResult
         * @classdesc Represents a MyGuardInfo.
         * @implements IMyGuardInfo
         * @constructor
         * @param {GuardianResult.IMyGuardInfo=} [properties] Properties to set
         */
        function MyGuardInfo(properties) {
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MyGuardInfo targetId.
         * @member {string} targetId
         * @memberof GuardianResult.MyGuardInfo
         * @instance
         */
        MyGuardInfo.prototype.targetId = "";

        /**
         * MyGuardInfo info.
         * @member {GuardianResult.IGuardian|null|undefined} info
         * @memberof GuardianResult.MyGuardInfo
         * @instance
         */
        MyGuardInfo.prototype.info = null;

        /**
         * MyGuardInfo overPercent.
         * @member {string} overPercent
         * @memberof GuardianResult.MyGuardInfo
         * @instance
         */
        MyGuardInfo.prototype.overPercent = "";

        /**
         * MyGuardInfo guardedDays.
         * @member {string} guardedDays
         * @memberof GuardianResult.MyGuardInfo
         * @instance
         */
        MyGuardInfo.prototype.guardedDays = "";

        /**
         * MyGuardInfo expireDays.
         * @member {string} expireDays
         * @memberof GuardianResult.MyGuardInfo
         * @instance
         */
        MyGuardInfo.prototype.expireDays = "";

        /**
         * MyGuardInfo signDays.
         * @member {number} signDays
         * @memberof GuardianResult.MyGuardInfo
         * @instance
         */
        MyGuardInfo.prototype.signDays = 0;

        /**
         * MyGuardInfo signed.
         * @member {boolean} signed
         * @memberof GuardianResult.MyGuardInfo
         * @instance
         */
        MyGuardInfo.prototype.signed = false;

        /**
         * MyGuardInfo tasks.
         * @member {Array.<GuardianResult.ITask>} tasks
         * @memberof GuardianResult.MyGuardInfo
         * @instance
         */
        MyGuardInfo.prototype.tasks = $util.emptyArray;

        /**
         * MyGuardInfo isGuardian.
         * @member {boolean} isGuardian
         * @memberof GuardianResult.MyGuardInfo
         * @instance
         */
        MyGuardInfo.prototype.isGuardian = false;

        /**
         * Decodes a MyGuardInfo message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.MyGuardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.MyGuardInfo} MyGuardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyGuardInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.MyGuardInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                case 2:
                    message.info = $root.GuardianResult.Guardian.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.overPercent = reader.string();
                    break;
                case 4:
                    message.guardedDays = reader.string();
                    break;
                case 5:
                    message.expireDays = reader.string();
                    break;
                case 6:
                    message.signDays = reader.int32();
                    break;
                case 7:
                    message.signed = reader.bool();
                    break;
                case 8:
                    if (!(message.tasks && message.tasks.length))
                        message.tasks = [];
                    message.tasks.push($root.GuardianResult.Task.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.isGuardian = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            if (!message.hasOwnProperty("isGuardian"))
                throw $util.ProtocolError("missing required 'isGuardian'", { instance: message });
            return message;
        };

        /**
         * Decodes a MyGuardInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.MyGuardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.MyGuardInfo} MyGuardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyGuardInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MyGuardInfo;
    })();

    GuardianResult.Guardian = (function() {

        /**
         * Properties of a Guardian.
         * @memberof GuardianResult
         * @interface IGuardian
         * @property {UserResult.IUserBase} base Guardian base
         * @property {number|Long} intimacy Guardian intimacy
         * @property {number} level Guardian level
         * @property {number} type Guardian type
         */

        /**
         * Constructs a new Guardian.
         * @memberof GuardianResult
         * @classdesc Represents a Guardian.
         * @implements IGuardian
         * @constructor
         * @param {GuardianResult.IGuardian=} [properties] Properties to set
         */
        function Guardian(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Guardian base.
         * @member {UserResult.IUserBase} base
         * @memberof GuardianResult.Guardian
         * @instance
         */
        Guardian.prototype.base = null;

        /**
         * Guardian intimacy.
         * @member {number|Long} intimacy
         * @memberof GuardianResult.Guardian
         * @instance
         */
        Guardian.prototype.intimacy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Guardian level.
         * @member {number} level
         * @memberof GuardianResult.Guardian
         * @instance
         */
        Guardian.prototype.level = 0;

        /**
         * Guardian type.
         * @member {number} type
         * @memberof GuardianResult.Guardian
         * @instance
         */
        Guardian.prototype.type = 0;

        /**
         * Decodes a Guardian message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.Guardian
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.Guardian} Guardian
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Guardian.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.Guardian();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.intimacy = reader.int64();
                    break;
                case 3:
                    message.level = reader.int32();
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("base"))
                throw $util.ProtocolError("missing required 'base'", { instance: message });
            if (!message.hasOwnProperty("intimacy"))
                throw $util.ProtocolError("missing required 'intimacy'", { instance: message });
            if (!message.hasOwnProperty("level"))
                throw $util.ProtocolError("missing required 'level'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a Guardian message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.Guardian
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.Guardian} Guardian
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Guardian.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Guardian;
    })();

    GuardianResult.Task = (function() {

        /**
         * Properties of a Task.
         * @memberof GuardianResult
         * @interface ITask
         * @property {string} id Task id
         * @property {number} reachNum Task reachNum
         */

        /**
         * Constructs a new Task.
         * @memberof GuardianResult
         * @classdesc Represents a Task.
         * @implements ITask
         * @constructor
         * @param {GuardianResult.ITask=} [properties] Properties to set
         */
        function Task(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Task id.
         * @member {string} id
         * @memberof GuardianResult.Task
         * @instance
         */
        Task.prototype.id = "";

        /**
         * Task reachNum.
         * @member {number} reachNum
         * @memberof GuardianResult.Task
         * @instance
         */
        Task.prototype.reachNum = 0;

        /**
         * Decodes a Task message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.Task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.Task} Task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Task.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.Task();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.reachNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("reachNum"))
                throw $util.ProtocolError("missing required 'reachNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a Task message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.Task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.Task} Task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Task.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Task;
    })();

    GuardianResult.JoinGuardianBroadcast = (function() {

        /**
         * Properties of a JoinGuardianBroadcast.
         * @memberof GuardianResult
         * @interface IJoinGuardianBroadcast
         * @property {UserResult.IUserBase} base JoinGuardianBroadcast base
         * @property {string} targetId JoinGuardianBroadcast targetId
         * @property {boolean} isNew JoinGuardianBroadcast isNew
         * @property {number} days JoinGuardianBroadcast days
         * @property {number|null} [num] JoinGuardianBroadcast num
         */

        /**
         * Constructs a new JoinGuardianBroadcast.
         * @memberof GuardianResult
         * @classdesc Represents a JoinGuardianBroadcast.
         * @implements IJoinGuardianBroadcast
         * @constructor
         * @param {GuardianResult.IJoinGuardianBroadcast=} [properties] Properties to set
         */
        function JoinGuardianBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JoinGuardianBroadcast base.
         * @member {UserResult.IUserBase} base
         * @memberof GuardianResult.JoinGuardianBroadcast
         * @instance
         */
        JoinGuardianBroadcast.prototype.base = null;

        /**
         * JoinGuardianBroadcast targetId.
         * @member {string} targetId
         * @memberof GuardianResult.JoinGuardianBroadcast
         * @instance
         */
        JoinGuardianBroadcast.prototype.targetId = "";

        /**
         * JoinGuardianBroadcast isNew.
         * @member {boolean} isNew
         * @memberof GuardianResult.JoinGuardianBroadcast
         * @instance
         */
        JoinGuardianBroadcast.prototype.isNew = false;

        /**
         * JoinGuardianBroadcast days.
         * @member {number} days
         * @memberof GuardianResult.JoinGuardianBroadcast
         * @instance
         */
        JoinGuardianBroadcast.prototype.days = 0;

        /**
         * JoinGuardianBroadcast num.
         * @member {number} num
         * @memberof GuardianResult.JoinGuardianBroadcast
         * @instance
         */
        JoinGuardianBroadcast.prototype.num = 0;

        /**
         * Decodes a JoinGuardianBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.JoinGuardianBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.JoinGuardianBroadcast} JoinGuardianBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinGuardianBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.JoinGuardianBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.isNew = reader.bool();
                    break;
                case 4:
                    message.days = reader.int32();
                    break;
                case 5:
                    message.num = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("base"))
                throw $util.ProtocolError("missing required 'base'", { instance: message });
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            if (!message.hasOwnProperty("isNew"))
                throw $util.ProtocolError("missing required 'isNew'", { instance: message });
            if (!message.hasOwnProperty("days"))
                throw $util.ProtocolError("missing required 'days'", { instance: message });
            return message;
        };

        /**
         * Decodes a JoinGuardianBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.JoinGuardianBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.JoinGuardianBroadcast} JoinGuardianBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinGuardianBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return JoinGuardianBroadcast;
    })();

    GuardianResult.UpdateGuardNameBroadcast = (function() {

        /**
         * Properties of an UpdateGuardNameBroadcast.
         * @memberof GuardianResult
         * @interface IUpdateGuardNameBroadcast
         * @property {string} targetId UpdateGuardNameBroadcast targetId
         * @property {string} name UpdateGuardNameBroadcast name
         */

        /**
         * Constructs a new UpdateGuardNameBroadcast.
         * @memberof GuardianResult
         * @classdesc Represents an UpdateGuardNameBroadcast.
         * @implements IUpdateGuardNameBroadcast
         * @constructor
         * @param {GuardianResult.IUpdateGuardNameBroadcast=} [properties] Properties to set
         */
        function UpdateGuardNameBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateGuardNameBroadcast targetId.
         * @member {string} targetId
         * @memberof GuardianResult.UpdateGuardNameBroadcast
         * @instance
         */
        UpdateGuardNameBroadcast.prototype.targetId = "";

        /**
         * UpdateGuardNameBroadcast name.
         * @member {string} name
         * @memberof GuardianResult.UpdateGuardNameBroadcast
         * @instance
         */
        UpdateGuardNameBroadcast.prototype.name = "";

        /**
         * Decodes an UpdateGuardNameBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.UpdateGuardNameBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.UpdateGuardNameBroadcast} UpdateGuardNameBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateGuardNameBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.UpdateGuardNameBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };

        /**
         * Decodes an UpdateGuardNameBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.UpdateGuardNameBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.UpdateGuardNameBroadcast} UpdateGuardNameBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateGuardNameBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UpdateGuardNameBroadcast;
    })();

    GuardianResult.GuardMemberCountBroadcast = (function() {

        /**
         * Properties of a GuardMemberCountBroadcast.
         * @memberof GuardianResult
         * @interface IGuardMemberCountBroadcast
         * @property {string} targetId GuardMemberCountBroadcast targetId
         * @property {number} memberCount GuardMemberCountBroadcast memberCount
         */

        /**
         * Constructs a new GuardMemberCountBroadcast.
         * @memberof GuardianResult
         * @classdesc Represents a GuardMemberCountBroadcast.
         * @implements IGuardMemberCountBroadcast
         * @constructor
         * @param {GuardianResult.IGuardMemberCountBroadcast=} [properties] Properties to set
         */
        function GuardMemberCountBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuardMemberCountBroadcast targetId.
         * @member {string} targetId
         * @memberof GuardianResult.GuardMemberCountBroadcast
         * @instance
         */
        GuardMemberCountBroadcast.prototype.targetId = "";

        /**
         * GuardMemberCountBroadcast memberCount.
         * @member {number} memberCount
         * @memberof GuardianResult.GuardMemberCountBroadcast
         * @instance
         */
        GuardMemberCountBroadcast.prototype.memberCount = 0;

        /**
         * Decodes a GuardMemberCountBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.GuardMemberCountBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.GuardMemberCountBroadcast} GuardMemberCountBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuardMemberCountBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.GuardMemberCountBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                case 2:
                    message.memberCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            if (!message.hasOwnProperty("memberCount"))
                throw $util.ProtocolError("missing required 'memberCount'", { instance: message });
            return message;
        };

        /**
         * Decodes a GuardMemberCountBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.GuardMemberCountBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.GuardMemberCountBroadcast} GuardMemberCountBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuardMemberCountBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return GuardMemberCountBroadcast;
    })();

    GuardianResult.UpdateGuardianLevelBroadcast = (function() {

        /**
         * Properties of an UpdateGuardianLevelBroadcast.
         * @memberof GuardianResult
         * @interface IUpdateGuardianLevelBroadcast
         * @property {string} targetId UpdateGuardianLevelBroadcast targetId
         * @property {string} userId UpdateGuardianLevelBroadcast userId
         * @property {number} level UpdateGuardianLevelBroadcast level
         */

        /**
         * Constructs a new UpdateGuardianLevelBroadcast.
         * @memberof GuardianResult
         * @classdesc Represents an UpdateGuardianLevelBroadcast.
         * @implements IUpdateGuardianLevelBroadcast
         * @constructor
         * @param {GuardianResult.IUpdateGuardianLevelBroadcast=} [properties] Properties to set
         */
        function UpdateGuardianLevelBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateGuardianLevelBroadcast targetId.
         * @member {string} targetId
         * @memberof GuardianResult.UpdateGuardianLevelBroadcast
         * @instance
         */
        UpdateGuardianLevelBroadcast.prototype.targetId = "";

        /**
         * UpdateGuardianLevelBroadcast userId.
         * @member {string} userId
         * @memberof GuardianResult.UpdateGuardianLevelBroadcast
         * @instance
         */
        UpdateGuardianLevelBroadcast.prototype.userId = "";

        /**
         * UpdateGuardianLevelBroadcast level.
         * @member {number} level
         * @memberof GuardianResult.UpdateGuardianLevelBroadcast
         * @instance
         */
        UpdateGuardianLevelBroadcast.prototype.level = 0;

        /**
         * Decodes an UpdateGuardianLevelBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.UpdateGuardianLevelBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.UpdateGuardianLevelBroadcast} UpdateGuardianLevelBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateGuardianLevelBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.UpdateGuardianLevelBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.level = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("level"))
                throw $util.ProtocolError("missing required 'level'", { instance: message });
            return message;
        };

        /**
         * Decodes an UpdateGuardianLevelBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.UpdateGuardianLevelBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.UpdateGuardianLevelBroadcast} UpdateGuardianLevelBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateGuardianLevelBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UpdateGuardianLevelBroadcast;
    })();

    GuardianResult.MyGuardPartInfo = (function() {

        /**
         * Properties of a MyGuardPartInfo.
         * @memberof GuardianResult
         * @interface IMyGuardPartInfo
         * @property {string} targetId MyGuardPartInfo targetId
         * @property {boolean} isGuardian MyGuardPartInfo isGuardian
         * @property {number|null} [level] MyGuardPartInfo level
         * @property {string|null} [guardName] MyGuardPartInfo guardName
         * @property {number|null} [memberCount] MyGuardPartInfo memberCount
         */

        /**
         * Constructs a new MyGuardPartInfo.
         * @memberof GuardianResult
         * @classdesc Represents a MyGuardPartInfo.
         * @implements IMyGuardPartInfo
         * @constructor
         * @param {GuardianResult.IMyGuardPartInfo=} [properties] Properties to set
         */
        function MyGuardPartInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MyGuardPartInfo targetId.
         * @member {string} targetId
         * @memberof GuardianResult.MyGuardPartInfo
         * @instance
         */
        MyGuardPartInfo.prototype.targetId = "";

        /**
         * MyGuardPartInfo isGuardian.
         * @member {boolean} isGuardian
         * @memberof GuardianResult.MyGuardPartInfo
         * @instance
         */
        MyGuardPartInfo.prototype.isGuardian = false;

        /**
         * MyGuardPartInfo level.
         * @member {number} level
         * @memberof GuardianResult.MyGuardPartInfo
         * @instance
         */
        MyGuardPartInfo.prototype.level = 0;

        /**
         * MyGuardPartInfo guardName.
         * @member {string} guardName
         * @memberof GuardianResult.MyGuardPartInfo
         * @instance
         */
        MyGuardPartInfo.prototype.guardName = "";

        /**
         * MyGuardPartInfo memberCount.
         * @member {number} memberCount
         * @memberof GuardianResult.MyGuardPartInfo
         * @instance
         */
        MyGuardPartInfo.prototype.memberCount = 0;

        /**
         * Decodes a MyGuardPartInfo message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.MyGuardPartInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.MyGuardPartInfo} MyGuardPartInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyGuardPartInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.MyGuardPartInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                case 2:
                    message.isGuardian = reader.bool();
                    break;
                case 4:
                    message.level = reader.int32();
                    break;
                case 5:
                    message.guardName = reader.string();
                    break;
                case 6:
                    message.memberCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            if (!message.hasOwnProperty("isGuardian"))
                throw $util.ProtocolError("missing required 'isGuardian'", { instance: message });
            return message;
        };

        /**
         * Decodes a MyGuardPartInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.MyGuardPartInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.MyGuardPartInfo} MyGuardPartInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyGuardPartInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MyGuardPartInfo;
    })();

    GuardianResult.InGuards = (function() {

        /**
         * Properties of an InGuards.
         * @memberof GuardianResult
         * @interface IInGuards
         * @property {Array.<GuardianResult.IInGuardInfo>|null} [list] InGuards list
         */

        /**
         * Constructs a new InGuards.
         * @memberof GuardianResult
         * @classdesc Represents an InGuards.
         * @implements IInGuards
         * @constructor
         * @param {GuardianResult.IInGuards=} [properties] Properties to set
         */
        function InGuards(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InGuards list.
         * @member {Array.<GuardianResult.IInGuardInfo>} list
         * @memberof GuardianResult.InGuards
         * @instance
         */
        InGuards.prototype.list = $util.emptyArray;

        /**
         * Decodes an InGuards message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.InGuards
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.InGuards} InGuards
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InGuards.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.InGuards();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.GuardianResult.InGuardInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InGuards message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.InGuards
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.InGuards} InGuards
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InGuards.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return InGuards;
    })();

    GuardianResult.InGuardInfo = (function() {

        /**
         * Properties of an InGuardInfo.
         * @memberof GuardianResult
         * @interface IInGuardInfo
         * @property {string} userId InGuardInfo userId
         * @property {string} guardName InGuardInfo guardName
         * @property {GuardianResult.IGuardian} info InGuardInfo info
         * @property {number} isOverTime InGuardInfo isOverTime
         * @property {string} guardTime InGuardInfo guardTime
         * @property {number|null} [roomStatus] InGuardInfo roomStatus
         * @property {string|null} [roomId] InGuardInfo roomId
         */

        /**
         * Constructs a new InGuardInfo.
         * @memberof GuardianResult
         * @classdesc Represents an InGuardInfo.
         * @implements IInGuardInfo
         * @constructor
         * @param {GuardianResult.IInGuardInfo=} [properties] Properties to set
         */
        function InGuardInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InGuardInfo userId.
         * @member {string} userId
         * @memberof GuardianResult.InGuardInfo
         * @instance
         */
        InGuardInfo.prototype.userId = "";

        /**
         * InGuardInfo guardName.
         * @member {string} guardName
         * @memberof GuardianResult.InGuardInfo
         * @instance
         */
        InGuardInfo.prototype.guardName = "";

        /**
         * InGuardInfo info.
         * @member {GuardianResult.IGuardian} info
         * @memberof GuardianResult.InGuardInfo
         * @instance
         */
        InGuardInfo.prototype.info = null;

        /**
         * InGuardInfo isOverTime.
         * @member {number} isOverTime
         * @memberof GuardianResult.InGuardInfo
         * @instance
         */
        InGuardInfo.prototype.isOverTime = 0;

        /**
         * InGuardInfo guardTime.
         * @member {string} guardTime
         * @memberof GuardianResult.InGuardInfo
         * @instance
         */
        InGuardInfo.prototype.guardTime = "";

        /**
         * InGuardInfo roomStatus.
         * @member {number} roomStatus
         * @memberof GuardianResult.InGuardInfo
         * @instance
         */
        InGuardInfo.prototype.roomStatus = 0;

        /**
         * InGuardInfo roomId.
         * @member {string} roomId
         * @memberof GuardianResult.InGuardInfo
         * @instance
         */
        InGuardInfo.prototype.roomId = "";

        /**
         * Decodes an InGuardInfo message from the specified reader or buffer.
         * @function decode
         * @memberof GuardianResult.InGuardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GuardianResult.InGuardInfo} InGuardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InGuardInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GuardianResult.InGuardInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.guardName = reader.string();
                    break;
                case 3:
                    message.info = $root.GuardianResult.Guardian.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.isOverTime = reader.int32();
                    break;
                case 5:
                    message.guardTime = reader.string();
                    break;
                case 6:
                    message.roomStatus = reader.int32();
                    break;
                case 7:
                    message.roomId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("guardName"))
                throw $util.ProtocolError("missing required 'guardName'", { instance: message });
            if (!message.hasOwnProperty("info"))
                throw $util.ProtocolError("missing required 'info'", { instance: message });
            if (!message.hasOwnProperty("isOverTime"))
                throw $util.ProtocolError("missing required 'isOverTime'", { instance: message });
            if (!message.hasOwnProperty("guardTime"))
                throw $util.ProtocolError("missing required 'guardTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an InGuardInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GuardianResult.InGuardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GuardianResult.InGuardInfo} InGuardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InGuardInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return InGuardInfo;
    })();

    return GuardianResult;
})();

export const LiveResult = $root.LiveResult = (() => {

    /**
     * Namespace LiveResult.
     * @exports LiveResult
     * @namespace
     */
    const LiveResult = {};

    LiveResult.FamilyList = (function() {

        /**
         * Properties of a FamilyList.
         * @memberof LiveResult
         * @interface IFamilyList
         * @property {Array.<LiveResult.IFamilyInfo>|null} [list] FamilyList list
         */

        /**
         * Constructs a new FamilyList.
         * @memberof LiveResult
         * @classdesc Represents a FamilyList.
         * @implements IFamilyList
         * @constructor
         * @param {LiveResult.IFamilyList=} [properties] Properties to set
         */
        function FamilyList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyList list.
         * @member {Array.<LiveResult.IFamilyInfo>} list
         * @memberof LiveResult.FamilyList
         * @instance
         */
        FamilyList.prototype.list = $util.emptyArray;

        /**
         * Decodes a FamilyList message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.FamilyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.FamilyList} FamilyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.FamilyList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.LiveResult.FamilyInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FamilyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.FamilyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.FamilyList} FamilyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FamilyList;
    })();

    LiveResult.FamilyInfo = (function() {

        /**
         * Properties of a FamilyInfo.
         * @memberof LiveResult
         * @interface IFamilyInfo
         * @property {string} familyId FamilyInfo familyId
         * @property {string|null} [familyName] FamilyInfo familyName
         * @property {string|null} [slogan] FamilyInfo slogan
         * @property {string|null} [createId] FamilyInfo createId
         * @property {string|null} [familyLogo] FamilyInfo familyLogo
         * @property {number|null} [type] FamilyInfo type
         * @property {Array.<LiveResult.IFamilyMemberInfo>|null} [list] FamilyInfo list
         */

        /**
         * Constructs a new FamilyInfo.
         * @memberof LiveResult
         * @classdesc Represents a FamilyInfo.
         * @implements IFamilyInfo
         * @constructor
         * @param {LiveResult.IFamilyInfo=} [properties] Properties to set
         */
        function FamilyInfo(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyInfo familyId.
         * @member {string} familyId
         * @memberof LiveResult.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.familyId = "";

        /**
         * FamilyInfo familyName.
         * @member {string} familyName
         * @memberof LiveResult.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.familyName = "";

        /**
         * FamilyInfo slogan.
         * @member {string} slogan
         * @memberof LiveResult.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.slogan = "";

        /**
         * FamilyInfo createId.
         * @member {string} createId
         * @memberof LiveResult.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.createId = "";

        /**
         * FamilyInfo familyLogo.
         * @member {string} familyLogo
         * @memberof LiveResult.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.familyLogo = "";

        /**
         * FamilyInfo type.
         * @member {number} type
         * @memberof LiveResult.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.type = 0;

        /**
         * FamilyInfo list.
         * @member {Array.<LiveResult.IFamilyMemberInfo>} list
         * @memberof LiveResult.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.list = $util.emptyArray;

        /**
         * Decodes a FamilyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.FamilyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.FamilyInfo} FamilyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.FamilyInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.familyId = reader.string();
                    break;
                case 2:
                    message.familyName = reader.string();
                    break;
                case 3:
                    message.slogan = reader.string();
                    break;
                case 4:
                    message.createId = reader.string();
                    break;
                case 5:
                    message.familyLogo = reader.string();
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                case 7:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.LiveResult.FamilyMemberInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("familyId"))
                throw $util.ProtocolError("missing required 'familyId'", { instance: message });
            return message;
        };

        /**
         * Decodes a FamilyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.FamilyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.FamilyInfo} FamilyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FamilyInfo;
    })();

    LiveResult.FamilyMemberInfo = (function() {

        /**
         * Properties of a FamilyMemberInfo.
         * @memberof LiveResult
         * @interface IFamilyMemberInfo
         * @property {string} memberId FamilyMemberInfo memberId
         * @property {string} merberName FamilyMemberInfo merberName
         * @property {number} logoTime FamilyMemberInfo logoTime
         * @property {number} jobId FamilyMemberInfo jobId
         */

        /**
         * Constructs a new FamilyMemberInfo.
         * @memberof LiveResult
         * @classdesc Represents a FamilyMemberInfo.
         * @implements IFamilyMemberInfo
         * @constructor
         * @param {LiveResult.IFamilyMemberInfo=} [properties] Properties to set
         */
        function FamilyMemberInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyMemberInfo memberId.
         * @member {string} memberId
         * @memberof LiveResult.FamilyMemberInfo
         * @instance
         */
        FamilyMemberInfo.prototype.memberId = "";

        /**
         * FamilyMemberInfo merberName.
         * @member {string} merberName
         * @memberof LiveResult.FamilyMemberInfo
         * @instance
         */
        FamilyMemberInfo.prototype.merberName = "";

        /**
         * FamilyMemberInfo logoTime.
         * @member {number} logoTime
         * @memberof LiveResult.FamilyMemberInfo
         * @instance
         */
        FamilyMemberInfo.prototype.logoTime = 0;

        /**
         * FamilyMemberInfo jobId.
         * @member {number} jobId
         * @memberof LiveResult.FamilyMemberInfo
         * @instance
         */
        FamilyMemberInfo.prototype.jobId = 0;

        /**
         * Decodes a FamilyMemberInfo message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.FamilyMemberInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.FamilyMemberInfo} FamilyMemberInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyMemberInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.FamilyMemberInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.memberId = reader.string();
                    break;
                case 2:
                    message.merberName = reader.string();
                    break;
                case 3:
                    message.logoTime = reader.int32();
                    break;
                case 4:
                    message.jobId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("memberId"))
                throw $util.ProtocolError("missing required 'memberId'", { instance: message });
            if (!message.hasOwnProperty("merberName"))
                throw $util.ProtocolError("missing required 'merberName'", { instance: message });
            if (!message.hasOwnProperty("logoTime"))
                throw $util.ProtocolError("missing required 'logoTime'", { instance: message });
            if (!message.hasOwnProperty("jobId"))
                throw $util.ProtocolError("missing required 'jobId'", { instance: message });
            return message;
        };

        /**
         * Decodes a FamilyMemberInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.FamilyMemberInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.FamilyMemberInfo} FamilyMemberInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyMemberInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FamilyMemberInfo;
    })();

    LiveResult.MyFamilyInfo = (function() {

        /**
         * Properties of a MyFamilyInfo.
         * @memberof LiveResult
         * @interface IMyFamilyInfo
         * @property {LiveResult.IFamilyInfo} family MyFamilyInfo family
         * @property {number|null} [signYears] MyFamilyInfo signYears
         * @property {number|null} [anchorType] MyFamilyInfo anchorType
         * @property {number|Long|null} [contractTime] MyFamilyInfo contractTime
         * @property {number|Long|null} [balance] MyFamilyInfo balance
         */

        /**
         * Constructs a new MyFamilyInfo.
         * @memberof LiveResult
         * @classdesc Represents a MyFamilyInfo.
         * @implements IMyFamilyInfo
         * @constructor
         * @param {LiveResult.IMyFamilyInfo=} [properties] Properties to set
         */
        function MyFamilyInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MyFamilyInfo family.
         * @member {LiveResult.IFamilyInfo} family
         * @memberof LiveResult.MyFamilyInfo
         * @instance
         */
        MyFamilyInfo.prototype.family = null;

        /**
         * MyFamilyInfo signYears.
         * @member {number} signYears
         * @memberof LiveResult.MyFamilyInfo
         * @instance
         */
        MyFamilyInfo.prototype.signYears = 0;

        /**
         * MyFamilyInfo anchorType.
         * @member {number} anchorType
         * @memberof LiveResult.MyFamilyInfo
         * @instance
         */
        MyFamilyInfo.prototype.anchorType = 0;

        /**
         * MyFamilyInfo contractTime.
         * @member {number|Long} contractTime
         * @memberof LiveResult.MyFamilyInfo
         * @instance
         */
        MyFamilyInfo.prototype.contractTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MyFamilyInfo balance.
         * @member {number|Long} balance
         * @memberof LiveResult.MyFamilyInfo
         * @instance
         */
        MyFamilyInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a MyFamilyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.MyFamilyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.MyFamilyInfo} MyFamilyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyFamilyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.MyFamilyInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.family = $root.LiveResult.FamilyInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.signYears = reader.int32();
                    break;
                case 3:
                    message.anchorType = reader.int32();
                    break;
                case 4:
                    message.contractTime = reader.int64();
                    break;
                case 5:
                    message.balance = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("family"))
                throw $util.ProtocolError("missing required 'family'", { instance: message });
            return message;
        };

        /**
         * Decodes a MyFamilyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.MyFamilyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.MyFamilyInfo} MyFamilyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyFamilyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MyFamilyInfo;
    })();

    LiveResult.FamilyStatusMsg = (function() {

        /**
         * Properties of a FamilyStatusMsg.
         * @memberof LiveResult
         * @interface IFamilyStatusMsg
         * @property {string|null} [familyId] FamilyStatusMsg familyId
         * @property {string|null} [familyName] FamilyStatusMsg familyName
         * @property {number|Long|null} [cancellationTime] FamilyStatusMsg cancellationTime
         * @property {number|null} [createFamilyStatus] FamilyStatusMsg createFamilyStatus
         */

        /**
         * Constructs a new FamilyStatusMsg.
         * @memberof LiveResult
         * @classdesc Represents a FamilyStatusMsg.
         * @implements IFamilyStatusMsg
         * @constructor
         * @param {LiveResult.IFamilyStatusMsg=} [properties] Properties to set
         */
        function FamilyStatusMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyStatusMsg familyId.
         * @member {string} familyId
         * @memberof LiveResult.FamilyStatusMsg
         * @instance
         */
        FamilyStatusMsg.prototype.familyId = "";

        /**
         * FamilyStatusMsg familyName.
         * @member {string} familyName
         * @memberof LiveResult.FamilyStatusMsg
         * @instance
         */
        FamilyStatusMsg.prototype.familyName = "";

        /**
         * FamilyStatusMsg cancellationTime.
         * @member {number|Long} cancellationTime
         * @memberof LiveResult.FamilyStatusMsg
         * @instance
         */
        FamilyStatusMsg.prototype.cancellationTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FamilyStatusMsg createFamilyStatus.
         * @member {number} createFamilyStatus
         * @memberof LiveResult.FamilyStatusMsg
         * @instance
         */
        FamilyStatusMsg.prototype.createFamilyStatus = 0;

        /**
         * Decodes a FamilyStatusMsg message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.FamilyStatusMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.FamilyStatusMsg} FamilyStatusMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyStatusMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.FamilyStatusMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.familyId = reader.string();
                    break;
                case 2:
                    message.familyName = reader.string();
                    break;
                case 3:
                    message.cancellationTime = reader.int64();
                    break;
                case 4:
                    message.createFamilyStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FamilyStatusMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.FamilyStatusMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.FamilyStatusMsg} FamilyStatusMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyStatusMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return FamilyStatusMsg;
    })();

    LiveResult.DrawingsResult = (function() {

        /**
         * Properties of a DrawingsResult.
         * @memberof LiveResult
         * @interface IDrawingsResult
         * @property {string} msg DrawingsResult msg
         * @property {number|null} [status] DrawingsResult status
         */

        /**
         * Constructs a new DrawingsResult.
         * @memberof LiveResult
         * @classdesc Represents a DrawingsResult.
         * @implements IDrawingsResult
         * @constructor
         * @param {LiveResult.IDrawingsResult=} [properties] Properties to set
         */
        function DrawingsResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DrawingsResult msg.
         * @member {string} msg
         * @memberof LiveResult.DrawingsResult
         * @instance
         */
        DrawingsResult.prototype.msg = "";

        /**
         * DrawingsResult status.
         * @member {number} status
         * @memberof LiveResult.DrawingsResult
         * @instance
         */
        DrawingsResult.prototype.status = 0;

        /**
         * Decodes a DrawingsResult message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.DrawingsResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.DrawingsResult} DrawingsResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DrawingsResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.DrawingsResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = reader.string();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("msg"))
                throw $util.ProtocolError("missing required 'msg'", { instance: message });
            return message;
        };

        /**
         * Decodes a DrawingsResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.DrawingsResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.DrawingsResult} DrawingsResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DrawingsResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return DrawingsResult;
    })();

    LiveResult.LiveExpenseStatus = (function() {

        /**
         * Properties of a LiveExpenseStatus.
         * @memberof LiveResult
         * @interface ILiveExpenseStatus
         * @property {string} orderId LiveExpenseStatus orderId
         * @property {number} status LiveExpenseStatus status
         */

        /**
         * Constructs a new LiveExpenseStatus.
         * @memberof LiveResult
         * @classdesc Represents a LiveExpenseStatus.
         * @implements ILiveExpenseStatus
         * @constructor
         * @param {LiveResult.ILiveExpenseStatus=} [properties] Properties to set
         */
        function LiveExpenseStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveExpenseStatus orderId.
         * @member {string} orderId
         * @memberof LiveResult.LiveExpenseStatus
         * @instance
         */
        LiveExpenseStatus.prototype.orderId = "";

        /**
         * LiveExpenseStatus status.
         * @member {number} status
         * @memberof LiveResult.LiveExpenseStatus
         * @instance
         */
        LiveExpenseStatus.prototype.status = 0;

        /**
         * Decodes a LiveExpenseStatus message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveExpenseStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveExpenseStatus} LiveExpenseStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExpenseStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveExpenseStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.orderId = reader.string();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("orderId"))
                throw $util.ProtocolError("missing required 'orderId'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveExpenseStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveExpenseStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveExpenseStatus} LiveExpenseStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExpenseStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveExpenseStatus;
    })();

    LiveResult.LiveEarningData = (function() {

        /**
         * Properties of a LiveEarningData.
         * @memberof LiveResult
         * @interface ILiveEarningData
         * @property {Array.<LiveResult.ILiveEarningInfo>|null} [list] LiveEarningData list
         */

        /**
         * Constructs a new LiveEarningData.
         * @memberof LiveResult
         * @classdesc Represents a LiveEarningData.
         * @implements ILiveEarningData
         * @constructor
         * @param {LiveResult.ILiveEarningData=} [properties] Properties to set
         */
        function LiveEarningData(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveEarningData list.
         * @member {Array.<LiveResult.ILiveEarningInfo>} list
         * @memberof LiveResult.LiveEarningData
         * @instance
         */
        LiveEarningData.prototype.list = $util.emptyArray;

        /**
         * Decodes a LiveEarningData message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveEarningData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveEarningData} LiveEarningData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveEarningData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveEarningData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.LiveResult.LiveEarningInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LiveEarningData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveEarningData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveEarningData} LiveEarningData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveEarningData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveEarningData;
    })();

    LiveResult.LiveEarningInfo = (function() {

        /**
         * Properties of a LiveEarningInfo.
         * @memberof LiveResult
         * @interface ILiveEarningInfo
         * @property {string} id LiveEarningInfo id
         * @property {number|null} [money] LiveEarningInfo money
         * @property {number|Long|null} [createTime] LiveEarningInfo createTime
         * @property {number|null} [roomAnchorRate] LiveEarningInfo roomAnchorRate
         */

        /**
         * Constructs a new LiveEarningInfo.
         * @memberof LiveResult
         * @classdesc Represents a LiveEarningInfo.
         * @implements ILiveEarningInfo
         * @constructor
         * @param {LiveResult.ILiveEarningInfo=} [properties] Properties to set
         */
        function LiveEarningInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveEarningInfo id.
         * @member {string} id
         * @memberof LiveResult.LiveEarningInfo
         * @instance
         */
        LiveEarningInfo.prototype.id = "";

        /**
         * LiveEarningInfo money.
         * @member {number} money
         * @memberof LiveResult.LiveEarningInfo
         * @instance
         */
        LiveEarningInfo.prototype.money = 0;

        /**
         * LiveEarningInfo createTime.
         * @member {number|Long} createTime
         * @memberof LiveResult.LiveEarningInfo
         * @instance
         */
        LiveEarningInfo.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveEarningInfo roomAnchorRate.
         * @member {number} roomAnchorRate
         * @memberof LiveResult.LiveEarningInfo
         * @instance
         */
        LiveEarningInfo.prototype.roomAnchorRate = 0;

        /**
         * Decodes a LiveEarningInfo message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveEarningInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveEarningInfo} LiveEarningInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveEarningInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveEarningInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 5:
                    message.money = reader.int32();
                    break;
                case 6:
                    message.createTime = reader.int64();
                    break;
                case 12:
                    message.roomAnchorRate = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveEarningInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveEarningInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveEarningInfo} LiveEarningInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveEarningInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveEarningInfo;
    })();

    LiveResult.LiveRecvData = (function() {

        /**
         * Properties of a LiveRecvData.
         * @memberof LiveResult
         * @interface ILiveRecvData
         * @property {Array.<LiveResult.ILiveRecvInfo>|null} [list] LiveRecvData list
         */

        /**
         * Constructs a new LiveRecvData.
         * @memberof LiveResult
         * @classdesc Represents a LiveRecvData.
         * @implements ILiveRecvData
         * @constructor
         * @param {LiveResult.ILiveRecvData=} [properties] Properties to set
         */
        function LiveRecvData(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveRecvData list.
         * @member {Array.<LiveResult.ILiveRecvInfo>} list
         * @memberof LiveResult.LiveRecvData
         * @instance
         */
        LiveRecvData.prototype.list = $util.emptyArray;

        /**
         * Decodes a LiveRecvData message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveRecvData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveRecvData} LiveRecvData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRecvData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveRecvData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.LiveResult.LiveRecvInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LiveRecvData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveRecvData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveRecvData} LiveRecvData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRecvData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveRecvData;
    })();

    LiveResult.LiveRecvInfo = (function() {

        /**
         * Properties of a LiveRecvInfo.
         * @memberof LiveResult
         * @interface ILiveRecvInfo
         * @property {string} id LiveRecvInfo id
         * @property {UserResult.IUserBase} sendUserBase LiveRecvInfo sendUserBase
         * @property {string} giftId LiveRecvInfo giftId
         * @property {number} giftNum LiveRecvInfo giftNum
         * @property {number} groupNum LiveRecvInfo groupNum
         * @property {number} recv LiveRecvInfo recv
         * @property {number} roomAnchorRate LiveRecvInfo roomAnchorRate
         * @property {number|Long} createTime LiveRecvInfo createTime
         */

        /**
         * Constructs a new LiveRecvInfo.
         * @memberof LiveResult
         * @classdesc Represents a LiveRecvInfo.
         * @implements ILiveRecvInfo
         * @constructor
         * @param {LiveResult.ILiveRecvInfo=} [properties] Properties to set
         */
        function LiveRecvInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveRecvInfo id.
         * @member {string} id
         * @memberof LiveResult.LiveRecvInfo
         * @instance
         */
        LiveRecvInfo.prototype.id = "";

        /**
         * LiveRecvInfo sendUserBase.
         * @member {UserResult.IUserBase} sendUserBase
         * @memberof LiveResult.LiveRecvInfo
         * @instance
         */
        LiveRecvInfo.prototype.sendUserBase = null;

        /**
         * LiveRecvInfo giftId.
         * @member {string} giftId
         * @memberof LiveResult.LiveRecvInfo
         * @instance
         */
        LiveRecvInfo.prototype.giftId = "";

        /**
         * LiveRecvInfo giftNum.
         * @member {number} giftNum
         * @memberof LiveResult.LiveRecvInfo
         * @instance
         */
        LiveRecvInfo.prototype.giftNum = 0;

        /**
         * LiveRecvInfo groupNum.
         * @member {number} groupNum
         * @memberof LiveResult.LiveRecvInfo
         * @instance
         */
        LiveRecvInfo.prototype.groupNum = 0;

        /**
         * LiveRecvInfo recv.
         * @member {number} recv
         * @memberof LiveResult.LiveRecvInfo
         * @instance
         */
        LiveRecvInfo.prototype.recv = 0;

        /**
         * LiveRecvInfo roomAnchorRate.
         * @member {number} roomAnchorRate
         * @memberof LiveResult.LiveRecvInfo
         * @instance
         */
        LiveRecvInfo.prototype.roomAnchorRate = 0;

        /**
         * LiveRecvInfo createTime.
         * @member {number|Long} createTime
         * @memberof LiveResult.LiveRecvInfo
         * @instance
         */
        LiveRecvInfo.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a LiveRecvInfo message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveRecvInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveRecvInfo} LiveRecvInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRecvInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveRecvInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.sendUserBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.giftId = reader.string();
                    break;
                case 4:
                    message.giftNum = reader.int32();
                    break;
                case 5:
                    message.groupNum = reader.int32();
                    break;
                case 6:
                    message.recv = reader.int32();
                    break;
                case 7:
                    message.roomAnchorRate = reader.int32();
                    break;
                case 8:
                    message.createTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("sendUserBase"))
                throw $util.ProtocolError("missing required 'sendUserBase'", { instance: message });
            if (!message.hasOwnProperty("giftId"))
                throw $util.ProtocolError("missing required 'giftId'", { instance: message });
            if (!message.hasOwnProperty("giftNum"))
                throw $util.ProtocolError("missing required 'giftNum'", { instance: message });
            if (!message.hasOwnProperty("groupNum"))
                throw $util.ProtocolError("missing required 'groupNum'", { instance: message });
            if (!message.hasOwnProperty("recv"))
                throw $util.ProtocolError("missing required 'recv'", { instance: message });
            if (!message.hasOwnProperty("roomAnchorRate"))
                throw $util.ProtocolError("missing required 'roomAnchorRate'", { instance: message });
            if (!message.hasOwnProperty("createTime"))
                throw $util.ProtocolError("missing required 'createTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveRecvInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveRecvInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveRecvInfo} LiveRecvInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRecvInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveRecvInfo;
    })();

    LiveResult.LiveExpenseData = (function() {

        /**
         * Properties of a LiveExpenseData.
         * @memberof LiveResult
         * @interface ILiveExpenseData
         * @property {Array.<LiveResult.ILiveExpenseInfo>|null} [list] LiveExpenseData list
         */

        /**
         * Constructs a new LiveExpenseData.
         * @memberof LiveResult
         * @classdesc Represents a LiveExpenseData.
         * @implements ILiveExpenseData
         * @constructor
         * @param {LiveResult.ILiveExpenseData=} [properties] Properties to set
         */
        function LiveExpenseData(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveExpenseData list.
         * @member {Array.<LiveResult.ILiveExpenseInfo>} list
         * @memberof LiveResult.LiveExpenseData
         * @instance
         */
        LiveExpenseData.prototype.list = $util.emptyArray;

        /**
         * Decodes a LiveExpenseData message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveExpenseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveExpenseData} LiveExpenseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExpenseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveExpenseData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.LiveResult.LiveExpenseInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LiveExpenseData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveExpenseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveExpenseData} LiveExpenseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExpenseData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveExpenseData;
    })();

    LiveResult.LiveExpenseInfo = (function() {

        /**
         * Properties of a LiveExpenseInfo.
         * @memberof LiveResult
         * @interface ILiveExpenseInfo
         * @property {string} id LiveExpenseInfo id
         * @property {string|null} [orderId] LiveExpenseInfo orderId
         * @property {string|null} [userId] LiveExpenseInfo userId
         * @property {number|null} [payType] LiveExpenseInfo payType
         * @property {number|null} [money] LiveExpenseInfo money
         * @property {number|Long|null} [createTime] LiveExpenseInfo createTime
         * @property {boolean|null} [needGetStatus] LiveExpenseInfo needGetStatus
         * @property {number|null} [status] LiveExpenseInfo status
         */

        /**
         * Constructs a new LiveExpenseInfo.
         * @memberof LiveResult
         * @classdesc Represents a LiveExpenseInfo.
         * @implements ILiveExpenseInfo
         * @constructor
         * @param {LiveResult.ILiveExpenseInfo=} [properties] Properties to set
         */
        function LiveExpenseInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveExpenseInfo id.
         * @member {string} id
         * @memberof LiveResult.LiveExpenseInfo
         * @instance
         */
        LiveExpenseInfo.prototype.id = "";

        /**
         * LiveExpenseInfo orderId.
         * @member {string} orderId
         * @memberof LiveResult.LiveExpenseInfo
         * @instance
         */
        LiveExpenseInfo.prototype.orderId = "";

        /**
         * LiveExpenseInfo userId.
         * @member {string} userId
         * @memberof LiveResult.LiveExpenseInfo
         * @instance
         */
        LiveExpenseInfo.prototype.userId = "";

        /**
         * LiveExpenseInfo payType.
         * @member {number} payType
         * @memberof LiveResult.LiveExpenseInfo
         * @instance
         */
        LiveExpenseInfo.prototype.payType = 0;

        /**
         * LiveExpenseInfo money.
         * @member {number} money
         * @memberof LiveResult.LiveExpenseInfo
         * @instance
         */
        LiveExpenseInfo.prototype.money = 0;

        /**
         * LiveExpenseInfo createTime.
         * @member {number|Long} createTime
         * @memberof LiveResult.LiveExpenseInfo
         * @instance
         */
        LiveExpenseInfo.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveExpenseInfo needGetStatus.
         * @member {boolean} needGetStatus
         * @memberof LiveResult.LiveExpenseInfo
         * @instance
         */
        LiveExpenseInfo.prototype.needGetStatus = false;

        /**
         * LiveExpenseInfo status.
         * @member {number} status
         * @memberof LiveResult.LiveExpenseInfo
         * @instance
         */
        LiveExpenseInfo.prototype.status = 0;

        /**
         * Decodes a LiveExpenseInfo message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveExpenseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveExpenseInfo} LiveExpenseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExpenseInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveExpenseInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.orderId = reader.string();
                    break;
                case 3:
                    message.userId = reader.string();
                    break;
                case 4:
                    message.payType = reader.int32();
                    break;
                case 5:
                    message.money = reader.int32();
                    break;
                case 6:
                    message.createTime = reader.int64();
                    break;
                case 7:
                    message.needGetStatus = reader.bool();
                    break;
                case 8:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveExpenseInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveExpenseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveExpenseInfo} LiveExpenseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExpenseInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveExpenseInfo;
    })();

    LiveResult.LiveExpenseInfoDetail = (function() {

        /**
         * Properties of a LiveExpenseInfoDetail.
         * @memberof LiveResult
         * @interface ILiveExpenseInfoDetail
         * @property {string} userId LiveExpenseInfoDetail userId
         * @property {string} orderId LiveExpenseInfoDetail orderId
         * @property {number} payType LiveExpenseInfoDetail payType
         * @property {number} money LiveExpenseInfoDetail money
         * @property {string} payeeRealName LiveExpenseInfoDetail payeeRealName
         * @property {string} payeeAccount LiveExpenseInfoDetail payeeAccount
         * @property {number} status LiveExpenseInfoDetail status
         * @property {number|Long|null} [createTime] LiveExpenseInfoDetail createTime
         * @property {boolean|null} [needGetStatus] LiveExpenseInfoDetail needGetStatus
         */

        /**
         * Constructs a new LiveExpenseInfoDetail.
         * @memberof LiveResult
         * @classdesc Represents a LiveExpenseInfoDetail.
         * @implements ILiveExpenseInfoDetail
         * @constructor
         * @param {LiveResult.ILiveExpenseInfoDetail=} [properties] Properties to set
         */
        function LiveExpenseInfoDetail(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveExpenseInfoDetail userId.
         * @member {string} userId
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @instance
         */
        LiveExpenseInfoDetail.prototype.userId = "";

        /**
         * LiveExpenseInfoDetail orderId.
         * @member {string} orderId
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @instance
         */
        LiveExpenseInfoDetail.prototype.orderId = "";

        /**
         * LiveExpenseInfoDetail payType.
         * @member {number} payType
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @instance
         */
        LiveExpenseInfoDetail.prototype.payType = 0;

        /**
         * LiveExpenseInfoDetail money.
         * @member {number} money
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @instance
         */
        LiveExpenseInfoDetail.prototype.money = 0;

        /**
         * LiveExpenseInfoDetail payeeRealName.
         * @member {string} payeeRealName
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @instance
         */
        LiveExpenseInfoDetail.prototype.payeeRealName = "";

        /**
         * LiveExpenseInfoDetail payeeAccount.
         * @member {string} payeeAccount
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @instance
         */
        LiveExpenseInfoDetail.prototype.payeeAccount = "";

        /**
         * LiveExpenseInfoDetail status.
         * @member {number} status
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @instance
         */
        LiveExpenseInfoDetail.prototype.status = 0;

        /**
         * LiveExpenseInfoDetail createTime.
         * @member {number|Long} createTime
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @instance
         */
        LiveExpenseInfoDetail.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveExpenseInfoDetail needGetStatus.
         * @member {boolean} needGetStatus
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @instance
         */
        LiveExpenseInfoDetail.prototype.needGetStatus = false;

        /**
         * Decodes a LiveExpenseInfoDetail message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveExpenseInfoDetail} LiveExpenseInfoDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExpenseInfoDetail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveExpenseInfoDetail();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.orderId = reader.string();
                    break;
                case 3:
                    message.payType = reader.int32();
                    break;
                case 4:
                    message.money = reader.int32();
                    break;
                case 5:
                    message.payeeRealName = reader.string();
                    break;
                case 6:
                    message.payeeAccount = reader.string();
                    break;
                case 7:
                    message.status = reader.int32();
                    break;
                case 8:
                    message.createTime = reader.int64();
                    break;
                case 9:
                    message.needGetStatus = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("orderId"))
                throw $util.ProtocolError("missing required 'orderId'", { instance: message });
            if (!message.hasOwnProperty("payType"))
                throw $util.ProtocolError("missing required 'payType'", { instance: message });
            if (!message.hasOwnProperty("money"))
                throw $util.ProtocolError("missing required 'money'", { instance: message });
            if (!message.hasOwnProperty("payeeRealName"))
                throw $util.ProtocolError("missing required 'payeeRealName'", { instance: message });
            if (!message.hasOwnProperty("payeeAccount"))
                throw $util.ProtocolError("missing required 'payeeAccount'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveExpenseInfoDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveExpenseInfoDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveExpenseInfoDetail} LiveExpenseInfoDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExpenseInfoDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveExpenseInfoDetail;
    })();

    LiveResult.LiveExchangeData = (function() {

        /**
         * Properties of a LiveExchangeData.
         * @memberof LiveResult
         * @interface ILiveExchangeData
         * @property {Array.<LiveResult.ILiveExchangeInfo>|null} [list] LiveExchangeData list
         */

        /**
         * Constructs a new LiveExchangeData.
         * @memberof LiveResult
         * @classdesc Represents a LiveExchangeData.
         * @implements ILiveExchangeData
         * @constructor
         * @param {LiveResult.ILiveExchangeData=} [properties] Properties to set
         */
        function LiveExchangeData(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveExchangeData list.
         * @member {Array.<LiveResult.ILiveExchangeInfo>} list
         * @memberof LiveResult.LiveExchangeData
         * @instance
         */
        LiveExchangeData.prototype.list = $util.emptyArray;

        /**
         * Decodes a LiveExchangeData message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveExchangeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveExchangeData} LiveExchangeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExchangeData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveExchangeData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.LiveResult.LiveExchangeInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LiveExchangeData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveExchangeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveExchangeData} LiveExchangeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExchangeData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveExchangeData;
    })();

    LiveResult.LiveExchangeInfo = (function() {

        /**
         * Properties of a LiveExchangeInfo.
         * @memberof LiveResult
         * @interface ILiveExchangeInfo
         * @property {string} id LiveExchangeInfo id
         * @property {string|null} [rechargeId] LiveExchangeInfo rechargeId
         * @property {number|null} [money] LiveExchangeInfo money
         * @property {number|null} [goldShell] LiveExchangeInfo goldShell
         * @property {number|Long|null} [balance] LiveExchangeInfo balance
         * @property {number|Long|null} [createTime] LiveExchangeInfo createTime
         * @property {number|null} [type] LiveExchangeInfo type
         * @property {string|null} [targetId] LiveExchangeInfo targetId
         * @property {string|null} [targetNickName] LiveExchangeInfo targetNickName
         */

        /**
         * Constructs a new LiveExchangeInfo.
         * @memberof LiveResult
         * @classdesc Represents a LiveExchangeInfo.
         * @implements ILiveExchangeInfo
         * @constructor
         * @param {LiveResult.ILiveExchangeInfo=} [properties] Properties to set
         */
        function LiveExchangeInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveExchangeInfo id.
         * @member {string} id
         * @memberof LiveResult.LiveExchangeInfo
         * @instance
         */
        LiveExchangeInfo.prototype.id = "";

        /**
         * LiveExchangeInfo rechargeId.
         * @member {string} rechargeId
         * @memberof LiveResult.LiveExchangeInfo
         * @instance
         */
        LiveExchangeInfo.prototype.rechargeId = "";

        /**
         * LiveExchangeInfo money.
         * @member {number} money
         * @memberof LiveResult.LiveExchangeInfo
         * @instance
         */
        LiveExchangeInfo.prototype.money = 0;

        /**
         * LiveExchangeInfo goldShell.
         * @member {number} goldShell
         * @memberof LiveResult.LiveExchangeInfo
         * @instance
         */
        LiveExchangeInfo.prototype.goldShell = 0;

        /**
         * LiveExchangeInfo balance.
         * @member {number|Long} balance
         * @memberof LiveResult.LiveExchangeInfo
         * @instance
         */
        LiveExchangeInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveExchangeInfo createTime.
         * @member {number|Long} createTime
         * @memberof LiveResult.LiveExchangeInfo
         * @instance
         */
        LiveExchangeInfo.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveExchangeInfo type.
         * @member {number} type
         * @memberof LiveResult.LiveExchangeInfo
         * @instance
         */
        LiveExchangeInfo.prototype.type = 0;

        /**
         * LiveExchangeInfo targetId.
         * @member {string} targetId
         * @memberof LiveResult.LiveExchangeInfo
         * @instance
         */
        LiveExchangeInfo.prototype.targetId = "";

        /**
         * LiveExchangeInfo targetNickName.
         * @member {string} targetNickName
         * @memberof LiveResult.LiveExchangeInfo
         * @instance
         */
        LiveExchangeInfo.prototype.targetNickName = "";

        /**
         * Decodes a LiveExchangeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveExchangeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveExchangeInfo} LiveExchangeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExchangeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveExchangeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.rechargeId = reader.string();
                    break;
                case 3:
                    message.money = reader.int32();
                    break;
                case 4:
                    message.goldShell = reader.int32();
                    break;
                case 5:
                    message.balance = reader.int64();
                    break;
                case 6:
                    message.createTime = reader.int64();
                    break;
                case 7:
                    message.type = reader.int32();
                    break;
                case 8:
                    message.targetId = reader.string();
                    break;
                case 9:
                    message.targetNickName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveExchangeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveExchangeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveExchangeInfo} LiveExchangeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveExchangeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveExchangeInfo;
    })();

    LiveResult.LiveRoomSendBarrageBroadcast = (function() {

        /**
         * Properties of a LiveRoomSendBarrageBroadcast.
         * @memberof LiveResult
         * @interface ILiveRoomSendBarrageBroadcast
         * @property {string} fromUserId LiveRoomSendBarrageBroadcast fromUserId
         * @property {string} fromNickName LiveRoomSendBarrageBroadcast fromNickName
         * @property {string} barrage LiveRoomSendBarrageBroadcast barrage
         * @property {number|null} [fromCharmlevel] LiveRoomSendBarrageBroadcast fromCharmlevel
         * @property {number|null} [fromLiveLevel] LiveRoomSendBarrageBroadcast fromLiveLevel
         * @property {number|null} [income] LiveRoomSendBarrageBroadcast income
         */

        /**
         * Constructs a new LiveRoomSendBarrageBroadcast.
         * @memberof LiveResult
         * @classdesc Represents a LiveRoomSendBarrageBroadcast.
         * @implements ILiveRoomSendBarrageBroadcast
         * @constructor
         * @param {LiveResult.ILiveRoomSendBarrageBroadcast=} [properties] Properties to set
         */
        function LiveRoomSendBarrageBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveRoomSendBarrageBroadcast fromUserId.
         * @member {string} fromUserId
         * @memberof LiveResult.LiveRoomSendBarrageBroadcast
         * @instance
         */
        LiveRoomSendBarrageBroadcast.prototype.fromUserId = "";

        /**
         * LiveRoomSendBarrageBroadcast fromNickName.
         * @member {string} fromNickName
         * @memberof LiveResult.LiveRoomSendBarrageBroadcast
         * @instance
         */
        LiveRoomSendBarrageBroadcast.prototype.fromNickName = "";

        /**
         * LiveRoomSendBarrageBroadcast barrage.
         * @member {string} barrage
         * @memberof LiveResult.LiveRoomSendBarrageBroadcast
         * @instance
         */
        LiveRoomSendBarrageBroadcast.prototype.barrage = "";

        /**
         * LiveRoomSendBarrageBroadcast fromCharmlevel.
         * @member {number} fromCharmlevel
         * @memberof LiveResult.LiveRoomSendBarrageBroadcast
         * @instance
         */
        LiveRoomSendBarrageBroadcast.prototype.fromCharmlevel = 0;

        /**
         * LiveRoomSendBarrageBroadcast fromLiveLevel.
         * @member {number} fromLiveLevel
         * @memberof LiveResult.LiveRoomSendBarrageBroadcast
         * @instance
         */
        LiveRoomSendBarrageBroadcast.prototype.fromLiveLevel = 0;

        /**
         * LiveRoomSendBarrageBroadcast income.
         * @member {number} income
         * @memberof LiveResult.LiveRoomSendBarrageBroadcast
         * @instance
         */
        LiveRoomSendBarrageBroadcast.prototype.income = 0;

        /**
         * Decodes a LiveRoomSendBarrageBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveRoomSendBarrageBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveRoomSendBarrageBroadcast} LiveRoomSendBarrageBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRoomSendBarrageBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveRoomSendBarrageBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fromUserId = reader.string();
                    break;
                case 2:
                    message.fromNickName = reader.string();
                    break;
                case 3:
                    message.barrage = reader.string();
                    break;
                case 4:
                    message.fromCharmlevel = reader.int32();
                    break;
                case 5:
                    message.fromLiveLevel = reader.int32();
                    break;
                case 6:
                    message.income = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fromUserId"))
                throw $util.ProtocolError("missing required 'fromUserId'", { instance: message });
            if (!message.hasOwnProperty("fromNickName"))
                throw $util.ProtocolError("missing required 'fromNickName'", { instance: message });
            if (!message.hasOwnProperty("barrage"))
                throw $util.ProtocolError("missing required 'barrage'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveRoomSendBarrageBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveRoomSendBarrageBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveRoomSendBarrageBroadcast} LiveRoomSendBarrageBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRoomSendBarrageBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveRoomSendBarrageBroadcast;
    })();

    LiveResult.LiveRoomSendGiftsBroadcast = (function() {

        /**
         * Properties of a LiveRoomSendGiftsBroadcast.
         * @memberof LiveResult
         * @interface ILiveRoomSendGiftsBroadcast
         * @property {UserResult.IUserBase} fromUserBase LiveRoomSendGiftsBroadcast fromUserBase
         * @property {string} giftId LiveRoomSendGiftsBroadcast giftId
         * @property {number} giftNum LiveRoomSendGiftsBroadcast giftNum
         * @property {number|null} [fromCharmLevel] LiveRoomSendGiftsBroadcast fromCharmLevel
         * @property {number|null} [fromContributeLevel] LiveRoomSendGiftsBroadcast fromContributeLevel
         * @property {string|null} [roomId] LiveRoomSendGiftsBroadcast roomId
         * @property {Array.<LiveResult.ILiveRoomGiftReceiverInfo>|null} [receiverInfos] LiveRoomSendGiftsBroadcast receiverInfos
         * @property {number|null} [groupNum] LiveRoomSendGiftsBroadcast groupNum
         * @property {number|null} [charm] LiveRoomSendGiftsBroadcast charm
         * @property {number|null} [broadcastType] LiveRoomSendGiftsBroadcast broadcastType
         * @property {string|null} [roomName] LiveRoomSendGiftsBroadcast roomName
         * @property {string|null} [boxId] LiveRoomSendGiftsBroadcast boxId
         * @property {number|Long|null} [contribute] LiveRoomSendGiftsBroadcast contribute
         * @property {boolean|null} [roomAll] LiveRoomSendGiftsBroadcast roomAll
         * @property {number|Long|null} [newContribute] LiveRoomSendGiftsBroadcast newContribute
         * @property {number|null} [price] LiveRoomSendGiftsBroadcast price
         */

        /**
         * Constructs a new LiveRoomSendGiftsBroadcast.
         * @memberof LiveResult
         * @classdesc Represents a LiveRoomSendGiftsBroadcast.
         * @implements ILiveRoomSendGiftsBroadcast
         * @constructor
         * @param {LiveResult.ILiveRoomSendGiftsBroadcast=} [properties] Properties to set
         */
        function LiveRoomSendGiftsBroadcast(properties) {
            this.receiverInfos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveRoomSendGiftsBroadcast fromUserBase.
         * @member {UserResult.IUserBase} fromUserBase
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.fromUserBase = null;

        /**
         * LiveRoomSendGiftsBroadcast giftId.
         * @member {string} giftId
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.giftId = "";

        /**
         * LiveRoomSendGiftsBroadcast giftNum.
         * @member {number} giftNum
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.giftNum = 0;

        /**
         * LiveRoomSendGiftsBroadcast fromCharmLevel.
         * @member {number} fromCharmLevel
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.fromCharmLevel = 0;

        /**
         * LiveRoomSendGiftsBroadcast fromContributeLevel.
         * @member {number} fromContributeLevel
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.fromContributeLevel = 0;

        /**
         * LiveRoomSendGiftsBroadcast roomId.
         * @member {string} roomId
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.roomId = "";

        /**
         * LiveRoomSendGiftsBroadcast receiverInfos.
         * @member {Array.<LiveResult.ILiveRoomGiftReceiverInfo>} receiverInfos
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.receiverInfos = $util.emptyArray;

        /**
         * LiveRoomSendGiftsBroadcast groupNum.
         * @member {number} groupNum
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.groupNum = 0;

        /**
         * LiveRoomSendGiftsBroadcast charm.
         * @member {number} charm
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.charm = 0;

        /**
         * LiveRoomSendGiftsBroadcast broadcastType.
         * @member {number} broadcastType
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.broadcastType = 0;

        /**
         * LiveRoomSendGiftsBroadcast roomName.
         * @member {string} roomName
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.roomName = "";

        /**
         * LiveRoomSendGiftsBroadcast boxId.
         * @member {string} boxId
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.boxId = "";

        /**
         * LiveRoomSendGiftsBroadcast contribute.
         * @member {number|Long} contribute
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.contribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveRoomSendGiftsBroadcast roomAll.
         * @member {boolean} roomAll
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.roomAll = false;

        /**
         * LiveRoomSendGiftsBroadcast newContribute.
         * @member {number|Long} newContribute
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.newContribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveRoomSendGiftsBroadcast price.
         * @member {number} price
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @instance
         */
        LiveRoomSendGiftsBroadcast.prototype.price = 0;

        /**
         * Decodes a LiveRoomSendGiftsBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveRoomSendGiftsBroadcast} LiveRoomSendGiftsBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRoomSendGiftsBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveRoomSendGiftsBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fromUserBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.giftId = reader.string();
                    break;
                case 3:
                    message.giftNum = reader.int32();
                    break;
                case 4:
                    message.fromCharmLevel = reader.int32();
                    break;
                case 5:
                    message.fromContributeLevel = reader.int32();
                    break;
                case 6:
                    message.roomId = reader.string();
                    break;
                case 7:
                    if (!(message.receiverInfos && message.receiverInfos.length))
                        message.receiverInfos = [];
                    message.receiverInfos.push($root.LiveResult.LiveRoomGiftReceiverInfo.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.groupNum = reader.int32();
                    break;
                case 9:
                    message.charm = reader.int32();
                    break;
                case 10:
                    message.broadcastType = reader.int32();
                    break;
                case 11:
                    message.roomName = reader.string();
                    break;
                case 12:
                    message.boxId = reader.string();
                    break;
                case 13:
                    message.contribute = reader.int64();
                    break;
                case 14:
                    message.roomAll = reader.bool();
                    break;
                case 15:
                    message.newContribute = reader.int64();
                    break;
                case 16:
                    message.price = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fromUserBase"))
                throw $util.ProtocolError("missing required 'fromUserBase'", { instance: message });
            if (!message.hasOwnProperty("giftId"))
                throw $util.ProtocolError("missing required 'giftId'", { instance: message });
            if (!message.hasOwnProperty("giftNum"))
                throw $util.ProtocolError("missing required 'giftNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveRoomSendGiftsBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveRoomSendGiftsBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveRoomSendGiftsBroadcast} LiveRoomSendGiftsBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRoomSendGiftsBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveRoomSendGiftsBroadcast;
    })();

    LiveResult.LiveRoomGiftReceiverInfo = (function() {

        /**
         * Properties of a LiveRoomGiftReceiverInfo.
         * @memberof LiveResult
         * @interface ILiveRoomGiftReceiverInfo
         * @property {string} toUserId LiveRoomGiftReceiverInfo toUserId
         * @property {string} toNickName LiveRoomGiftReceiverInfo toNickName
         * @property {number|null} [toCharmLevel] LiveRoomGiftReceiverInfo toCharmLevel
         * @property {number|null} [toContributeLevel] LiveRoomGiftReceiverInfo toContributeLevel
         * @property {number|Long|null} [toHeartValue] LiveRoomGiftReceiverInfo toHeartValue
         * @property {number|null} [toSex] LiveRoomGiftReceiverInfo toSex
         */

        /**
         * Constructs a new LiveRoomGiftReceiverInfo.
         * @memberof LiveResult
         * @classdesc Represents a LiveRoomGiftReceiverInfo.
         * @implements ILiveRoomGiftReceiverInfo
         * @constructor
         * @param {LiveResult.ILiveRoomGiftReceiverInfo=} [properties] Properties to set
         */
        function LiveRoomGiftReceiverInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveRoomGiftReceiverInfo toUserId.
         * @member {string} toUserId
         * @memberof LiveResult.LiveRoomGiftReceiverInfo
         * @instance
         */
        LiveRoomGiftReceiverInfo.prototype.toUserId = "";

        /**
         * LiveRoomGiftReceiverInfo toNickName.
         * @member {string} toNickName
         * @memberof LiveResult.LiveRoomGiftReceiverInfo
         * @instance
         */
        LiveRoomGiftReceiverInfo.prototype.toNickName = "";

        /**
         * LiveRoomGiftReceiverInfo toCharmLevel.
         * @member {number} toCharmLevel
         * @memberof LiveResult.LiveRoomGiftReceiverInfo
         * @instance
         */
        LiveRoomGiftReceiverInfo.prototype.toCharmLevel = 0;

        /**
         * LiveRoomGiftReceiverInfo toContributeLevel.
         * @member {number} toContributeLevel
         * @memberof LiveResult.LiveRoomGiftReceiverInfo
         * @instance
         */
        LiveRoomGiftReceiverInfo.prototype.toContributeLevel = 0;

        /**
         * LiveRoomGiftReceiverInfo toHeartValue.
         * @member {number|Long} toHeartValue
         * @memberof LiveResult.LiveRoomGiftReceiverInfo
         * @instance
         */
        LiveRoomGiftReceiverInfo.prototype.toHeartValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveRoomGiftReceiverInfo toSex.
         * @member {number} toSex
         * @memberof LiveResult.LiveRoomGiftReceiverInfo
         * @instance
         */
        LiveRoomGiftReceiverInfo.prototype.toSex = 0;

        /**
         * Decodes a LiveRoomGiftReceiverInfo message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveRoomGiftReceiverInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveRoomGiftReceiverInfo} LiveRoomGiftReceiverInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRoomGiftReceiverInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveRoomGiftReceiverInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.toUserId = reader.string();
                    break;
                case 2:
                    message.toNickName = reader.string();
                    break;
                case 3:
                    message.toCharmLevel = reader.int32();
                    break;
                case 4:
                    message.toContributeLevel = reader.int32();
                    break;
                case 5:
                    message.toHeartValue = reader.int64();
                    break;
                case 6:
                    message.toSex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("toUserId"))
                throw $util.ProtocolError("missing required 'toUserId'", { instance: message });
            if (!message.hasOwnProperty("toNickName"))
                throw $util.ProtocolError("missing required 'toNickName'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveRoomGiftReceiverInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveRoomGiftReceiverInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveRoomGiftReceiverInfo} LiveRoomGiftReceiverInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveRoomGiftReceiverInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveRoomGiftReceiverInfo;
    })();

    LiveResult.LiveData = (function() {

        /**
         * Properties of a LiveData.
         * @memberof LiveResult
         * @interface ILiveData
         * @property {number|Long} dayLiveRecv LiveData dayLiveRecv
         * @property {number|Long} dayLiveEarn LiveData dayLiveEarn
         * @property {number|Long} totalLiveEarn LiveData totalLiveEarn
         * @property {number|Long} weekLiveEarn LiveData weekLiveEarn
         * @property {number|Long} balance LiveData balance
         * @property {number|Long|null} [totalLiveRecv] LiveData totalLiveRecv
         * @property {number|Long|null} [dayBaseSalary] LiveData dayBaseSalary
         * @property {number|Long|null} [monthBaseSalary] LiveData monthBaseSalary
         * @property {number|Long|null} [monthLiveRecv] LiveData monthLiveRecv
         * @property {number|Long|null} [dayBaseEarn] LiveData dayBaseEarn
         * @property {number|Long|null} [dayRewardEarn] LiveData dayRewardEarn
         * @property {number|Long|null} [dayChatRecv] LiveData dayChatRecv
         * @property {number|Long|null} [dayChatEarn] LiveData dayChatEarn
         */

        /**
         * Constructs a new LiveData.
         * @memberof LiveResult
         * @classdesc Represents a LiveData.
         * @implements ILiveData
         * @constructor
         * @param {LiveResult.ILiveData=} [properties] Properties to set
         */
        function LiveData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveData dayLiveRecv.
         * @member {number|Long} dayLiveRecv
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.dayLiveRecv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData dayLiveEarn.
         * @member {number|Long} dayLiveEarn
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.dayLiveEarn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData totalLiveEarn.
         * @member {number|Long} totalLiveEarn
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.totalLiveEarn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData weekLiveEarn.
         * @member {number|Long} weekLiveEarn
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.weekLiveEarn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData balance.
         * @member {number|Long} balance
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData totalLiveRecv.
         * @member {number|Long} totalLiveRecv
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.totalLiveRecv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData dayBaseSalary.
         * @member {number|Long} dayBaseSalary
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.dayBaseSalary = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData monthBaseSalary.
         * @member {number|Long} monthBaseSalary
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.monthBaseSalary = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData monthLiveRecv.
         * @member {number|Long} monthLiveRecv
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.monthLiveRecv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData dayBaseEarn.
         * @member {number|Long} dayBaseEarn
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.dayBaseEarn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData dayRewardEarn.
         * @member {number|Long} dayRewardEarn
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.dayRewardEarn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData dayChatRecv.
         * @member {number|Long} dayChatRecv
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.dayChatRecv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveData dayChatEarn.
         * @member {number|Long} dayChatEarn
         * @memberof LiveResult.LiveData
         * @instance
         */
        LiveData.prototype.dayChatEarn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a LiveData message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveData} LiveData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dayLiveRecv = reader.int64();
                    break;
                case 2:
                    message.dayLiveEarn = reader.int64();
                    break;
                case 3:
                    message.totalLiveEarn = reader.int64();
                    break;
                case 4:
                    message.weekLiveEarn = reader.int64();
                    break;
                case 5:
                    message.balance = reader.int64();
                    break;
                case 6:
                    message.totalLiveRecv = reader.int64();
                    break;
                case 7:
                    message.dayBaseSalary = reader.int64();
                    break;
                case 8:
                    message.monthBaseSalary = reader.int64();
                    break;
                case 9:
                    message.monthLiveRecv = reader.int64();
                    break;
                case 10:
                    message.dayBaseEarn = reader.int64();
                    break;
                case 11:
                    message.dayRewardEarn = reader.int64();
                    break;
                case 12:
                    message.dayChatRecv = reader.int64();
                    break;
                case 13:
                    message.dayChatEarn = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("dayLiveRecv"))
                throw $util.ProtocolError("missing required 'dayLiveRecv'", { instance: message });
            if (!message.hasOwnProperty("dayLiveEarn"))
                throw $util.ProtocolError("missing required 'dayLiveEarn'", { instance: message });
            if (!message.hasOwnProperty("totalLiveEarn"))
                throw $util.ProtocolError("missing required 'totalLiveEarn'", { instance: message });
            if (!message.hasOwnProperty("weekLiveEarn"))
                throw $util.ProtocolError("missing required 'weekLiveEarn'", { instance: message });
            if (!message.hasOwnProperty("balance"))
                throw $util.ProtocolError("missing required 'balance'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveData} LiveData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveData;
    })();

    LiveResult.LiveInfo = (function() {

        /**
         * Properties of a LiveInfo.
         * @memberof LiveResult
         * @interface ILiveInfo
         * @property {string} userId LiveInfo userId
         * @property {boolean} isCertification LiveInfo isCertification
         * @property {number} matchmakerStatus LiveInfo matchmakerStatus
         * @property {number} anchorStatus LiveInfo anchorStatus
         * @property {number} certificationSex LiveInfo certificationSex
         */

        /**
         * Constructs a new LiveInfo.
         * @memberof LiveResult
         * @classdesc Represents a LiveInfo.
         * @implements ILiveInfo
         * @constructor
         * @param {LiveResult.ILiveInfo=} [properties] Properties to set
         */
        function LiveInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveInfo userId.
         * @member {string} userId
         * @memberof LiveResult.LiveInfo
         * @instance
         */
        LiveInfo.prototype.userId = "";

        /**
         * LiveInfo isCertification.
         * @member {boolean} isCertification
         * @memberof LiveResult.LiveInfo
         * @instance
         */
        LiveInfo.prototype.isCertification = false;

        /**
         * LiveInfo matchmakerStatus.
         * @member {number} matchmakerStatus
         * @memberof LiveResult.LiveInfo
         * @instance
         */
        LiveInfo.prototype.matchmakerStatus = 0;

        /**
         * LiveInfo anchorStatus.
         * @member {number} anchorStatus
         * @memberof LiveResult.LiveInfo
         * @instance
         */
        LiveInfo.prototype.anchorStatus = 0;

        /**
         * LiveInfo certificationSex.
         * @member {number} certificationSex
         * @memberof LiveResult.LiveInfo
         * @instance
         */
        LiveInfo.prototype.certificationSex = 0;

        /**
         * Decodes a LiveInfo message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveInfo} LiveInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.isCertification = reader.bool();
                    break;
                case 3:
                    message.matchmakerStatus = reader.int32();
                    break;
                case 4:
                    message.anchorStatus = reader.int32();
                    break;
                case 5:
                    message.certificationSex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("isCertification"))
                throw $util.ProtocolError("missing required 'isCertification'", { instance: message });
            if (!message.hasOwnProperty("matchmakerStatus"))
                throw $util.ProtocolError("missing required 'matchmakerStatus'", { instance: message });
            if (!message.hasOwnProperty("anchorStatus"))
                throw $util.ProtocolError("missing required 'anchorStatus'", { instance: message });
            if (!message.hasOwnProperty("certificationSex"))
                throw $util.ProtocolError("missing required 'certificationSex'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveInfo} LiveInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveInfo;
    })();

    LiveResult.ApplyMatchmakerTask = (function() {

        /**
         * Properties of an ApplyMatchmakerTask.
         * @memberof LiveResult
         * @interface IApplyMatchmakerTask
         * @property {number|Long} onMicTime ApplyMatchmakerTask onMicTime
         * @property {number|Long} inviteFemaleOnMicTime ApplyMatchmakerTask inviteFemaleOnMicTime
         */

        /**
         * Constructs a new ApplyMatchmakerTask.
         * @memberof LiveResult
         * @classdesc Represents an ApplyMatchmakerTask.
         * @implements IApplyMatchmakerTask
         * @constructor
         * @param {LiveResult.IApplyMatchmakerTask=} [properties] Properties to set
         */
        function ApplyMatchmakerTask(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplyMatchmakerTask onMicTime.
         * @member {number|Long} onMicTime
         * @memberof LiveResult.ApplyMatchmakerTask
         * @instance
         */
        ApplyMatchmakerTask.prototype.onMicTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ApplyMatchmakerTask inviteFemaleOnMicTime.
         * @member {number|Long} inviteFemaleOnMicTime
         * @memberof LiveResult.ApplyMatchmakerTask
         * @instance
         */
        ApplyMatchmakerTask.prototype.inviteFemaleOnMicTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes an ApplyMatchmakerTask message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.ApplyMatchmakerTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.ApplyMatchmakerTask} ApplyMatchmakerTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplyMatchmakerTask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.ApplyMatchmakerTask();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.onMicTime = reader.int64();
                    break;
                case 2:
                    message.inviteFemaleOnMicTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("onMicTime"))
                throw $util.ProtocolError("missing required 'onMicTime'", { instance: message });
            if (!message.hasOwnProperty("inviteFemaleOnMicTime"))
                throw $util.ProtocolError("missing required 'inviteFemaleOnMicTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an ApplyMatchmakerTask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.ApplyMatchmakerTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.ApplyMatchmakerTask} ApplyMatchmakerTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplyMatchmakerTask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ApplyMatchmakerTask;
    })();

    LiveResult.LiveEarningList = (function() {

        /**
         * Properties of a LiveEarningList.
         * @memberof LiveResult
         * @interface ILiveEarningList
         * @property {Array.<LiveResult.ILiveEarning>|null} [list] LiveEarningList list
         * @property {number|Long} total LiveEarningList total
         */

        /**
         * Constructs a new LiveEarningList.
         * @memberof LiveResult
         * @classdesc Represents a LiveEarningList.
         * @implements ILiveEarningList
         * @constructor
         * @param {LiveResult.ILiveEarningList=} [properties] Properties to set
         */
        function LiveEarningList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveEarningList list.
         * @member {Array.<LiveResult.ILiveEarning>} list
         * @memberof LiveResult.LiveEarningList
         * @instance
         */
        LiveEarningList.prototype.list = $util.emptyArray;

        /**
         * LiveEarningList total.
         * @member {number|Long} total
         * @memberof LiveResult.LiveEarningList
         * @instance
         */
        LiveEarningList.prototype.total = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a LiveEarningList message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveEarningList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveEarningList} LiveEarningList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveEarningList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveEarningList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.LiveResult.LiveEarning.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.total = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("total"))
                throw $util.ProtocolError("missing required 'total'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveEarningList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveEarningList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveEarningList} LiveEarningList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveEarningList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveEarningList;
    })();

    LiveResult.LiveEarning = (function() {

        /**
         * Properties of a LiveEarning.
         * @memberof LiveResult
         * @interface ILiveEarning
         * @property {string} id LiveEarning id
         * @property {string} recordDate LiveEarning recordDate
         * @property {number|Long} money LiveEarning money
         */

        /**
         * Constructs a new LiveEarning.
         * @memberof LiveResult
         * @classdesc Represents a LiveEarning.
         * @implements ILiveEarning
         * @constructor
         * @param {LiveResult.ILiveEarning=} [properties] Properties to set
         */
        function LiveEarning(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveEarning id.
         * @member {string} id
         * @memberof LiveResult.LiveEarning
         * @instance
         */
        LiveEarning.prototype.id = "";

        /**
         * LiveEarning recordDate.
         * @member {string} recordDate
         * @memberof LiveResult.LiveEarning
         * @instance
         */
        LiveEarning.prototype.recordDate = "";

        /**
         * LiveEarning money.
         * @member {number|Long} money
         * @memberof LiveResult.LiveEarning
         * @instance
         */
        LiveEarning.prototype.money = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a LiveEarning message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveEarning
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveEarning} LiveEarning
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveEarning.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveEarning();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.recordDate = reader.string();
                    break;
                case 3:
                    message.money = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("recordDate"))
                throw $util.ProtocolError("missing required 'recordDate'", { instance: message });
            if (!message.hasOwnProperty("money"))
                throw $util.ProtocolError("missing required 'money'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveEarning message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveEarning
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveEarning} LiveEarning
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveEarning.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveEarning;
    })();

    LiveResult.LiveFamilyAnchorList = (function() {

        /**
         * Properties of a LiveFamilyAnchorList.
         * @memberof LiveResult
         * @interface ILiveFamilyAnchorList
         * @property {Array.<LiveResult.ILiveFamilyAnchor>|null} [anchor] LiveFamilyAnchorList anchor
         */

        /**
         * Constructs a new LiveFamilyAnchorList.
         * @memberof LiveResult
         * @classdesc Represents a LiveFamilyAnchorList.
         * @implements ILiveFamilyAnchorList
         * @constructor
         * @param {LiveResult.ILiveFamilyAnchorList=} [properties] Properties to set
         */
        function LiveFamilyAnchorList(properties) {
            this.anchor = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveFamilyAnchorList anchor.
         * @member {Array.<LiveResult.ILiveFamilyAnchor>} anchor
         * @memberof LiveResult.LiveFamilyAnchorList
         * @instance
         */
        LiveFamilyAnchorList.prototype.anchor = $util.emptyArray;

        /**
         * Decodes a LiveFamilyAnchorList message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveFamilyAnchorList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveFamilyAnchorList} LiveFamilyAnchorList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveFamilyAnchorList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveFamilyAnchorList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.anchor && message.anchor.length))
                        message.anchor = [];
                    message.anchor.push($root.LiveResult.LiveFamilyAnchor.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LiveFamilyAnchorList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveFamilyAnchorList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveFamilyAnchorList} LiveFamilyAnchorList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveFamilyAnchorList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveFamilyAnchorList;
    })();

    LiveResult.LiveFamilyAnchor = (function() {

        /**
         * Properties of a LiveFamilyAnchor.
         * @memberof LiveResult
         * @interface ILiveFamilyAnchor
         * @property {UserResult.IUserBase} anchor LiveFamilyAnchor anchor
         * @property {string} familyId LiveFamilyAnchor familyId
         * @property {string|null} [contacts] LiveFamilyAnchor contacts
         * @property {number} anchorType LiveFamilyAnchor anchorType
         * @property {number} signYears LiveFamilyAnchor signYears
         * @property {string|null} [qq] LiveFamilyAnchor qq
         * @property {string|null} [idCard] LiveFamilyAnchor idCard
         * @property {number} status LiveFamilyAnchor status
         * @property {string} applyDate LiveFamilyAnchor applyDate
         * @property {string} id LiveFamilyAnchor id
         */

        /**
         * Constructs a new LiveFamilyAnchor.
         * @memberof LiveResult
         * @classdesc Represents a LiveFamilyAnchor.
         * @implements ILiveFamilyAnchor
         * @constructor
         * @param {LiveResult.ILiveFamilyAnchor=} [properties] Properties to set
         */
        function LiveFamilyAnchor(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveFamilyAnchor anchor.
         * @member {UserResult.IUserBase} anchor
         * @memberof LiveResult.LiveFamilyAnchor
         * @instance
         */
        LiveFamilyAnchor.prototype.anchor = null;

        /**
         * LiveFamilyAnchor familyId.
         * @member {string} familyId
         * @memberof LiveResult.LiveFamilyAnchor
         * @instance
         */
        LiveFamilyAnchor.prototype.familyId = "";

        /**
         * LiveFamilyAnchor contacts.
         * @member {string} contacts
         * @memberof LiveResult.LiveFamilyAnchor
         * @instance
         */
        LiveFamilyAnchor.prototype.contacts = "";

        /**
         * LiveFamilyAnchor anchorType.
         * @member {number} anchorType
         * @memberof LiveResult.LiveFamilyAnchor
         * @instance
         */
        LiveFamilyAnchor.prototype.anchorType = 0;

        /**
         * LiveFamilyAnchor signYears.
         * @member {number} signYears
         * @memberof LiveResult.LiveFamilyAnchor
         * @instance
         */
        LiveFamilyAnchor.prototype.signYears = 0;

        /**
         * LiveFamilyAnchor qq.
         * @member {string} qq
         * @memberof LiveResult.LiveFamilyAnchor
         * @instance
         */
        LiveFamilyAnchor.prototype.qq = "";

        /**
         * LiveFamilyAnchor idCard.
         * @member {string} idCard
         * @memberof LiveResult.LiveFamilyAnchor
         * @instance
         */
        LiveFamilyAnchor.prototype.idCard = "";

        /**
         * LiveFamilyAnchor status.
         * @member {number} status
         * @memberof LiveResult.LiveFamilyAnchor
         * @instance
         */
        LiveFamilyAnchor.prototype.status = 0;

        /**
         * LiveFamilyAnchor applyDate.
         * @member {string} applyDate
         * @memberof LiveResult.LiveFamilyAnchor
         * @instance
         */
        LiveFamilyAnchor.prototype.applyDate = "";

        /**
         * LiveFamilyAnchor id.
         * @member {string} id
         * @memberof LiveResult.LiveFamilyAnchor
         * @instance
         */
        LiveFamilyAnchor.prototype.id = "";

        /**
         * Decodes a LiveFamilyAnchor message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.LiveFamilyAnchor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.LiveFamilyAnchor} LiveFamilyAnchor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveFamilyAnchor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.LiveFamilyAnchor();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.anchor = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.familyId = reader.string();
                    break;
                case 3:
                    message.contacts = reader.string();
                    break;
                case 4:
                    message.anchorType = reader.int32();
                    break;
                case 5:
                    message.signYears = reader.int32();
                    break;
                case 6:
                    message.qq = reader.string();
                    break;
                case 7:
                    message.idCard = reader.string();
                    break;
                case 8:
                    message.status = reader.int32();
                    break;
                case 9:
                    message.applyDate = reader.string();
                    break;
                case 10:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("anchor"))
                throw $util.ProtocolError("missing required 'anchor'", { instance: message });
            if (!message.hasOwnProperty("familyId"))
                throw $util.ProtocolError("missing required 'familyId'", { instance: message });
            if (!message.hasOwnProperty("anchorType"))
                throw $util.ProtocolError("missing required 'anchorType'", { instance: message });
            if (!message.hasOwnProperty("signYears"))
                throw $util.ProtocolError("missing required 'signYears'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            if (!message.hasOwnProperty("applyDate"))
                throw $util.ProtocolError("missing required 'applyDate'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveFamilyAnchor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.LiveFamilyAnchor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.LiveFamilyAnchor} LiveFamilyAnchor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveFamilyAnchor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveFamilyAnchor;
    })();

    LiveResult.joinPayExpenseResult = (function() {

        /**
         * Properties of a joinPayExpenseResult.
         * @memberof LiveResult
         * @interface IjoinPayExpenseResult
         * @property {number} state joinPayExpenseResult state
         * @property {string|null} [message] joinPayExpenseResult message
         */

        /**
         * Constructs a new joinPayExpenseResult.
         * @memberof LiveResult
         * @classdesc Represents a joinPayExpenseResult.
         * @implements IjoinPayExpenseResult
         * @constructor
         * @param {LiveResult.IjoinPayExpenseResult=} [properties] Properties to set
         */
        function joinPayExpenseResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * joinPayExpenseResult state.
         * @member {number} state
         * @memberof LiveResult.joinPayExpenseResult
         * @instance
         */
        joinPayExpenseResult.prototype.state = 0;

        /**
         * joinPayExpenseResult message.
         * @member {string} message
         * @memberof LiveResult.joinPayExpenseResult
         * @instance
         */
        joinPayExpenseResult.prototype.message = "";

        /**
         * Decodes a joinPayExpenseResult message from the specified reader or buffer.
         * @function decode
         * @memberof LiveResult.joinPayExpenseResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LiveResult.joinPayExpenseResult} joinPayExpenseResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        joinPayExpenseResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveResult.joinPayExpenseResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("state"))
                throw $util.ProtocolError("missing required 'state'", { instance: message });
            return message;
        };

        /**
         * Decodes a joinPayExpenseResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LiveResult.joinPayExpenseResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LiveResult.joinPayExpenseResult} joinPayExpenseResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        joinPayExpenseResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return joinPayExpenseResult;
    })();

    return LiveResult;
})();

export const MessageResult = $root.MessageResult = (() => {

    /**
     * Namespace MessageResult.
     * @exports MessageResult
     * @namespace
     */
    const MessageResult = {};

    MessageResult.ShowMessageBroadcast = (function() {

        /**
         * Properties of a ShowMessageBroadcast.
         * @memberof MessageResult
         * @interface IShowMessageBroadcast
         * @property {string|null} [msgId] ShowMessageBroadcast msgId
         * @property {Array.<string>|null} [msgParams] ShowMessageBroadcast msgParams
         */

        /**
         * Constructs a new ShowMessageBroadcast.
         * @memberof MessageResult
         * @classdesc Represents a ShowMessageBroadcast.
         * @implements IShowMessageBroadcast
         * @constructor
         * @param {MessageResult.IShowMessageBroadcast=} [properties] Properties to set
         */
        function ShowMessageBroadcast(properties) {
            this.msgParams = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShowMessageBroadcast msgId.
         * @member {string} msgId
         * @memberof MessageResult.ShowMessageBroadcast
         * @instance
         */
        ShowMessageBroadcast.prototype.msgId = "";

        /**
         * ShowMessageBroadcast msgParams.
         * @member {Array.<string>} msgParams
         * @memberof MessageResult.ShowMessageBroadcast
         * @instance
         */
        ShowMessageBroadcast.prototype.msgParams = $util.emptyArray;

        /**
         * Decodes a ShowMessageBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof MessageResult.ShowMessageBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MessageResult.ShowMessageBroadcast} ShowMessageBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShowMessageBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageResult.ShowMessageBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msgId = reader.string();
                    break;
                case 2:
                    if (!(message.msgParams && message.msgParams.length))
                        message.msgParams = [];
                    message.msgParams.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShowMessageBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MessageResult.ShowMessageBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MessageResult.ShowMessageBroadcast} ShowMessageBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShowMessageBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ShowMessageBroadcast;
    })();

    return MessageResult;
})();

export const MomentResult = $root.MomentResult = (() => {

    /**
     * Namespace MomentResult.
     * @exports MomentResult
     * @namespace
     */
    const MomentResult = {};

    MomentResult.SquareMomentVOs = (function() {

        /**
         * Properties of a SquareMomentVOs.
         * @memberof MomentResult
         * @interface ISquareMomentVOs
         * @property {Array.<MomentResult.ISquareMomentVO>|null} [squareMomentVO] SquareMomentVOs squareMomentVO
         */

        /**
         * Constructs a new SquareMomentVOs.
         * @memberof MomentResult
         * @classdesc Represents a SquareMomentVOs.
         * @implements ISquareMomentVOs
         * @constructor
         * @param {MomentResult.ISquareMomentVOs=} [properties] Properties to set
         */
        function SquareMomentVOs(properties) {
            this.squareMomentVO = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SquareMomentVOs squareMomentVO.
         * @member {Array.<MomentResult.ISquareMomentVO>} squareMomentVO
         * @memberof MomentResult.SquareMomentVOs
         * @instance
         */
        SquareMomentVOs.prototype.squareMomentVO = $util.emptyArray;

        /**
         * Decodes a SquareMomentVOs message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.SquareMomentVOs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.SquareMomentVOs} SquareMomentVOs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SquareMomentVOs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.SquareMomentVOs();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.squareMomentVO && message.squareMomentVO.length))
                        message.squareMomentVO = [];
                    message.squareMomentVO.push($root.MomentResult.SquareMomentVO.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SquareMomentVOs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.SquareMomentVOs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.SquareMomentVOs} SquareMomentVOs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SquareMomentVOs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SquareMomentVOs;
    })();

    MomentResult.SquareMomentVO = (function() {

        /**
         * Properties of a SquareMomentVO.
         * @memberof MomentResult
         * @interface ISquareMomentVO
         * @property {UserResult.IUserBase|null} [userBase] SquareMomentVO userBase
         * @property {MomentResult.IMomentVO|null} [moments] SquareMomentVO moments
         * @property {MomentResult.IMomentChangeData|null} [changes] SquareMomentVO changes
         * @property {number|null} [index] SquareMomentVO index
         * @property {CommentResult.ICommentVO|null} [heatComment] SquareMomentVO heatComment
         * @property {string|null} [label] SquareMomentVO label
         */

        /**
         * Constructs a new SquareMomentVO.
         * @memberof MomentResult
         * @classdesc Represents a SquareMomentVO.
         * @implements ISquareMomentVO
         * @constructor
         * @param {MomentResult.ISquareMomentVO=} [properties] Properties to set
         */
        function SquareMomentVO(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SquareMomentVO userBase.
         * @member {UserResult.IUserBase|null|undefined} userBase
         * @memberof MomentResult.SquareMomentVO
         * @instance
         */
        SquareMomentVO.prototype.userBase = null;

        /**
         * SquareMomentVO moments.
         * @member {MomentResult.IMomentVO|null|undefined} moments
         * @memberof MomentResult.SquareMomentVO
         * @instance
         */
        SquareMomentVO.prototype.moments = null;

        /**
         * SquareMomentVO changes.
         * @member {MomentResult.IMomentChangeData|null|undefined} changes
         * @memberof MomentResult.SquareMomentVO
         * @instance
         */
        SquareMomentVO.prototype.changes = null;

        /**
         * SquareMomentVO index.
         * @member {number} index
         * @memberof MomentResult.SquareMomentVO
         * @instance
         */
        SquareMomentVO.prototype.index = 0;

        /**
         * SquareMomentVO heatComment.
         * @member {CommentResult.ICommentVO|null|undefined} heatComment
         * @memberof MomentResult.SquareMomentVO
         * @instance
         */
        SquareMomentVO.prototype.heatComment = null;

        /**
         * SquareMomentVO label.
         * @member {string} label
         * @memberof MomentResult.SquareMomentVO
         * @instance
         */
        SquareMomentVO.prototype.label = "";

        /**
         * Decodes a SquareMomentVO message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.SquareMomentVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.SquareMomentVO} SquareMomentVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SquareMomentVO.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.SquareMomentVO();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.moments = $root.MomentResult.MomentVO.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.changes = $root.MomentResult.MomentChangeData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.index = reader.int32();
                    break;
                case 5:
                    message.heatComment = $root.CommentResult.CommentVO.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.label = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SquareMomentVO message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.SquareMomentVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.SquareMomentVO} SquareMomentVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SquareMomentVO.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SquareMomentVO;
    })();

    MomentResult.MomentVOS = (function() {

        /**
         * Properties of a MomentVOS.
         * @memberof MomentResult
         * @interface IMomentVOS
         * @property {Array.<MomentResult.IMomentVO>|null} [moments] MomentVOS moments
         * @property {Array.<MomentResult.IMomentChangeData>|null} [changes] MomentVOS changes
         */

        /**
         * Constructs a new MomentVOS.
         * @memberof MomentResult
         * @classdesc Represents a MomentVOS.
         * @implements IMomentVOS
         * @constructor
         * @param {MomentResult.IMomentVOS=} [properties] Properties to set
         */
        function MomentVOS(properties) {
            this.moments = [];
            this.changes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MomentVOS moments.
         * @member {Array.<MomentResult.IMomentVO>} moments
         * @memberof MomentResult.MomentVOS
         * @instance
         */
        MomentVOS.prototype.moments = $util.emptyArray;

        /**
         * MomentVOS changes.
         * @member {Array.<MomentResult.IMomentChangeData>} changes
         * @memberof MomentResult.MomentVOS
         * @instance
         */
        MomentVOS.prototype.changes = $util.emptyArray;

        /**
         * Decodes a MomentVOS message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.MomentVOS
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.MomentVOS} MomentVOS
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentVOS.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.MomentVOS();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.moments && message.moments.length))
                        message.moments = [];
                    message.moments.push($root.MomentResult.MomentVO.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.changes && message.changes.length))
                        message.changes = [];
                    message.changes.push($root.MomentResult.MomentChangeData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MomentVOS message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.MomentVOS
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.MomentVOS} MomentVOS
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentVOS.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MomentVOS;
    })();

    MomentResult.MomentVO = (function() {

        /**
         * Properties of a MomentVO.
         * @memberof MomentResult
         * @interface IMomentVO
         * @property {string} id MomentVO id
         * @property {string} userId MomentVO userId
         * @property {string|null} [word] MomentVO word
         * @property {string|null} [location] MomentVO location
         * @property {string|null} [topic] MomentVO topic
         * @property {number|null} [watches] MomentVO watches
         * @property {number|null} [likes] MomentVO likes
         * @property {number|null} [comments] MomentVO comments
         * @property {number|Long|null} [issueTime] MomentVO issueTime
         * @property {number|null} [version] MomentVO version
         * @property {number|null} [contType] MomentVO contType
         * @property {boolean|null} [isDeleted] MomentVO isDeleted
         * @property {number|null} [onceComments] MomentVO onceComments
         * @property {boolean|null} [isHot] MomentVO isHot
         * @property {number|null} [lng] MomentVO lng
         * @property {number|null} [lat] MomentVO lat
         * @property {number|null} [shares] MomentVO shares
         * @property {string|null} [cityCode] MomentVO cityCode
         * @property {Array.<MomentResult.IMomentMedia>|null} [mediaList] MomentVO mediaList
         * @property {string|null} [topicName] MomentVO topicName
         */

        /**
         * Constructs a new MomentVO.
         * @memberof MomentResult
         * @classdesc Represents a MomentVO.
         * @implements IMomentVO
         * @constructor
         * @param {MomentResult.IMomentVO=} [properties] Properties to set
         */
        function MomentVO(properties) {
            this.mediaList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MomentVO id.
         * @member {string} id
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.id = "";

        /**
         * MomentVO userId.
         * @member {string} userId
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.userId = "";

        /**
         * MomentVO word.
         * @member {string} word
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.word = "";

        /**
         * MomentVO location.
         * @member {string} location
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.location = "";

        /**
         * MomentVO topic.
         * @member {string} topic
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.topic = "";

        /**
         * MomentVO watches.
         * @member {number} watches
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.watches = 0;

        /**
         * MomentVO likes.
         * @member {number} likes
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.likes = 0;

        /**
         * MomentVO comments.
         * @member {number} comments
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.comments = 0;

        /**
         * MomentVO issueTime.
         * @member {number|Long} issueTime
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.issueTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MomentVO version.
         * @member {number} version
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.version = 0;

        /**
         * MomentVO contType.
         * @member {number} contType
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.contType = 0;

        /**
         * MomentVO isDeleted.
         * @member {boolean} isDeleted
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.isDeleted = false;

        /**
         * MomentVO onceComments.
         * @member {number} onceComments
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.onceComments = 0;

        /**
         * MomentVO isHot.
         * @member {boolean} isHot
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.isHot = false;

        /**
         * MomentVO lng.
         * @member {number} lng
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.lng = 0;

        /**
         * MomentVO lat.
         * @member {number} lat
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.lat = 0;

        /**
         * MomentVO shares.
         * @member {number} shares
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.shares = 0;

        /**
         * MomentVO cityCode.
         * @member {string} cityCode
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.cityCode = "";

        /**
         * MomentVO mediaList.
         * @member {Array.<MomentResult.IMomentMedia>} mediaList
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.mediaList = $util.emptyArray;

        /**
         * MomentVO topicName.
         * @member {string} topicName
         * @memberof MomentResult.MomentVO
         * @instance
         */
        MomentVO.prototype.topicName = "";

        /**
         * Decodes a MomentVO message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.MomentVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.MomentVO} MomentVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentVO.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.MomentVO();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.word = reader.string();
                    break;
                case 4:
                    message.location = reader.string();
                    break;
                case 5:
                    message.topic = reader.string();
                    break;
                case 6:
                    message.watches = reader.int32();
                    break;
                case 7:
                    message.likes = reader.int32();
                    break;
                case 8:
                    message.comments = reader.int32();
                    break;
                case 9:
                    message.issueTime = reader.int64();
                    break;
                case 10:
                    message.version = reader.int32();
                    break;
                case 11:
                    message.contType = reader.int32();
                    break;
                case 12:
                    message.isDeleted = reader.bool();
                    break;
                case 13:
                    message.onceComments = reader.int32();
                    break;
                case 14:
                    message.isHot = reader.bool();
                    break;
                case 15:
                    message.lng = reader.double();
                    break;
                case 16:
                    message.lat = reader.double();
                    break;
                case 17:
                    message.shares = reader.int32();
                    break;
                case 18:
                    message.cityCode = reader.string();
                    break;
                case 19:
                    if (!(message.mediaList && message.mediaList.length))
                        message.mediaList = [];
                    message.mediaList.push($root.MomentResult.MomentMedia.decode(reader, reader.uint32()));
                    break;
                case 20:
                    message.topicName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            return message;
        };

        /**
         * Decodes a MomentVO message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.MomentVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.MomentVO} MomentVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentVO.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MomentVO;
    })();

    MomentResult.MomentChangeData = (function() {

        /**
         * Properties of a MomentChangeData.
         * @memberof MomentResult
         * @interface IMomentChangeData
         * @property {boolean|null} [isLike] MomentChangeData isLike
         * @property {boolean|null} [isComment] MomentChangeData isComment
         * @property {string|null} [roomId] MomentChangeData roomId
         * @property {number|null} [roomStatus] MomentChangeData roomStatus
         * @property {Array.<CommentResult.ICommentMixtureVO>|null} [commentMixtureVO] MomentChangeData commentMixtureVO
         * @property {boolean|null} [isShare] MomentChangeData isShare
         * @property {number|null} [roomType] MomentChangeData roomType
         */

        /**
         * Constructs a new MomentChangeData.
         * @memberof MomentResult
         * @classdesc Represents a MomentChangeData.
         * @implements IMomentChangeData
         * @constructor
         * @param {MomentResult.IMomentChangeData=} [properties] Properties to set
         */
        function MomentChangeData(properties) {
            this.commentMixtureVO = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MomentChangeData isLike.
         * @member {boolean} isLike
         * @memberof MomentResult.MomentChangeData
         * @instance
         */
        MomentChangeData.prototype.isLike = false;

        /**
         * MomentChangeData isComment.
         * @member {boolean} isComment
         * @memberof MomentResult.MomentChangeData
         * @instance
         */
        MomentChangeData.prototype.isComment = false;

        /**
         * MomentChangeData roomId.
         * @member {string} roomId
         * @memberof MomentResult.MomentChangeData
         * @instance
         */
        MomentChangeData.prototype.roomId = "";

        /**
         * MomentChangeData roomStatus.
         * @member {number} roomStatus
         * @memberof MomentResult.MomentChangeData
         * @instance
         */
        MomentChangeData.prototype.roomStatus = 0;

        /**
         * MomentChangeData commentMixtureVO.
         * @member {Array.<CommentResult.ICommentMixtureVO>} commentMixtureVO
         * @memberof MomentResult.MomentChangeData
         * @instance
         */
        MomentChangeData.prototype.commentMixtureVO = $util.emptyArray;

        /**
         * MomentChangeData isShare.
         * @member {boolean} isShare
         * @memberof MomentResult.MomentChangeData
         * @instance
         */
        MomentChangeData.prototype.isShare = false;

        /**
         * MomentChangeData roomType.
         * @member {number} roomType
         * @memberof MomentResult.MomentChangeData
         * @instance
         */
        MomentChangeData.prototype.roomType = 0;

        /**
         * Decodes a MomentChangeData message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.MomentChangeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.MomentChangeData} MomentChangeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentChangeData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.MomentChangeData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isLike = reader.bool();
                    break;
                case 2:
                    message.isComment = reader.bool();
                    break;
                case 3:
                    message.roomId = reader.string();
                    break;
                case 4:
                    message.roomStatus = reader.int32();
                    break;
                case 5:
                    if (!(message.commentMixtureVO && message.commentMixtureVO.length))
                        message.commentMixtureVO = [];
                    message.commentMixtureVO.push($root.CommentResult.CommentMixtureVO.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.isShare = reader.bool();
                    break;
                case 7:
                    message.roomType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MomentChangeData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.MomentChangeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.MomentChangeData} MomentChangeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentChangeData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MomentChangeData;
    })();

    MomentResult.MomentBroadCast = (function() {

        /**
         * Properties of a MomentBroadCast.
         * @memberof MomentResult
         * @interface IMomentBroadCast
         * @property {string} id MomentBroadCast id
         * @property {string} userId MomentBroadCast userId
         * @property {number} operation MomentBroadCast operation
         */

        /**
         * Constructs a new MomentBroadCast.
         * @memberof MomentResult
         * @classdesc Represents a MomentBroadCast.
         * @implements IMomentBroadCast
         * @constructor
         * @param {MomentResult.IMomentBroadCast=} [properties] Properties to set
         */
        function MomentBroadCast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MomentBroadCast id.
         * @member {string} id
         * @memberof MomentResult.MomentBroadCast
         * @instance
         */
        MomentBroadCast.prototype.id = "";

        /**
         * MomentBroadCast userId.
         * @member {string} userId
         * @memberof MomentResult.MomentBroadCast
         * @instance
         */
        MomentBroadCast.prototype.userId = "";

        /**
         * MomentBroadCast operation.
         * @member {number} operation
         * @memberof MomentResult.MomentBroadCast
         * @instance
         */
        MomentBroadCast.prototype.operation = 0;

        /**
         * Decodes a MomentBroadCast message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.MomentBroadCast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.MomentBroadCast} MomentBroadCast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentBroadCast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.MomentBroadCast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.operation = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("operation"))
                throw $util.ProtocolError("missing required 'operation'", { instance: message });
            return message;
        };

        /**
         * Decodes a MomentBroadCast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.MomentBroadCast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.MomentBroadCast} MomentBroadCast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentBroadCast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MomentBroadCast;
    })();

    MomentResult.VoiceCardData = (function() {

        /**
         * Properties of a VoiceCardData.
         * @memberof MomentResult
         * @interface IVoiceCardData
         * @property {string} dataId VoiceCardData dataId
         * @property {string} voice VoiceCardData voice
         * @property {number} voiceDuration VoiceCardData voiceDuration
         * @property {string} userId VoiceCardData userId
         * @property {string|null} [nickName] VoiceCardData nickName
         * @property {string|null} [active] VoiceCardData active
         * @property {number|null} [nextIdx] VoiceCardData nextIdx
         */

        /**
         * Constructs a new VoiceCardData.
         * @memberof MomentResult
         * @classdesc Represents a VoiceCardData.
         * @implements IVoiceCardData
         * @constructor
         * @param {MomentResult.IVoiceCardData=} [properties] Properties to set
         */
        function VoiceCardData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VoiceCardData dataId.
         * @member {string} dataId
         * @memberof MomentResult.VoiceCardData
         * @instance
         */
        VoiceCardData.prototype.dataId = "";

        /**
         * VoiceCardData voice.
         * @member {string} voice
         * @memberof MomentResult.VoiceCardData
         * @instance
         */
        VoiceCardData.prototype.voice = "";

        /**
         * VoiceCardData voiceDuration.
         * @member {number} voiceDuration
         * @memberof MomentResult.VoiceCardData
         * @instance
         */
        VoiceCardData.prototype.voiceDuration = 0;

        /**
         * VoiceCardData userId.
         * @member {string} userId
         * @memberof MomentResult.VoiceCardData
         * @instance
         */
        VoiceCardData.prototype.userId = "";

        /**
         * VoiceCardData nickName.
         * @member {string} nickName
         * @memberof MomentResult.VoiceCardData
         * @instance
         */
        VoiceCardData.prototype.nickName = "";

        /**
         * VoiceCardData active.
         * @member {string} active
         * @memberof MomentResult.VoiceCardData
         * @instance
         */
        VoiceCardData.prototype.active = "";

        /**
         * VoiceCardData nextIdx.
         * @member {number} nextIdx
         * @memberof MomentResult.VoiceCardData
         * @instance
         */
        VoiceCardData.prototype.nextIdx = 0;

        /**
         * Decodes a VoiceCardData message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.VoiceCardData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.VoiceCardData} VoiceCardData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoiceCardData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.VoiceCardData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dataId = reader.string();
                    break;
                case 2:
                    message.voice = reader.string();
                    break;
                case 3:
                    message.voiceDuration = reader.int32();
                    break;
                case 4:
                    message.userId = reader.string();
                    break;
                case 5:
                    message.nickName = reader.string();
                    break;
                case 6:
                    message.active = reader.string();
                    break;
                case 7:
                    message.nextIdx = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("dataId"))
                throw $util.ProtocolError("missing required 'dataId'", { instance: message });
            if (!message.hasOwnProperty("voice"))
                throw $util.ProtocolError("missing required 'voice'", { instance: message });
            if (!message.hasOwnProperty("voiceDuration"))
                throw $util.ProtocolError("missing required 'voiceDuration'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            return message;
        };

        /**
         * Decodes a VoiceCardData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.VoiceCardData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.VoiceCardData} VoiceCardData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoiceCardData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return VoiceCardData;
    })();

    MomentResult.MomentVoiceData = (function() {

        /**
         * Properties of a MomentVoiceData.
         * @memberof MomentResult
         * @interface IMomentVoiceData
         * @property {string} dataId MomentVoiceData dataId
         * @property {string} voice MomentVoiceData voice
         * @property {number} voiceDuration MomentVoiceData voiceDuration
         * @property {boolean} isLike MomentVoiceData isLike
         * @property {UserResult.IUserBase} userBase MomentVoiceData userBase
         */

        /**
         * Constructs a new MomentVoiceData.
         * @memberof MomentResult
         * @classdesc Represents a MomentVoiceData.
         * @implements IMomentVoiceData
         * @constructor
         * @param {MomentResult.IMomentVoiceData=} [properties] Properties to set
         */
        function MomentVoiceData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MomentVoiceData dataId.
         * @member {string} dataId
         * @memberof MomentResult.MomentVoiceData
         * @instance
         */
        MomentVoiceData.prototype.dataId = "";

        /**
         * MomentVoiceData voice.
         * @member {string} voice
         * @memberof MomentResult.MomentVoiceData
         * @instance
         */
        MomentVoiceData.prototype.voice = "";

        /**
         * MomentVoiceData voiceDuration.
         * @member {number} voiceDuration
         * @memberof MomentResult.MomentVoiceData
         * @instance
         */
        MomentVoiceData.prototype.voiceDuration = 0;

        /**
         * MomentVoiceData isLike.
         * @member {boolean} isLike
         * @memberof MomentResult.MomentVoiceData
         * @instance
         */
        MomentVoiceData.prototype.isLike = false;

        /**
         * MomentVoiceData userBase.
         * @member {UserResult.IUserBase} userBase
         * @memberof MomentResult.MomentVoiceData
         * @instance
         */
        MomentVoiceData.prototype.userBase = null;

        /**
         * Decodes a MomentVoiceData message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.MomentVoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.MomentVoiceData} MomentVoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentVoiceData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.MomentVoiceData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dataId = reader.string();
                    break;
                case 2:
                    message.voice = reader.string();
                    break;
                case 3:
                    message.voiceDuration = reader.int32();
                    break;
                case 4:
                    message.isLike = reader.bool();
                    break;
                case 5:
                    message.userBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("dataId"))
                throw $util.ProtocolError("missing required 'dataId'", { instance: message });
            if (!message.hasOwnProperty("voice"))
                throw $util.ProtocolError("missing required 'voice'", { instance: message });
            if (!message.hasOwnProperty("voiceDuration"))
                throw $util.ProtocolError("missing required 'voiceDuration'", { instance: message });
            if (!message.hasOwnProperty("isLike"))
                throw $util.ProtocolError("missing required 'isLike'", { instance: message });
            if (!message.hasOwnProperty("userBase"))
                throw $util.ProtocolError("missing required 'userBase'", { instance: message });
            return message;
        };

        /**
         * Decodes a MomentVoiceData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.MomentVoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.MomentVoiceData} MomentVoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentVoiceData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MomentVoiceData;
    })();

    MomentResult.TopicDatas = (function() {

        /**
         * Properties of a TopicDatas.
         * @memberof MomentResult
         * @interface ITopicDatas
         * @property {Array.<MomentResult.ITopicData>|null} [datas] TopicDatas datas
         */

        /**
         * Constructs a new TopicDatas.
         * @memberof MomentResult
         * @classdesc Represents a TopicDatas.
         * @implements ITopicDatas
         * @constructor
         * @param {MomentResult.ITopicDatas=} [properties] Properties to set
         */
        function TopicDatas(properties) {
            this.datas = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TopicDatas datas.
         * @member {Array.<MomentResult.ITopicData>} datas
         * @memberof MomentResult.TopicDatas
         * @instance
         */
        TopicDatas.prototype.datas = $util.emptyArray;

        /**
         * Decodes a TopicDatas message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.TopicDatas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.TopicDatas} TopicDatas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopicDatas.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.TopicDatas();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.datas && message.datas.length))
                        message.datas = [];
                    message.datas.push($root.MomentResult.TopicData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TopicDatas message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.TopicDatas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.TopicDatas} TopicDatas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopicDatas.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return TopicDatas;
    })();

    MomentResult.TopicData = (function() {

        /**
         * Properties of a TopicData.
         * @memberof MomentResult
         * @interface ITopicData
         * @property {string} id TopicData id
         * @property {string} topicName TopicData topicName
         * @property {string} topicIntroduce TopicData topicIntroduce
         * @property {string} pic TopicData pic
         * @property {boolean|null} [topSearchTopic] TopicData topSearchTopic
         * @property {string|null} [topSearchLabel] TopicData topSearchLabel
         * @property {string|null} [topSearchStartTime] TopicData topSearchStartTime
         * @property {string|null} [topSearchEndTime] TopicData topSearchEndTime
         * @property {number|null} [weight] TopicData weight
         * @property {number|Long|null} [momentCount] TopicData momentCount
         * @property {number|Long|null} [joinCount] TopicData joinCount
         * @property {number|null} [heat] TopicData heat
         */

        /**
         * Constructs a new TopicData.
         * @memberof MomentResult
         * @classdesc Represents a TopicData.
         * @implements ITopicData
         * @constructor
         * @param {MomentResult.ITopicData=} [properties] Properties to set
         */
        function TopicData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TopicData id.
         * @member {string} id
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.id = "";

        /**
         * TopicData topicName.
         * @member {string} topicName
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.topicName = "";

        /**
         * TopicData topicIntroduce.
         * @member {string} topicIntroduce
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.topicIntroduce = "";

        /**
         * TopicData pic.
         * @member {string} pic
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.pic = "";

        /**
         * TopicData topSearchTopic.
         * @member {boolean} topSearchTopic
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.topSearchTopic = false;

        /**
         * TopicData topSearchLabel.
         * @member {string} topSearchLabel
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.topSearchLabel = "";

        /**
         * TopicData topSearchStartTime.
         * @member {string} topSearchStartTime
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.topSearchStartTime = "";

        /**
         * TopicData topSearchEndTime.
         * @member {string} topSearchEndTime
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.topSearchEndTime = "";

        /**
         * TopicData weight.
         * @member {number} weight
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.weight = 0;

        /**
         * TopicData momentCount.
         * @member {number|Long} momentCount
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.momentCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TopicData joinCount.
         * @member {number|Long} joinCount
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.joinCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TopicData heat.
         * @member {number} heat
         * @memberof MomentResult.TopicData
         * @instance
         */
        TopicData.prototype.heat = 0;

        /**
         * Decodes a TopicData message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.TopicData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.TopicData} TopicData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopicData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.TopicData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.topicName = reader.string();
                    break;
                case 3:
                    message.topicIntroduce = reader.string();
                    break;
                case 4:
                    message.pic = reader.string();
                    break;
                case 5:
                    message.topSearchTopic = reader.bool();
                    break;
                case 6:
                    message.topSearchLabel = reader.string();
                    break;
                case 7:
                    message.topSearchStartTime = reader.string();
                    break;
                case 8:
                    message.topSearchEndTime = reader.string();
                    break;
                case 9:
                    message.weight = reader.int32();
                    break;
                case 10:
                    message.momentCount = reader.int64();
                    break;
                case 11:
                    message.joinCount = reader.int64();
                    break;
                case 12:
                    message.heat = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("topicName"))
                throw $util.ProtocolError("missing required 'topicName'", { instance: message });
            if (!message.hasOwnProperty("topicIntroduce"))
                throw $util.ProtocolError("missing required 'topicIntroduce'", { instance: message });
            if (!message.hasOwnProperty("pic"))
                throw $util.ProtocolError("missing required 'pic'", { instance: message });
            return message;
        };

        /**
         * Decodes a TopicData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.TopicData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.TopicData} TopicData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopicData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return TopicData;
    })();

    MomentResult.MomentMedia = (function() {

        /**
         * Properties of a MomentMedia.
         * @memberof MomentResult
         * @interface IMomentMedia
         * @property {string|null} [pic] MomentMedia pic
         * @property {number|null} [height] MomentMedia height
         * @property {number|null} [width] MomentMedia width
         * @property {string|null} [video] MomentMedia video
         * @property {string|null} [videoPic] MomentMedia videoPic
         * @property {string|null} [voice] MomentMedia voice
         * @property {number|null} [duration] MomentMedia duration
         * @property {number} type MomentMedia type
         * @property {string|null} [ext] MomentMedia ext
         */

        /**
         * Constructs a new MomentMedia.
         * @memberof MomentResult
         * @classdesc Represents a MomentMedia.
         * @implements IMomentMedia
         * @constructor
         * @param {MomentResult.IMomentMedia=} [properties] Properties to set
         */
        function MomentMedia(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MomentMedia pic.
         * @member {string} pic
         * @memberof MomentResult.MomentMedia
         * @instance
         */
        MomentMedia.prototype.pic = "";

        /**
         * MomentMedia height.
         * @member {number} height
         * @memberof MomentResult.MomentMedia
         * @instance
         */
        MomentMedia.prototype.height = 0;

        /**
         * MomentMedia width.
         * @member {number} width
         * @memberof MomentResult.MomentMedia
         * @instance
         */
        MomentMedia.prototype.width = 0;

        /**
         * MomentMedia video.
         * @member {string} video
         * @memberof MomentResult.MomentMedia
         * @instance
         */
        MomentMedia.prototype.video = "";

        /**
         * MomentMedia videoPic.
         * @member {string} videoPic
         * @memberof MomentResult.MomentMedia
         * @instance
         */
        MomentMedia.prototype.videoPic = "";

        /**
         * MomentMedia voice.
         * @member {string} voice
         * @memberof MomentResult.MomentMedia
         * @instance
         */
        MomentMedia.prototype.voice = "";

        /**
         * MomentMedia duration.
         * @member {number} duration
         * @memberof MomentResult.MomentMedia
         * @instance
         */
        MomentMedia.prototype.duration = 0;

        /**
         * MomentMedia type.
         * @member {number} type
         * @memberof MomentResult.MomentMedia
         * @instance
         */
        MomentMedia.prototype.type = 0;

        /**
         * MomentMedia ext.
         * @member {string} ext
         * @memberof MomentResult.MomentMedia
         * @instance
         */
        MomentMedia.prototype.ext = "";

        /**
         * Decodes a MomentMedia message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.MomentMedia
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.MomentMedia} MomentMedia
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentMedia.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.MomentMedia();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pic = reader.string();
                    break;
                case 2:
                    message.height = reader.int32();
                    break;
                case 3:
                    message.width = reader.int32();
                    break;
                case 4:
                    message.video = reader.string();
                    break;
                case 5:
                    message.videoPic = reader.string();
                    break;
                case 6:
                    message.voice = reader.string();
                    break;
                case 7:
                    message.duration = reader.int32();
                    break;
                case 8:
                    message.type = reader.int32();
                    break;
                case 9:
                    message.ext = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a MomentMedia message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.MomentMedia
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.MomentMedia} MomentMedia
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentMedia.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MomentMedia;
    })();

    MomentResult.SquareTopicVOs = (function() {

        /**
         * Properties of a SquareTopicVOs.
         * @memberof MomentResult
         * @interface ISquareTopicVOs
         * @property {Array.<MomentResult.ISquareTopicVO>|null} [squareTopicVO] SquareTopicVOs squareTopicVO
         */

        /**
         * Constructs a new SquareTopicVOs.
         * @memberof MomentResult
         * @classdesc Represents a SquareTopicVOs.
         * @implements ISquareTopicVOs
         * @constructor
         * @param {MomentResult.ISquareTopicVOs=} [properties] Properties to set
         */
        function SquareTopicVOs(properties) {
            this.squareTopicVO = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SquareTopicVOs squareTopicVO.
         * @member {Array.<MomentResult.ISquareTopicVO>} squareTopicVO
         * @memberof MomentResult.SquareTopicVOs
         * @instance
         */
        SquareTopicVOs.prototype.squareTopicVO = $util.emptyArray;

        /**
         * Decodes a SquareTopicVOs message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.SquareTopicVOs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.SquareTopicVOs} SquareTopicVOs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SquareTopicVOs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.SquareTopicVOs();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.squareTopicVO && message.squareTopicVO.length))
                        message.squareTopicVO = [];
                    message.squareTopicVO.push($root.MomentResult.SquareTopicVO.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SquareTopicVOs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.SquareTopicVOs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.SquareTopicVOs} SquareTopicVOs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SquareTopicVOs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SquareTopicVOs;
    })();

    MomentResult.SquareTopicVO = (function() {

        /**
         * Properties of a SquareTopicVO.
         * @memberof MomentResult
         * @interface ISquareTopicVO
         * @property {MomentResult.ITopicData|null} [topicData] SquareTopicVO topicData
         * @property {boolean|null} [isMyTopic] SquareTopicVO isMyTopic
         * @property {number|null} [index] SquareTopicVO index
         */

        /**
         * Constructs a new SquareTopicVO.
         * @memberof MomentResult
         * @classdesc Represents a SquareTopicVO.
         * @implements ISquareTopicVO
         * @constructor
         * @param {MomentResult.ISquareTopicVO=} [properties] Properties to set
         */
        function SquareTopicVO(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SquareTopicVO topicData.
         * @member {MomentResult.ITopicData|null|undefined} topicData
         * @memberof MomentResult.SquareTopicVO
         * @instance
         */
        SquareTopicVO.prototype.topicData = null;

        /**
         * SquareTopicVO isMyTopic.
         * @member {boolean} isMyTopic
         * @memberof MomentResult.SquareTopicVO
         * @instance
         */
        SquareTopicVO.prototype.isMyTopic = false;

        /**
         * SquareTopicVO index.
         * @member {number} index
         * @memberof MomentResult.SquareTopicVO
         * @instance
         */
        SquareTopicVO.prototype.index = 0;

        /**
         * Decodes a SquareTopicVO message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.SquareTopicVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.SquareTopicVO} SquareTopicVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SquareTopicVO.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.SquareTopicVO();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.topicData = $root.MomentResult.TopicData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.isMyTopic = reader.bool();
                    break;
                case 3:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SquareTopicVO message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.SquareTopicVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.SquareTopicVO} SquareTopicVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SquareTopicVO.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SquareTopicVO;
    })();

    MomentResult.LikeMomentData = (function() {

        /**
         * Properties of a LikeMomentData.
         * @memberof MomentResult
         * @interface ILikeMomentData
         * @property {number} totalPage LikeMomentData totalPage
         * @property {number} totalCount LikeMomentData totalCount
         * @property {Array.<MomentResult.ISquareMomentVO>|null} [squareMomentVO] LikeMomentData squareMomentVO
         */

        /**
         * Constructs a new LikeMomentData.
         * @memberof MomentResult
         * @classdesc Represents a LikeMomentData.
         * @implements ILikeMomentData
         * @constructor
         * @param {MomentResult.ILikeMomentData=} [properties] Properties to set
         */
        function LikeMomentData(properties) {
            this.squareMomentVO = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LikeMomentData totalPage.
         * @member {number} totalPage
         * @memberof MomentResult.LikeMomentData
         * @instance
         */
        LikeMomentData.prototype.totalPage = 0;

        /**
         * LikeMomentData totalCount.
         * @member {number} totalCount
         * @memberof MomentResult.LikeMomentData
         * @instance
         */
        LikeMomentData.prototype.totalCount = 0;

        /**
         * LikeMomentData squareMomentVO.
         * @member {Array.<MomentResult.ISquareMomentVO>} squareMomentVO
         * @memberof MomentResult.LikeMomentData
         * @instance
         */
        LikeMomentData.prototype.squareMomentVO = $util.emptyArray;

        /**
         * Decodes a LikeMomentData message from the specified reader or buffer.
         * @function decode
         * @memberof MomentResult.LikeMomentData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MomentResult.LikeMomentData} LikeMomentData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeMomentData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MomentResult.LikeMomentData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalPage = reader.int32();
                    break;
                case 2:
                    message.totalCount = reader.int32();
                    break;
                case 3:
                    if (!(message.squareMomentVO && message.squareMomentVO.length))
                        message.squareMomentVO = [];
                    message.squareMomentVO.push($root.MomentResult.SquareMomentVO.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("totalPage"))
                throw $util.ProtocolError("missing required 'totalPage'", { instance: message });
            if (!message.hasOwnProperty("totalCount"))
                throw $util.ProtocolError("missing required 'totalCount'", { instance: message });
            return message;
        };

        /**
         * Decodes a LikeMomentData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MomentResult.LikeMomentData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MomentResult.LikeMomentData} LikeMomentData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeMomentData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LikeMomentData;
    })();

    return MomentResult;
})();

export const NotificationResult = $root.NotificationResult = (() => {

    /**
     * Namespace NotificationResult.
     * @exports NotificationResult
     * @namespace
     */
    const NotificationResult = {};

    NotificationResult.NotificationVOs = (function() {

        /**
         * Properties of a NotificationVOs.
         * @memberof NotificationResult
         * @interface INotificationVOs
         * @property {Array.<NotificationResult.INotificationVO>|null} [noteVO] NotificationVOs noteVO
         */

        /**
         * Constructs a new NotificationVOs.
         * @memberof NotificationResult
         * @classdesc Represents a NotificationVOs.
         * @implements INotificationVOs
         * @constructor
         * @param {NotificationResult.INotificationVOs=} [properties] Properties to set
         */
        function NotificationVOs(properties) {
            this.noteVO = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NotificationVOs noteVO.
         * @member {Array.<NotificationResult.INotificationVO>} noteVO
         * @memberof NotificationResult.NotificationVOs
         * @instance
         */
        NotificationVOs.prototype.noteVO = $util.emptyArray;

        /**
         * Decodes a NotificationVOs message from the specified reader or buffer.
         * @function decode
         * @memberof NotificationResult.NotificationVOs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NotificationResult.NotificationVOs} NotificationVOs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationVOs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NotificationResult.NotificationVOs();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.noteVO && message.noteVO.length))
                        message.noteVO = [];
                    message.noteVO.push($root.NotificationResult.NotificationVO.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NotificationVOs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NotificationResult.NotificationVOs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NotificationResult.NotificationVOs} NotificationVOs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationVOs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return NotificationVOs;
    })();

    NotificationResult.NotificationVO = (function() {

        /**
         * Properties of a NotificationVO.
         * @memberof NotificationResult
         * @interface INotificationVO
         * @property {string} id NotificationVO id
         * @property {UserResult.IUserBase} noteUserInfo NotificationVO noteUserInfo
         * @property {string} sourceId NotificationVO sourceId
         * @property {number} sourceType NotificationVO sourceType
         * @property {string} createTime NotificationVO createTime
         * @property {string|null} [word] NotificationVO word
         * @property {string|null} [voice] NotificationVO voice
         * @property {number|null} [voiceDur] NotificationVO voiceDur
         * @property {string|null} [pic] NotificationVO pic
         * @property {number|null} [version] NotificationVO version
         * @property {string|null} [auxiliarySourceId] NotificationVO auxiliarySourceId
         * @property {string|null} [auxiliaryWord] NotificationVO auxiliaryWord
         * @property {boolean|null} [read] NotificationVO read
         * @property {string|null} [commentId] NotificationVO commentId
         * @property {UserResult.IUserBase|null} [beRepliedUserInfo] NotificationVO beRepliedUserInfo
         */

        /**
         * Constructs a new NotificationVO.
         * @memberof NotificationResult
         * @classdesc Represents a NotificationVO.
         * @implements INotificationVO
         * @constructor
         * @param {NotificationResult.INotificationVO=} [properties] Properties to set
         */
        function NotificationVO(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NotificationVO id.
         * @member {string} id
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.id = "";

        /**
         * NotificationVO noteUserInfo.
         * @member {UserResult.IUserBase} noteUserInfo
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.noteUserInfo = null;

        /**
         * NotificationVO sourceId.
         * @member {string} sourceId
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.sourceId = "";

        /**
         * NotificationVO sourceType.
         * @member {number} sourceType
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.sourceType = 0;

        /**
         * NotificationVO createTime.
         * @member {string} createTime
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.createTime = "";

        /**
         * NotificationVO word.
         * @member {string} word
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.word = "";

        /**
         * NotificationVO voice.
         * @member {string} voice
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.voice = "";

        /**
         * NotificationVO voiceDur.
         * @member {number} voiceDur
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.voiceDur = 0;

        /**
         * NotificationVO pic.
         * @member {string} pic
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.pic = "";

        /**
         * NotificationVO version.
         * @member {number} version
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.version = 0;

        /**
         * NotificationVO auxiliarySourceId.
         * @member {string} auxiliarySourceId
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.auxiliarySourceId = "";

        /**
         * NotificationVO auxiliaryWord.
         * @member {string} auxiliaryWord
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.auxiliaryWord = "";

        /**
         * NotificationVO read.
         * @member {boolean} read
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.read = false;

        /**
         * NotificationVO commentId.
         * @member {string} commentId
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.commentId = "";

        /**
         * NotificationVO beRepliedUserInfo.
         * @member {UserResult.IUserBase|null|undefined} beRepliedUserInfo
         * @memberof NotificationResult.NotificationVO
         * @instance
         */
        NotificationVO.prototype.beRepliedUserInfo = null;

        /**
         * Decodes a NotificationVO message from the specified reader or buffer.
         * @function decode
         * @memberof NotificationResult.NotificationVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NotificationResult.NotificationVO} NotificationVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationVO.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NotificationResult.NotificationVO();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.noteUserInfo = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.sourceId = reader.string();
                    break;
                case 4:
                    message.sourceType = reader.int32();
                    break;
                case 5:
                    message.createTime = reader.string();
                    break;
                case 6:
                    message.word = reader.string();
                    break;
                case 7:
                    message.voice = reader.string();
                    break;
                case 9:
                    message.voiceDur = reader.int32();
                    break;
                case 10:
                    message.pic = reader.string();
                    break;
                case 12:
                    message.version = reader.int32();
                    break;
                case 13:
                    message.auxiliarySourceId = reader.string();
                    break;
                case 14:
                    message.auxiliaryWord = reader.string();
                    break;
                case 15:
                    message.read = reader.bool();
                    break;
                case 16:
                    message.commentId = reader.string();
                    break;
                case 17:
                    message.beRepliedUserInfo = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("noteUserInfo"))
                throw $util.ProtocolError("missing required 'noteUserInfo'", { instance: message });
            if (!message.hasOwnProperty("sourceId"))
                throw $util.ProtocolError("missing required 'sourceId'", { instance: message });
            if (!message.hasOwnProperty("sourceType"))
                throw $util.ProtocolError("missing required 'sourceType'", { instance: message });
            if (!message.hasOwnProperty("createTime"))
                throw $util.ProtocolError("missing required 'createTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a NotificationVO message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NotificationResult.NotificationVO
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NotificationResult.NotificationVO} NotificationVO
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationVO.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return NotificationVO;
    })();

    NotificationResult.NoteBroadcast = (function() {

        /**
         * Properties of a NoteBroadcast.
         * @memberof NotificationResult
         * @interface INoteBroadcast
         * @property {string} id NoteBroadcast id
         * @property {string} acceptor NoteBroadcast acceptor
         * @property {string} initiator NoteBroadcast initiator
         * @property {number} operation NoteBroadcast operation
         */

        /**
         * Constructs a new NoteBroadcast.
         * @memberof NotificationResult
         * @classdesc Represents a NoteBroadcast.
         * @implements INoteBroadcast
         * @constructor
         * @param {NotificationResult.INoteBroadcast=} [properties] Properties to set
         */
        function NoteBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoteBroadcast id.
         * @member {string} id
         * @memberof NotificationResult.NoteBroadcast
         * @instance
         */
        NoteBroadcast.prototype.id = "";

        /**
         * NoteBroadcast acceptor.
         * @member {string} acceptor
         * @memberof NotificationResult.NoteBroadcast
         * @instance
         */
        NoteBroadcast.prototype.acceptor = "";

        /**
         * NoteBroadcast initiator.
         * @member {string} initiator
         * @memberof NotificationResult.NoteBroadcast
         * @instance
         */
        NoteBroadcast.prototype.initiator = "";

        /**
         * NoteBroadcast operation.
         * @member {number} operation
         * @memberof NotificationResult.NoteBroadcast
         * @instance
         */
        NoteBroadcast.prototype.operation = 0;

        /**
         * Decodes a NoteBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof NotificationResult.NoteBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NotificationResult.NoteBroadcast} NoteBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoteBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NotificationResult.NoteBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.acceptor = reader.string();
                    break;
                case 3:
                    message.initiator = reader.string();
                    break;
                case 4:
                    message.operation = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("acceptor"))
                throw $util.ProtocolError("missing required 'acceptor'", { instance: message });
            if (!message.hasOwnProperty("initiator"))
                throw $util.ProtocolError("missing required 'initiator'", { instance: message });
            if (!message.hasOwnProperty("operation"))
                throw $util.ProtocolError("missing required 'operation'", { instance: message });
            return message;
        };

        /**
         * Decodes a NoteBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NotificationResult.NoteBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NotificationResult.NoteBroadcast} NoteBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoteBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return NoteBroadcast;
    })();

    NotificationResult.NewNoteBroadcast = (function() {

        /**
         * Properties of a NewNoteBroadcast.
         * @memberof NotificationResult
         * @interface INewNoteBroadcast
         */

        /**
         * Constructs a new NewNoteBroadcast.
         * @memberof NotificationResult
         * @classdesc Represents a NewNoteBroadcast.
         * @implements INewNoteBroadcast
         * @constructor
         * @param {NotificationResult.INewNoteBroadcast=} [properties] Properties to set
         */
        function NewNoteBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Decodes a NewNoteBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof NotificationResult.NewNoteBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NotificationResult.NewNoteBroadcast} NewNoteBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewNoteBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NotificationResult.NewNoteBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewNoteBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NotificationResult.NewNoteBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NotificationResult.NewNoteBroadcast} NewNoteBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewNoteBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return NewNoteBroadcast;
    })();

    return NotificationResult;
})();

export const RechargeResult = $root.RechargeResult = (() => {

    /**
     * Namespace RechargeResult.
     * @exports RechargeResult
     * @namespace
     */
    const RechargeResult = {};

    RechargeResult.RechargeData = (function() {

        /**
         * Properties of a RechargeData.
         * @memberof RechargeResult
         * @interface IRechargeData
         * @property {Array.<RechargeResult.IRechargeInfo>|null} [list] RechargeData list
         */

        /**
         * Constructs a new RechargeData.
         * @memberof RechargeResult
         * @classdesc Represents a RechargeData.
         * @implements IRechargeData
         * @constructor
         * @param {RechargeResult.IRechargeData=} [properties] Properties to set
         */
        function RechargeData(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeData list.
         * @member {Array.<RechargeResult.IRechargeInfo>} list
         * @memberof RechargeResult.RechargeData
         * @instance
         */
        RechargeData.prototype.list = $util.emptyArray;

        /**
         * Decodes a RechargeData message from the specified reader or buffer.
         * @function decode
         * @memberof RechargeResult.RechargeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RechargeResult.RechargeData} RechargeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RechargeResult.RechargeData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RechargeResult.RechargeInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RechargeResult.RechargeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RechargeResult.RechargeData} RechargeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RechargeData;
    })();

    RechargeResult.RechargeInfo = (function() {

        /**
         * Properties of a RechargeInfo.
         * @memberof RechargeResult
         * @interface IRechargeInfo
         * @property {string} id RechargeInfo id
         * @property {string} productId RechargeInfo productId
         * @property {number} money RechargeInfo money
         * @property {number} state RechargeInfo state
         * @property {number|Long} logTime RechargeInfo logTime
         * @property {number} payType RechargeInfo payType
         */

        /**
         * Constructs a new RechargeInfo.
         * @memberof RechargeResult
         * @classdesc Represents a RechargeInfo.
         * @implements IRechargeInfo
         * @constructor
         * @param {RechargeResult.IRechargeInfo=} [properties] Properties to set
         */
        function RechargeInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeInfo id.
         * @member {string} id
         * @memberof RechargeResult.RechargeInfo
         * @instance
         */
        RechargeInfo.prototype.id = "";

        /**
         * RechargeInfo productId.
         * @member {string} productId
         * @memberof RechargeResult.RechargeInfo
         * @instance
         */
        RechargeInfo.prototype.productId = "";

        /**
         * RechargeInfo money.
         * @member {number} money
         * @memberof RechargeResult.RechargeInfo
         * @instance
         */
        RechargeInfo.prototype.money = 0;

        /**
         * RechargeInfo state.
         * @member {number} state
         * @memberof RechargeResult.RechargeInfo
         * @instance
         */
        RechargeInfo.prototype.state = 0;

        /**
         * RechargeInfo logTime.
         * @member {number|Long} logTime
         * @memberof RechargeResult.RechargeInfo
         * @instance
         */
        RechargeInfo.prototype.logTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RechargeInfo payType.
         * @member {number} payType
         * @memberof RechargeResult.RechargeInfo
         * @instance
         */
        RechargeInfo.prototype.payType = 0;

        /**
         * Decodes a RechargeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RechargeResult.RechargeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RechargeResult.RechargeInfo} RechargeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RechargeResult.RechargeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.productId = reader.string();
                    break;
                case 3:
                    message.money = reader.int32();
                    break;
                case 4:
                    message.state = reader.int32();
                    break;
                case 5:
                    message.logTime = reader.int64();
                    break;
                case 6:
                    message.payType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("productId"))
                throw $util.ProtocolError("missing required 'productId'", { instance: message });
            if (!message.hasOwnProperty("money"))
                throw $util.ProtocolError("missing required 'money'", { instance: message });
            if (!message.hasOwnProperty("state"))
                throw $util.ProtocolError("missing required 'state'", { instance: message });
            if (!message.hasOwnProperty("logTime"))
                throw $util.ProtocolError("missing required 'logTime'", { instance: message });
            if (!message.hasOwnProperty("payType"))
                throw $util.ProtocolError("missing required 'payType'", { instance: message });
            return message;
        };

        /**
         * Decodes a RechargeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RechargeResult.RechargeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RechargeResult.RechargeInfo} RechargeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RechargeInfo;
    })();

    RechargeResult.RechargeCount = (function() {

        /**
         * Properties of a RechargeCount.
         * @memberof RechargeResult
         * @interface IRechargeCount
         * @property {Array.<string>|null} [ids] RechargeCount ids
         * @property {Array.<number>|null} [counts] RechargeCount counts
         * @property {boolean|null} [hasRecharge] RechargeCount hasRecharge
         */

        /**
         * Constructs a new RechargeCount.
         * @memberof RechargeResult
         * @classdesc Represents a RechargeCount.
         * @implements IRechargeCount
         * @constructor
         * @param {RechargeResult.IRechargeCount=} [properties] Properties to set
         */
        function RechargeCount(properties) {
            this.ids = [];
            this.counts = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeCount ids.
         * @member {Array.<string>} ids
         * @memberof RechargeResult.RechargeCount
         * @instance
         */
        RechargeCount.prototype.ids = $util.emptyArray;

        /**
         * RechargeCount counts.
         * @member {Array.<number>} counts
         * @memberof RechargeResult.RechargeCount
         * @instance
         */
        RechargeCount.prototype.counts = $util.emptyArray;

        /**
         * RechargeCount hasRecharge.
         * @member {boolean} hasRecharge
         * @memberof RechargeResult.RechargeCount
         * @instance
         */
        RechargeCount.prototype.hasRecharge = false;

        /**
         * Decodes a RechargeCount message from the specified reader or buffer.
         * @function decode
         * @memberof RechargeResult.RechargeCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RechargeResult.RechargeCount} RechargeCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeCount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RechargeResult.RechargeCount();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push(reader.string());
                    break;
                case 2:
                    if (!(message.counts && message.counts.length))
                        message.counts = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.counts.push(reader.int32());
                    } else
                        message.counts.push(reader.int32());
                    break;
                case 3:
                    message.hasRecharge = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeCount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RechargeResult.RechargeCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RechargeResult.RechargeCount} RechargeCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeCount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RechargeCount;
    })();

    RechargeResult.RechargeTotal = (function() {

        /**
         * Properties of a RechargeTotal.
         * @memberof RechargeResult
         * @interface IRechargeTotal
         * @property {string} userId RechargeTotal userId
         * @property {number|null} [totalMoney] RechargeTotal totalMoney
         */

        /**
         * Constructs a new RechargeTotal.
         * @memberof RechargeResult
         * @classdesc Represents a RechargeTotal.
         * @implements IRechargeTotal
         * @constructor
         * @param {RechargeResult.IRechargeTotal=} [properties] Properties to set
         */
        function RechargeTotal(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeTotal userId.
         * @member {string} userId
         * @memberof RechargeResult.RechargeTotal
         * @instance
         */
        RechargeTotal.prototype.userId = "";

        /**
         * RechargeTotal totalMoney.
         * @member {number} totalMoney
         * @memberof RechargeResult.RechargeTotal
         * @instance
         */
        RechargeTotal.prototype.totalMoney = 0;

        /**
         * Decodes a RechargeTotal message from the specified reader or buffer.
         * @function decode
         * @memberof RechargeResult.RechargeTotal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RechargeResult.RechargeTotal} RechargeTotal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeTotal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RechargeResult.RechargeTotal();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.totalMoney = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            return message;
        };

        /**
         * Decodes a RechargeTotal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RechargeResult.RechargeTotal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RechargeResult.RechargeTotal} RechargeTotal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeTotal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RechargeTotal;
    })();

    RechargeResult.OrderPayTimeOutBroadcast = (function() {

        /**
         * Properties of an OrderPayTimeOutBroadcast.
         * @memberof RechargeResult
         * @interface IOrderPayTimeOutBroadcast
         * @property {string|null} [orderId] OrderPayTimeOutBroadcast orderId
         * @property {string|null} [desc] OrderPayTimeOutBroadcast desc
         */

        /**
         * Constructs a new OrderPayTimeOutBroadcast.
         * @memberof RechargeResult
         * @classdesc Represents an OrderPayTimeOutBroadcast.
         * @implements IOrderPayTimeOutBroadcast
         * @constructor
         * @param {RechargeResult.IOrderPayTimeOutBroadcast=} [properties] Properties to set
         */
        function OrderPayTimeOutBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderPayTimeOutBroadcast orderId.
         * @member {string} orderId
         * @memberof RechargeResult.OrderPayTimeOutBroadcast
         * @instance
         */
        OrderPayTimeOutBroadcast.prototype.orderId = "";

        /**
         * OrderPayTimeOutBroadcast desc.
         * @member {string} desc
         * @memberof RechargeResult.OrderPayTimeOutBroadcast
         * @instance
         */
        OrderPayTimeOutBroadcast.prototype.desc = "";

        /**
         * Decodes an OrderPayTimeOutBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof RechargeResult.OrderPayTimeOutBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RechargeResult.OrderPayTimeOutBroadcast} OrderPayTimeOutBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderPayTimeOutBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RechargeResult.OrderPayTimeOutBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.orderId = reader.string();
                    break;
                case 2:
                    message.desc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OrderPayTimeOutBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RechargeResult.OrderPayTimeOutBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RechargeResult.OrderPayTimeOutBroadcast} OrderPayTimeOutBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderPayTimeOutBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return OrderPayTimeOutBroadcast;
    })();

    RechargeResult.SendGoldShelLogList = (function() {

        /**
         * Properties of a SendGoldShelLogList.
         * @memberof RechargeResult
         * @interface ISendGoldShelLogList
         * @property {Array.<RechargeResult.ISendGoldShelLog>|null} [list] SendGoldShelLogList list
         */

        /**
         * Constructs a new SendGoldShelLogList.
         * @memberof RechargeResult
         * @classdesc Represents a SendGoldShelLogList.
         * @implements ISendGoldShelLogList
         * @constructor
         * @param {RechargeResult.ISendGoldShelLogList=} [properties] Properties to set
         */
        function SendGoldShelLogList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendGoldShelLogList list.
         * @member {Array.<RechargeResult.ISendGoldShelLog>} list
         * @memberof RechargeResult.SendGoldShelLogList
         * @instance
         */
        SendGoldShelLogList.prototype.list = $util.emptyArray;

        /**
         * Decodes a SendGoldShelLogList message from the specified reader or buffer.
         * @function decode
         * @memberof RechargeResult.SendGoldShelLogList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RechargeResult.SendGoldShelLogList} SendGoldShelLogList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendGoldShelLogList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RechargeResult.SendGoldShelLogList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RechargeResult.SendGoldShelLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendGoldShelLogList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RechargeResult.SendGoldShelLogList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RechargeResult.SendGoldShelLogList} SendGoldShelLogList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendGoldShelLogList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SendGoldShelLogList;
    })();

    RechargeResult.SendGoldShelLog = (function() {

        /**
         * Properties of a SendGoldShelLog.
         * @memberof RechargeResult
         * @interface ISendGoldShelLog
         * @property {string} id SendGoldShelLog id
         * @property {string} targetId SendGoldShelLog targetId
         * @property {number} goldShell SendGoldShelLog goldShell
         * @property {string} recordDate SendGoldShelLog recordDate
         * @property {string} statusMsg SendGoldShelLog statusMsg
         * @property {UserResult.IUserBase|null} [targetBase] SendGoldShelLog targetBase
         */

        /**
         * Constructs a new SendGoldShelLog.
         * @memberof RechargeResult
         * @classdesc Represents a SendGoldShelLog.
         * @implements ISendGoldShelLog
         * @constructor
         * @param {RechargeResult.ISendGoldShelLog=} [properties] Properties to set
         */
        function SendGoldShelLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendGoldShelLog id.
         * @member {string} id
         * @memberof RechargeResult.SendGoldShelLog
         * @instance
         */
        SendGoldShelLog.prototype.id = "";

        /**
         * SendGoldShelLog targetId.
         * @member {string} targetId
         * @memberof RechargeResult.SendGoldShelLog
         * @instance
         */
        SendGoldShelLog.prototype.targetId = "";

        /**
         * SendGoldShelLog goldShell.
         * @member {number} goldShell
         * @memberof RechargeResult.SendGoldShelLog
         * @instance
         */
        SendGoldShelLog.prototype.goldShell = 0;

        /**
         * SendGoldShelLog recordDate.
         * @member {string} recordDate
         * @memberof RechargeResult.SendGoldShelLog
         * @instance
         */
        SendGoldShelLog.prototype.recordDate = "";

        /**
         * SendGoldShelLog statusMsg.
         * @member {string} statusMsg
         * @memberof RechargeResult.SendGoldShelLog
         * @instance
         */
        SendGoldShelLog.prototype.statusMsg = "";

        /**
         * SendGoldShelLog targetBase.
         * @member {UserResult.IUserBase|null|undefined} targetBase
         * @memberof RechargeResult.SendGoldShelLog
         * @instance
         */
        SendGoldShelLog.prototype.targetBase = null;

        /**
         * Decodes a SendGoldShelLog message from the specified reader or buffer.
         * @function decode
         * @memberof RechargeResult.SendGoldShelLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RechargeResult.SendGoldShelLog} SendGoldShelLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendGoldShelLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RechargeResult.SendGoldShelLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.goldShell = reader.int32();
                    break;
                case 4:
                    message.recordDate = reader.string();
                    break;
                case 5:
                    message.statusMsg = reader.string();
                    break;
                case 6:
                    message.targetBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("targetId"))
                throw $util.ProtocolError("missing required 'targetId'", { instance: message });
            if (!message.hasOwnProperty("goldShell"))
                throw $util.ProtocolError("missing required 'goldShell'", { instance: message });
            if (!message.hasOwnProperty("recordDate"))
                throw $util.ProtocolError("missing required 'recordDate'", { instance: message });
            if (!message.hasOwnProperty("statusMsg"))
                throw $util.ProtocolError("missing required 'statusMsg'", { instance: message });
            return message;
        };

        /**
         * Decodes a SendGoldShelLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RechargeResult.SendGoldShelLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RechargeResult.SendGoldShelLog} SendGoldShelLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendGoldShelLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SendGoldShelLog;
    })();

    RechargeResult.ReceivedGoldShellLogList = (function() {

        /**
         * Properties of a ReceivedGoldShellLogList.
         * @memberof RechargeResult
         * @interface IReceivedGoldShellLogList
         * @property {Array.<RechargeResult.IReceivedGoldShellLog>|null} [list] ReceivedGoldShellLogList list
         */

        /**
         * Constructs a new ReceivedGoldShellLogList.
         * @memberof RechargeResult
         * @classdesc Represents a ReceivedGoldShellLogList.
         * @implements IReceivedGoldShellLogList
         * @constructor
         * @param {RechargeResult.IReceivedGoldShellLogList=} [properties] Properties to set
         */
        function ReceivedGoldShellLogList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReceivedGoldShellLogList list.
         * @member {Array.<RechargeResult.IReceivedGoldShellLog>} list
         * @memberof RechargeResult.ReceivedGoldShellLogList
         * @instance
         */
        ReceivedGoldShellLogList.prototype.list = $util.emptyArray;

        /**
         * Decodes a ReceivedGoldShellLogList message from the specified reader or buffer.
         * @function decode
         * @memberof RechargeResult.ReceivedGoldShellLogList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RechargeResult.ReceivedGoldShellLogList} ReceivedGoldShellLogList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceivedGoldShellLogList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RechargeResult.ReceivedGoldShellLogList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RechargeResult.ReceivedGoldShellLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReceivedGoldShellLogList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RechargeResult.ReceivedGoldShellLogList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RechargeResult.ReceivedGoldShellLogList} ReceivedGoldShellLogList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceivedGoldShellLogList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ReceivedGoldShellLogList;
    })();

    RechargeResult.ReceivedGoldShellLog = (function() {

        /**
         * Properties of a ReceivedGoldShellLog.
         * @memberof RechargeResult
         * @interface IReceivedGoldShellLog
         * @property {string} id ReceivedGoldShellLog id
         * @property {string} sourceId ReceivedGoldShellLog sourceId
         * @property {number} goldShell ReceivedGoldShellLog goldShell
         * @property {string} recordDate ReceivedGoldShellLog recordDate
         * @property {string} statusMsg ReceivedGoldShellLog statusMsg
         */

        /**
         * Constructs a new ReceivedGoldShellLog.
         * @memberof RechargeResult
         * @classdesc Represents a ReceivedGoldShellLog.
         * @implements IReceivedGoldShellLog
         * @constructor
         * @param {RechargeResult.IReceivedGoldShellLog=} [properties] Properties to set
         */
        function ReceivedGoldShellLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReceivedGoldShellLog id.
         * @member {string} id
         * @memberof RechargeResult.ReceivedGoldShellLog
         * @instance
         */
        ReceivedGoldShellLog.prototype.id = "";

        /**
         * ReceivedGoldShellLog sourceId.
         * @member {string} sourceId
         * @memberof RechargeResult.ReceivedGoldShellLog
         * @instance
         */
        ReceivedGoldShellLog.prototype.sourceId = "";

        /**
         * ReceivedGoldShellLog goldShell.
         * @member {number} goldShell
         * @memberof RechargeResult.ReceivedGoldShellLog
         * @instance
         */
        ReceivedGoldShellLog.prototype.goldShell = 0;

        /**
         * ReceivedGoldShellLog recordDate.
         * @member {string} recordDate
         * @memberof RechargeResult.ReceivedGoldShellLog
         * @instance
         */
        ReceivedGoldShellLog.prototype.recordDate = "";

        /**
         * ReceivedGoldShellLog statusMsg.
         * @member {string} statusMsg
         * @memberof RechargeResult.ReceivedGoldShellLog
         * @instance
         */
        ReceivedGoldShellLog.prototype.statusMsg = "";

        /**
         * Decodes a ReceivedGoldShellLog message from the specified reader or buffer.
         * @function decode
         * @memberof RechargeResult.ReceivedGoldShellLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RechargeResult.ReceivedGoldShellLog} ReceivedGoldShellLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceivedGoldShellLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RechargeResult.ReceivedGoldShellLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.sourceId = reader.string();
                    break;
                case 3:
                    message.goldShell = reader.int32();
                    break;
                case 4:
                    message.recordDate = reader.string();
                    break;
                case 5:
                    message.statusMsg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("sourceId"))
                throw $util.ProtocolError("missing required 'sourceId'", { instance: message });
            if (!message.hasOwnProperty("goldShell"))
                throw $util.ProtocolError("missing required 'goldShell'", { instance: message });
            if (!message.hasOwnProperty("recordDate"))
                throw $util.ProtocolError("missing required 'recordDate'", { instance: message });
            if (!message.hasOwnProperty("statusMsg"))
                throw $util.ProtocolError("missing required 'statusMsg'", { instance: message });
            return message;
        };

        /**
         * Decodes a ReceivedGoldShellLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RechargeResult.ReceivedGoldShellLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RechargeResult.ReceivedGoldShellLog} ReceivedGoldShellLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceivedGoldShellLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ReceivedGoldShellLog;
    })();

    return RechargeResult;
})();

export const RedEnvelopeResult = $root.RedEnvelopeResult = (() => {

    /**
     * Namespace RedEnvelopeResult.
     * @exports RedEnvelopeResult
     * @namespace
     */
    const RedEnvelopeResult = {};

    RedEnvelopeResult.Setting = (function() {

        /**
         * Properties of a Setting.
         * @memberof RedEnvelopeResult
         * @interface ISetting
         * @property {boolean|null} [canInvitationCode] Setting canInvitationCode
         */

        /**
         * Constructs a new Setting.
         * @memberof RedEnvelopeResult
         * @classdesc Represents a Setting.
         * @implements ISetting
         * @constructor
         * @param {RedEnvelopeResult.ISetting=} [properties] Properties to set
         */
        function Setting(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Setting canInvitationCode.
         * @member {boolean} canInvitationCode
         * @memberof RedEnvelopeResult.Setting
         * @instance
         */
        Setting.prototype.canInvitationCode = false;

        /**
         * Decodes a Setting message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.Setting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.Setting} Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Setting.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.Setting();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.canInvitationCode = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Setting message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.Setting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.Setting} Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Setting.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Setting;
    })();

    RedEnvelopeResult.RedEnvelopeList = (function() {

        /**
         * Properties of a RedEnvelopeList.
         * @memberof RedEnvelopeResult
         * @interface IRedEnvelopeList
         * @property {Array.<RedEnvelopeResult.IRedEnvelope>|null} [redEnvelopes] RedEnvelopeList redEnvelopes
         */

        /**
         * Constructs a new RedEnvelopeList.
         * @memberof RedEnvelopeResult
         * @classdesc Represents a RedEnvelopeList.
         * @implements IRedEnvelopeList
         * @constructor
         * @param {RedEnvelopeResult.IRedEnvelopeList=} [properties] Properties to set
         */
        function RedEnvelopeList(properties) {
            this.redEnvelopes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedEnvelopeList redEnvelopes.
         * @member {Array.<RedEnvelopeResult.IRedEnvelope>} redEnvelopes
         * @memberof RedEnvelopeResult.RedEnvelopeList
         * @instance
         */
        RedEnvelopeList.prototype.redEnvelopes = $util.emptyArray;

        /**
         * Decodes a RedEnvelopeList message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.RedEnvelopeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.RedEnvelopeList} RedEnvelopeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.RedEnvelopeList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.redEnvelopes && message.redEnvelopes.length))
                        message.redEnvelopes = [];
                    message.redEnvelopes.push($root.RedEnvelopeResult.RedEnvelope.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedEnvelopeList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.RedEnvelopeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.RedEnvelopeList} RedEnvelopeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RedEnvelopeList;
    })();

    RedEnvelopeResult.RedEnvelope = (function() {

        /**
         * Properties of a RedEnvelope.
         * @memberof RedEnvelopeResult
         * @interface IRedEnvelope
         * @property {string} id RedEnvelope id
         * @property {number|null} [money] RedEnvelope money
         * @property {number|null} [type] 类型：1登录红包，2直播间红包，3邀请红包，4签到红包
         * @property {number|Long|null} [overTime] RedEnvelope overTime
         * @property {number|Long|null} [createTime] RedEnvelope createTime
         */

        /**
         * Constructs a new RedEnvelope.
         * @memberof RedEnvelopeResult
         * @classdesc Represents a RedEnvelope.
         * @implements IRedEnvelope
         * @constructor
         * @param {RedEnvelopeResult.IRedEnvelope=} [properties] Properties to set
         */
        function RedEnvelope(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedEnvelope id.
         * @member {string} id
         * @memberof RedEnvelopeResult.RedEnvelope
         * @instance
         */
        RedEnvelope.prototype.id = "";

        /**
         * RedEnvelope money.
         * @member {number} money
         * @memberof RedEnvelopeResult.RedEnvelope
         * @instance
         */
        RedEnvelope.prototype.money = 0;

        /**
         * 类型：1登录红包，2直播间红包，3邀请红包，4签到红包
         * @member {number} type
         * @memberof RedEnvelopeResult.RedEnvelope
         * @instance
         */
        RedEnvelope.prototype.type = 0;

        /**
         * RedEnvelope overTime.
         * @member {number|Long} overTime
         * @memberof RedEnvelopeResult.RedEnvelope
         * @instance
         */
        RedEnvelope.prototype.overTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RedEnvelope createTime.
         * @member {number|Long} createTime
         * @memberof RedEnvelopeResult.RedEnvelope
         * @instance
         */
        RedEnvelope.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes a RedEnvelope message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.RedEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.RedEnvelope} RedEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.RedEnvelope();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.money = reader.int32();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.overTime = reader.int64();
                    break;
                case 5:
                    message.createTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a RedEnvelope message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.RedEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.RedEnvelope} RedEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelope.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return RedEnvelope;
    })();

    RedEnvelopeResult.InvitationCode = (function() {

        /**
         * Properties of an InvitationCode.
         * @memberof RedEnvelopeResult
         * @interface IInvitationCode
         */

        /**
         * Constructs a new InvitationCode.
         * @memberof RedEnvelopeResult
         * @classdesc Represents an InvitationCode.
         * @implements IInvitationCode
         * @constructor
         * @param {RedEnvelopeResult.IInvitationCode=} [properties] Properties to set
         */
        function InvitationCode(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Decodes an InvitationCode message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.InvitationCode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.InvitationCode} InvitationCode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvitationCode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.InvitationCode();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvitationCode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.InvitationCode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.InvitationCode} InvitationCode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvitationCode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return InvitationCode;
    })();

    RedEnvelopeResult.DrawingsResult = (function() {

        /**
         * Properties of a DrawingsResult.
         * @memberof RedEnvelopeResult
         * @interface IDrawingsResult
         * @property {string} msg DrawingsResult msg
         * @property {number|null} [status] DrawingsResult status
         */

        /**
         * Constructs a new DrawingsResult.
         * @memberof RedEnvelopeResult
         * @classdesc Represents a DrawingsResult.
         * @implements IDrawingsResult
         * @constructor
         * @param {RedEnvelopeResult.IDrawingsResult=} [properties] Properties to set
         */
        function DrawingsResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DrawingsResult msg.
         * @member {string} msg
         * @memberof RedEnvelopeResult.DrawingsResult
         * @instance
         */
        DrawingsResult.prototype.msg = "";

        /**
         * DrawingsResult status.
         * @member {number} status
         * @memberof RedEnvelopeResult.DrawingsResult
         * @instance
         */
        DrawingsResult.prototype.status = 0;

        /**
         * Decodes a DrawingsResult message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.DrawingsResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.DrawingsResult} DrawingsResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DrawingsResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.DrawingsResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = reader.string();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("msg"))
                throw $util.ProtocolError("missing required 'msg'", { instance: message });
            return message;
        };

        /**
         * Decodes a DrawingsResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.DrawingsResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.DrawingsResult} DrawingsResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DrawingsResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return DrawingsResult;
    })();

    RedEnvelopeResult.ExpenseStatus = (function() {

        /**
         * Properties of an ExpenseStatus.
         * @memberof RedEnvelopeResult
         * @interface IExpenseStatus
         * @property {string} orderId ExpenseStatus orderId
         * @property {number} status ExpenseStatus status
         */

        /**
         * Constructs a new ExpenseStatus.
         * @memberof RedEnvelopeResult
         * @classdesc Represents an ExpenseStatus.
         * @implements IExpenseStatus
         * @constructor
         * @param {RedEnvelopeResult.IExpenseStatus=} [properties] Properties to set
         */
        function ExpenseStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpenseStatus orderId.
         * @member {string} orderId
         * @memberof RedEnvelopeResult.ExpenseStatus
         * @instance
         */
        ExpenseStatus.prototype.orderId = "";

        /**
         * ExpenseStatus status.
         * @member {number} status
         * @memberof RedEnvelopeResult.ExpenseStatus
         * @instance
         */
        ExpenseStatus.prototype.status = 0;

        /**
         * Decodes an ExpenseStatus message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.ExpenseStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.ExpenseStatus} ExpenseStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpenseStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.ExpenseStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.orderId = reader.string();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("orderId"))
                throw $util.ProtocolError("missing required 'orderId'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes an ExpenseStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.ExpenseStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.ExpenseStatus} ExpenseStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpenseStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ExpenseStatus;
    })();

    RedEnvelopeResult.ExpenseList = (function() {

        /**
         * Properties of an ExpenseList.
         * @memberof RedEnvelopeResult
         * @interface IExpenseList
         * @property {Array.<RedEnvelopeResult.IExpenseInfo>|null} [list] ExpenseList list
         */

        /**
         * Constructs a new ExpenseList.
         * @memberof RedEnvelopeResult
         * @classdesc Represents an ExpenseList.
         * @implements IExpenseList
         * @constructor
         * @param {RedEnvelopeResult.IExpenseList=} [properties] Properties to set
         */
        function ExpenseList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpenseList list.
         * @member {Array.<RedEnvelopeResult.IExpenseInfo>} list
         * @memberof RedEnvelopeResult.ExpenseList
         * @instance
         */
        ExpenseList.prototype.list = $util.emptyArray;

        /**
         * Decodes an ExpenseList message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.ExpenseList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.ExpenseList} ExpenseList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpenseList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.ExpenseList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RedEnvelopeResult.ExpenseInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExpenseList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.ExpenseList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.ExpenseList} ExpenseList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpenseList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ExpenseList;
    })();

    RedEnvelopeResult.ExpenseInfo = (function() {

        /**
         * Properties of an ExpenseInfo.
         * @memberof RedEnvelopeResult
         * @interface IExpenseInfo
         * @property {string} id ExpenseInfo id
         * @property {string|null} [orderId] ExpenseInfo orderId
         * @property {string|null} [userId] ExpenseInfo userId
         * @property {number|null} [payType] ExpenseInfo payType
         * @property {number|null} [money] ExpenseInfo money
         * @property {number|Long|null} [createTime] ExpenseInfo createTime
         * @property {boolean|null} [needGetStatus] ExpenseInfo needGetStatus
         * @property {number|null} [status] ExpenseInfo status
         */

        /**
         * Constructs a new ExpenseInfo.
         * @memberof RedEnvelopeResult
         * @classdesc Represents an ExpenseInfo.
         * @implements IExpenseInfo
         * @constructor
         * @param {RedEnvelopeResult.IExpenseInfo=} [properties] Properties to set
         */
        function ExpenseInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpenseInfo id.
         * @member {string} id
         * @memberof RedEnvelopeResult.ExpenseInfo
         * @instance
         */
        ExpenseInfo.prototype.id = "";

        /**
         * ExpenseInfo orderId.
         * @member {string} orderId
         * @memberof RedEnvelopeResult.ExpenseInfo
         * @instance
         */
        ExpenseInfo.prototype.orderId = "";

        /**
         * ExpenseInfo userId.
         * @member {string} userId
         * @memberof RedEnvelopeResult.ExpenseInfo
         * @instance
         */
        ExpenseInfo.prototype.userId = "";

        /**
         * ExpenseInfo payType.
         * @member {number} payType
         * @memberof RedEnvelopeResult.ExpenseInfo
         * @instance
         */
        ExpenseInfo.prototype.payType = 0;

        /**
         * ExpenseInfo money.
         * @member {number} money
         * @memberof RedEnvelopeResult.ExpenseInfo
         * @instance
         */
        ExpenseInfo.prototype.money = 0;

        /**
         * ExpenseInfo createTime.
         * @member {number|Long} createTime
         * @memberof RedEnvelopeResult.ExpenseInfo
         * @instance
         */
        ExpenseInfo.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExpenseInfo needGetStatus.
         * @member {boolean} needGetStatus
         * @memberof RedEnvelopeResult.ExpenseInfo
         * @instance
         */
        ExpenseInfo.prototype.needGetStatus = false;

        /**
         * ExpenseInfo status.
         * @member {number} status
         * @memberof RedEnvelopeResult.ExpenseInfo
         * @instance
         */
        ExpenseInfo.prototype.status = 0;

        /**
         * Decodes an ExpenseInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.ExpenseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.ExpenseInfo} ExpenseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpenseInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.ExpenseInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.orderId = reader.string();
                    break;
                case 3:
                    message.userId = reader.string();
                    break;
                case 4:
                    message.payType = reader.int32();
                    break;
                case 5:
                    message.money = reader.int32();
                    break;
                case 6:
                    message.createTime = reader.int64();
                    break;
                case 7:
                    message.needGetStatus = reader.bool();
                    break;
                case 8:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes an ExpenseInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.ExpenseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.ExpenseInfo} ExpenseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpenseInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ExpenseInfo;
    })();

    RedEnvelopeResult.ExpenseInfoDetail = (function() {

        /**
         * Properties of an ExpenseInfoDetail.
         * @memberof RedEnvelopeResult
         * @interface IExpenseInfoDetail
         * @property {string} userId ExpenseInfoDetail userId
         * @property {string} orderId ExpenseInfoDetail orderId
         * @property {number} payType ExpenseInfoDetail payType
         * @property {number} money ExpenseInfoDetail money
         * @property {string} payeeRealName ExpenseInfoDetail payeeRealName
         * @property {string} payeeAccount ExpenseInfoDetail payeeAccount
         * @property {number} status ExpenseInfoDetail status
         * @property {number|Long|null} [createTime] ExpenseInfoDetail createTime
         * @property {boolean|null} [needGetStatus] ExpenseInfoDetail needGetStatus
         */

        /**
         * Constructs a new ExpenseInfoDetail.
         * @memberof RedEnvelopeResult
         * @classdesc Represents an ExpenseInfoDetail.
         * @implements IExpenseInfoDetail
         * @constructor
         * @param {RedEnvelopeResult.IExpenseInfoDetail=} [properties] Properties to set
         */
        function ExpenseInfoDetail(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpenseInfoDetail userId.
         * @member {string} userId
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @instance
         */
        ExpenseInfoDetail.prototype.userId = "";

        /**
         * ExpenseInfoDetail orderId.
         * @member {string} orderId
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @instance
         */
        ExpenseInfoDetail.prototype.orderId = "";

        /**
         * ExpenseInfoDetail payType.
         * @member {number} payType
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @instance
         */
        ExpenseInfoDetail.prototype.payType = 0;

        /**
         * ExpenseInfoDetail money.
         * @member {number} money
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @instance
         */
        ExpenseInfoDetail.prototype.money = 0;

        /**
         * ExpenseInfoDetail payeeRealName.
         * @member {string} payeeRealName
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @instance
         */
        ExpenseInfoDetail.prototype.payeeRealName = "";

        /**
         * ExpenseInfoDetail payeeAccount.
         * @member {string} payeeAccount
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @instance
         */
        ExpenseInfoDetail.prototype.payeeAccount = "";

        /**
         * ExpenseInfoDetail status.
         * @member {number} status
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @instance
         */
        ExpenseInfoDetail.prototype.status = 0;

        /**
         * ExpenseInfoDetail createTime.
         * @member {number|Long} createTime
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @instance
         */
        ExpenseInfoDetail.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExpenseInfoDetail needGetStatus.
         * @member {boolean} needGetStatus
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @instance
         */
        ExpenseInfoDetail.prototype.needGetStatus = false;

        /**
         * Decodes an ExpenseInfoDetail message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.ExpenseInfoDetail} ExpenseInfoDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpenseInfoDetail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.ExpenseInfoDetail();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.orderId = reader.string();
                    break;
                case 3:
                    message.payType = reader.int32();
                    break;
                case 4:
                    message.money = reader.int32();
                    break;
                case 5:
                    message.payeeRealName = reader.string();
                    break;
                case 6:
                    message.payeeAccount = reader.string();
                    break;
                case 7:
                    message.status = reader.int32();
                    break;
                case 8:
                    message.createTime = reader.int64();
                    break;
                case 9:
                    message.needGetStatus = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("orderId"))
                throw $util.ProtocolError("missing required 'orderId'", { instance: message });
            if (!message.hasOwnProperty("payType"))
                throw $util.ProtocolError("missing required 'payType'", { instance: message });
            if (!message.hasOwnProperty("money"))
                throw $util.ProtocolError("missing required 'money'", { instance: message });
            if (!message.hasOwnProperty("payeeRealName"))
                throw $util.ProtocolError("missing required 'payeeRealName'", { instance: message });
            if (!message.hasOwnProperty("payeeAccount"))
                throw $util.ProtocolError("missing required 'payeeAccount'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes an ExpenseInfoDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.ExpenseInfoDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.ExpenseInfoDetail} ExpenseInfoDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpenseInfoDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ExpenseInfoDetail;
    })();

    RedEnvelopeResult.ExchangeList = (function() {

        /**
         * Properties of an ExchangeList.
         * @memberof RedEnvelopeResult
         * @interface IExchangeList
         * @property {Array.<RedEnvelopeResult.IExchangeInfo>|null} [list] ExchangeList list
         */

        /**
         * Constructs a new ExchangeList.
         * @memberof RedEnvelopeResult
         * @classdesc Represents an ExchangeList.
         * @implements IExchangeList
         * @constructor
         * @param {RedEnvelopeResult.IExchangeList=} [properties] Properties to set
         */
        function ExchangeList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeList list.
         * @member {Array.<RedEnvelopeResult.IExchangeInfo>} list
         * @memberof RedEnvelopeResult.ExchangeList
         * @instance
         */
        ExchangeList.prototype.list = $util.emptyArray;

        /**
         * Decodes an ExchangeList message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.ExchangeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.ExchangeList} ExchangeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.ExchangeList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.RedEnvelopeResult.ExchangeInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.ExchangeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.ExchangeList} ExchangeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ExchangeList;
    })();

    RedEnvelopeResult.ExchangeInfo = (function() {

        /**
         * Properties of an ExchangeInfo.
         * @memberof RedEnvelopeResult
         * @interface IExchangeInfo
         * @property {string} id ExchangeInfo id
         * @property {string|null} [rechargeId] ExchangeInfo rechargeId
         * @property {number|null} [money] ExchangeInfo money
         * @property {number|null} [goldShell] ExchangeInfo goldShell
         * @property {number|Long|null} [balance] ExchangeInfo balance
         * @property {number|Long|null} [createTime] ExchangeInfo createTime
         */

        /**
         * Constructs a new ExchangeInfo.
         * @memberof RedEnvelopeResult
         * @classdesc Represents an ExchangeInfo.
         * @implements IExchangeInfo
         * @constructor
         * @param {RedEnvelopeResult.IExchangeInfo=} [properties] Properties to set
         */
        function ExchangeInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeInfo id.
         * @member {string} id
         * @memberof RedEnvelopeResult.ExchangeInfo
         * @instance
         */
        ExchangeInfo.prototype.id = "";

        /**
         * ExchangeInfo rechargeId.
         * @member {string} rechargeId
         * @memberof RedEnvelopeResult.ExchangeInfo
         * @instance
         */
        ExchangeInfo.prototype.rechargeId = "";

        /**
         * ExchangeInfo money.
         * @member {number} money
         * @memberof RedEnvelopeResult.ExchangeInfo
         * @instance
         */
        ExchangeInfo.prototype.money = 0;

        /**
         * ExchangeInfo goldShell.
         * @member {number} goldShell
         * @memberof RedEnvelopeResult.ExchangeInfo
         * @instance
         */
        ExchangeInfo.prototype.goldShell = 0;

        /**
         * ExchangeInfo balance.
         * @member {number|Long} balance
         * @memberof RedEnvelopeResult.ExchangeInfo
         * @instance
         */
        ExchangeInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeInfo createTime.
         * @member {number|Long} createTime
         * @memberof RedEnvelopeResult.ExchangeInfo
         * @instance
         */
        ExchangeInfo.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Decodes an ExchangeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.ExchangeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.ExchangeInfo} ExchangeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.ExchangeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.rechargeId = reader.string();
                    break;
                case 3:
                    message.money = reader.int32();
                    break;
                case 4:
                    message.goldShell = reader.int32();
                    break;
                case 5:
                    message.balance = reader.int64();
                    break;
                case 6:
                    message.createTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes an ExchangeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.ExchangeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.ExchangeInfo} ExchangeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ExchangeInfo;
    })();

    RedEnvelopeResult.InviteRedEnvelopeList = (function() {

        /**
         * Properties of an InviteRedEnvelopeList.
         * @memberof RedEnvelopeResult
         * @interface IInviteRedEnvelopeList
         * @property {Array.<UserResult.IUserBase>|null} [base] InviteRedEnvelopeList base
         * @property {Array.<number>|null} [status] InviteRedEnvelopeList status
         */

        /**
         * Constructs a new InviteRedEnvelopeList.
         * @memberof RedEnvelopeResult
         * @classdesc Represents an InviteRedEnvelopeList.
         * @implements IInviteRedEnvelopeList
         * @constructor
         * @param {RedEnvelopeResult.IInviteRedEnvelopeList=} [properties] Properties to set
         */
        function InviteRedEnvelopeList(properties) {
            this.base = [];
            this.status = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InviteRedEnvelopeList base.
         * @member {Array.<UserResult.IUserBase>} base
         * @memberof RedEnvelopeResult.InviteRedEnvelopeList
         * @instance
         */
        InviteRedEnvelopeList.prototype.base = $util.emptyArray;

        /**
         * InviteRedEnvelopeList status.
         * @member {Array.<number>} status
         * @memberof RedEnvelopeResult.InviteRedEnvelopeList
         * @instance
         */
        InviteRedEnvelopeList.prototype.status = $util.emptyArray;

        /**
         * Decodes an InviteRedEnvelopeList message from the specified reader or buffer.
         * @function decode
         * @memberof RedEnvelopeResult.InviteRedEnvelopeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedEnvelopeResult.InviteRedEnvelopeList} InviteRedEnvelopeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteRedEnvelopeList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedEnvelopeResult.InviteRedEnvelopeList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.base && message.base.length))
                        message.base = [];
                    message.base.push($root.UserResult.UserBase.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.status && message.status.length))
                        message.status = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.status.push(reader.int32());
                    } else
                        message.status.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InviteRedEnvelopeList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedEnvelopeResult.InviteRedEnvelopeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedEnvelopeResult.InviteRedEnvelopeList} InviteRedEnvelopeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteRedEnvelopeList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return InviteRedEnvelopeList;
    })();

    return RedEnvelopeResult;
})();

export const ResourceResult = $root.ResourceResult = (() => {

    /**
     * Namespace ResourceResult.
     * @exports ResourceResult
     * @namespace
     */
    const ResourceResult = {};

    ResourceResult.Musics = (function() {

        /**
         * Properties of a Musics.
         * @memberof ResourceResult
         * @interface IMusics
         * @property {Array.<ResourceResult.IMusicInfo>|null} [list] Musics list
         */

        /**
         * Constructs a new Musics.
         * @memberof ResourceResult
         * @classdesc Represents a Musics.
         * @implements IMusics
         * @constructor
         * @param {ResourceResult.IMusics=} [properties] Properties to set
         */
        function Musics(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Musics list.
         * @member {Array.<ResourceResult.IMusicInfo>} list
         * @memberof ResourceResult.Musics
         * @instance
         */
        Musics.prototype.list = $util.emptyArray;

        /**
         * Decodes a Musics message from the specified reader or buffer.
         * @function decode
         * @memberof ResourceResult.Musics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ResourceResult.Musics} Musics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Musics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResourceResult.Musics();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.ResourceResult.MusicInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Musics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ResourceResult.Musics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ResourceResult.Musics} Musics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Musics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Musics;
    })();

    ResourceResult.MusicInfo = (function() {

        /**
         * Properties of a MusicInfo.
         * @memberof ResourceResult
         * @interface IMusicInfo
         * @property {string} id MusicInfo id
         * @property {string|null} [name] MusicInfo name
         * @property {string|null} [singer] MusicInfo singer
         * @property {string|null} [uploader] MusicInfo uploader
         * @property {string|null} [uploaderName] MusicInfo uploaderName
         * @property {number|null} [uploaderLogoTime] MusicInfo uploaderLogoTime
         * @property {string|null} [uploaderThirdUrl] MusicInfo uploaderThirdUrl
         * @property {string|null} [downloadURL] MusicInfo downloadURL
         * @property {number|null} [fileSize] MusicInfo fileSize
         * @property {string|null} [musicTime] MusicInfo musicTime
         * @property {number|Long|null} [seat] MusicInfo seat
         * @property {number} playNumber MusicInfo playNumber
         */

        /**
         * Constructs a new MusicInfo.
         * @memberof ResourceResult
         * @classdesc Represents a MusicInfo.
         * @implements IMusicInfo
         * @constructor
         * @param {ResourceResult.IMusicInfo=} [properties] Properties to set
         */
        function MusicInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MusicInfo id.
         * @member {string} id
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.id = "";

        /**
         * MusicInfo name.
         * @member {string} name
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.name = "";

        /**
         * MusicInfo singer.
         * @member {string} singer
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.singer = "";

        /**
         * MusicInfo uploader.
         * @member {string} uploader
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.uploader = "";

        /**
         * MusicInfo uploaderName.
         * @member {string} uploaderName
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.uploaderName = "";

        /**
         * MusicInfo uploaderLogoTime.
         * @member {number} uploaderLogoTime
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.uploaderLogoTime = 0;

        /**
         * MusicInfo uploaderThirdUrl.
         * @member {string} uploaderThirdUrl
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.uploaderThirdUrl = "";

        /**
         * MusicInfo downloadURL.
         * @member {string} downloadURL
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.downloadURL = "";

        /**
         * MusicInfo fileSize.
         * @member {number} fileSize
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.fileSize = 0;

        /**
         * MusicInfo musicTime.
         * @member {string} musicTime
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.musicTime = "";

        /**
         * MusicInfo seat.
         * @member {number|Long} seat
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.seat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MusicInfo playNumber.
         * @member {number} playNumber
         * @memberof ResourceResult.MusicInfo
         * @instance
         */
        MusicInfo.prototype.playNumber = 0;

        /**
         * Decodes a MusicInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ResourceResult.MusicInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ResourceResult.MusicInfo} MusicInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MusicInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResourceResult.MusicInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.singer = reader.string();
                    break;
                case 4:
                    message.uploader = reader.string();
                    break;
                case 5:
                    message.uploaderName = reader.string();
                    break;
                case 6:
                    message.uploaderLogoTime = reader.int32();
                    break;
                case 7:
                    message.uploaderThirdUrl = reader.string();
                    break;
                case 8:
                    message.downloadURL = reader.string();
                    break;
                case 9:
                    message.fileSize = reader.double();
                    break;
                case 10:
                    message.musicTime = reader.string();
                    break;
                case 11:
                    message.seat = reader.int64();
                    break;
                case 12:
                    message.playNumber = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("playNumber"))
                throw $util.ProtocolError("missing required 'playNumber'", { instance: message });
            return message;
        };

        /**
         * Decodes a MusicInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ResourceResult.MusicInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ResourceResult.MusicInfo} MusicInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MusicInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return MusicInfo;
    })();

    ResourceResult.ChannelInfo = (function() {

        /**
         * Properties of a ChannelInfo.
         * @memberof ResourceResult
         * @interface IChannelInfo
         * @property {string} version ChannelInfo version
         * @property {number} forceUpdate ChannelInfo forceUpdate
         * @property {string} downloadUrl ChannelInfo downloadUrl
         * @property {number} iosPayType ChannelInfo iosPayType
         * @property {boolean} isSanBox ChannelInfo isSanBox
         * @property {string} desc ChannelInfo desc
         */

        /**
         * Constructs a new ChannelInfo.
         * @memberof ResourceResult
         * @classdesc Represents a ChannelInfo.
         * @implements IChannelInfo
         * @constructor
         * @param {ResourceResult.IChannelInfo=} [properties] Properties to set
         */
        function ChannelInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelInfo version.
         * @member {string} version
         * @memberof ResourceResult.ChannelInfo
         * @instance
         */
        ChannelInfo.prototype.version = "";

        /**
         * ChannelInfo forceUpdate.
         * @member {number} forceUpdate
         * @memberof ResourceResult.ChannelInfo
         * @instance
         */
        ChannelInfo.prototype.forceUpdate = 0;

        /**
         * ChannelInfo downloadUrl.
         * @member {string} downloadUrl
         * @memberof ResourceResult.ChannelInfo
         * @instance
         */
        ChannelInfo.prototype.downloadUrl = "";

        /**
         * ChannelInfo iosPayType.
         * @member {number} iosPayType
         * @memberof ResourceResult.ChannelInfo
         * @instance
         */
        ChannelInfo.prototype.iosPayType = 0;

        /**
         * ChannelInfo isSanBox.
         * @member {boolean} isSanBox
         * @memberof ResourceResult.ChannelInfo
         * @instance
         */
        ChannelInfo.prototype.isSanBox = false;

        /**
         * ChannelInfo desc.
         * @member {string} desc
         * @memberof ResourceResult.ChannelInfo
         * @instance
         */
        ChannelInfo.prototype.desc = "";

        /**
         * Decodes a ChannelInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ResourceResult.ChannelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ResourceResult.ChannelInfo} ChannelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResourceResult.ChannelInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.forceUpdate = reader.int32();
                    break;
                case 3:
                    message.downloadUrl = reader.string();
                    break;
                case 4:
                    message.iosPayType = reader.int32();
                    break;
                case 5:
                    message.isSanBox = reader.bool();
                    break;
                case 6:
                    message.desc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("version"))
                throw $util.ProtocolError("missing required 'version'", { instance: message });
            if (!message.hasOwnProperty("forceUpdate"))
                throw $util.ProtocolError("missing required 'forceUpdate'", { instance: message });
            if (!message.hasOwnProperty("downloadUrl"))
                throw $util.ProtocolError("missing required 'downloadUrl'", { instance: message });
            if (!message.hasOwnProperty("iosPayType"))
                throw $util.ProtocolError("missing required 'iosPayType'", { instance: message });
            if (!message.hasOwnProperty("isSanBox"))
                throw $util.ProtocolError("missing required 'isSanBox'", { instance: message });
            if (!message.hasOwnProperty("desc"))
                throw $util.ProtocolError("missing required 'desc'", { instance: message });
            return message;
        };

        /**
         * Decodes a ChannelInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ResourceResult.ChannelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ResourceResult.ChannelInfo} ChannelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ChannelInfo;
    })();

    return ResourceResult;
})();

export const ShortcutMessageResult = $root.ShortcutMessageResult = (() => {

    /**
     * Namespace ShortcutMessageResult.
     * @exports ShortcutMessageResult
     * @namespace
     */
    const ShortcutMessageResult = {};

    ShortcutMessageResult.ShortcutMessageList = (function() {

        /**
         * Properties of a ShortcutMessageList.
         * @memberof ShortcutMessageResult
         * @interface IShortcutMessageList
         * @property {Array.<ShortcutMessageResult.IShortcutMessage>|null} [list] ShortcutMessageList list
         */

        /**
         * Constructs a new ShortcutMessageList.
         * @memberof ShortcutMessageResult
         * @classdesc Represents a ShortcutMessageList.
         * @implements IShortcutMessageList
         * @constructor
         * @param {ShortcutMessageResult.IShortcutMessageList=} [properties] Properties to set
         */
        function ShortcutMessageList(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShortcutMessageList list.
         * @member {Array.<ShortcutMessageResult.IShortcutMessage>} list
         * @memberof ShortcutMessageResult.ShortcutMessageList
         * @instance
         */
        ShortcutMessageList.prototype.list = $util.emptyArray;

        /**
         * Decodes a ShortcutMessageList message from the specified reader or buffer.
         * @function decode
         * @memberof ShortcutMessageResult.ShortcutMessageList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ShortcutMessageResult.ShortcutMessageList} ShortcutMessageList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShortcutMessageList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ShortcutMessageResult.ShortcutMessageList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.ShortcutMessageResult.ShortcutMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShortcutMessageList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ShortcutMessageResult.ShortcutMessageList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ShortcutMessageResult.ShortcutMessageList} ShortcutMessageList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShortcutMessageList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ShortcutMessageList;
    })();

    ShortcutMessageResult.ShortcutMessage = (function() {

        /**
         * Properties of a ShortcutMessage.
         * @memberof ShortcutMessageResult
         * @interface IShortcutMessage
         * @property {string} id ShortcutMessage id
         * @property {string} userId ShortcutMessage userId
         * @property {string} message ShortcutMessage message
         * @property {number} sortingNo ShortcutMessage sortingNo
         * @property {string|null} [createTime] ShortcutMessage createTime
         * @property {string|null} [updateTime] ShortcutMessage updateTime
         */

        /**
         * Constructs a new ShortcutMessage.
         * @memberof ShortcutMessageResult
         * @classdesc Represents a ShortcutMessage.
         * @implements IShortcutMessage
         * @constructor
         * @param {ShortcutMessageResult.IShortcutMessage=} [properties] Properties to set
         */
        function ShortcutMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShortcutMessage id.
         * @member {string} id
         * @memberof ShortcutMessageResult.ShortcutMessage
         * @instance
         */
        ShortcutMessage.prototype.id = "";

        /**
         * ShortcutMessage userId.
         * @member {string} userId
         * @memberof ShortcutMessageResult.ShortcutMessage
         * @instance
         */
        ShortcutMessage.prototype.userId = "";

        /**
         * ShortcutMessage message.
         * @member {string} message
         * @memberof ShortcutMessageResult.ShortcutMessage
         * @instance
         */
        ShortcutMessage.prototype.message = "";

        /**
         * ShortcutMessage sortingNo.
         * @member {number} sortingNo
         * @memberof ShortcutMessageResult.ShortcutMessage
         * @instance
         */
        ShortcutMessage.prototype.sortingNo = 0;

        /**
         * ShortcutMessage createTime.
         * @member {string} createTime
         * @memberof ShortcutMessageResult.ShortcutMessage
         * @instance
         */
        ShortcutMessage.prototype.createTime = "";

        /**
         * ShortcutMessage updateTime.
         * @member {string} updateTime
         * @memberof ShortcutMessageResult.ShortcutMessage
         * @instance
         */
        ShortcutMessage.prototype.updateTime = "";

        /**
         * Decodes a ShortcutMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ShortcutMessageResult.ShortcutMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ShortcutMessageResult.ShortcutMessage} ShortcutMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShortcutMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ShortcutMessageResult.ShortcutMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.message = reader.string();
                    break;
                case 4:
                    message.sortingNo = reader.int32();
                    break;
                case 5:
                    message.createTime = reader.string();
                    break;
                case 6:
                    message.updateTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("userId"))
                throw $util.ProtocolError("missing required 'userId'", { instance: message });
            if (!message.hasOwnProperty("message"))
                throw $util.ProtocolError("missing required 'message'", { instance: message });
            if (!message.hasOwnProperty("sortingNo"))
                throw $util.ProtocolError("missing required 'sortingNo'", { instance: message });
            return message;
        };

        /**
         * Decodes a ShortcutMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ShortcutMessageResult.ShortcutMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ShortcutMessageResult.ShortcutMessage} ShortcutMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShortcutMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ShortcutMessage;
    })();

    return ShortcutMessageResult;
})();

export const SkillChatResult = $root.SkillChatResult = (() => {

    /**
     * Namespace SkillChatResult.
     * @exports SkillChatResult
     * @namespace
     */
    const SkillChatResult = {};

    SkillChatResult.SkillChatBroadcast = (function() {

        /**
         * Properties of a SkillChatBroadcast.
         * @memberof SkillChatResult
         * @interface ISkillChatBroadcast
         * @property {number} status SkillChatBroadcast status
         * @property {string|null} [callerId] SkillChatBroadcast callerId
         * @property {string|null} [anchorId] SkillChatBroadcast anchorId
         * @property {UserResult.IUserBase|null} [caller] SkillChatBroadcast caller
         * @property {UserResult.IUserBase|null} [anchor] SkillChatBroadcast anchor
         * @property {string|null} [roomId] SkillChatBroadcast roomId
         * @property {number|null} [chatTime] SkillChatBroadcast chatTime
         * @property {number|null} [totalMoney] SkillChatBroadcast totalMoney
         * @property {number|null} [anchorMoney] SkillChatBroadcast anchorMoney
         * @property {number|null} [ltMinute] SkillChatBroadcast ltMinute
         */

        /**
         * Constructs a new SkillChatBroadcast.
         * @memberof SkillChatResult
         * @classdesc Represents a SkillChatBroadcast.
         * @implements ISkillChatBroadcast
         * @constructor
         * @param {SkillChatResult.ISkillChatBroadcast=} [properties] Properties to set
         */
        function SkillChatBroadcast(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SkillChatBroadcast status.
         * @member {number} status
         * @memberof SkillChatResult.SkillChatBroadcast
         * @instance
         */
        SkillChatBroadcast.prototype.status = 0;

        /**
         * SkillChatBroadcast callerId.
         * @member {string} callerId
         * @memberof SkillChatResult.SkillChatBroadcast
         * @instance
         */
        SkillChatBroadcast.prototype.callerId = "";

        /**
         * SkillChatBroadcast anchorId.
         * @member {string} anchorId
         * @memberof SkillChatResult.SkillChatBroadcast
         * @instance
         */
        SkillChatBroadcast.prototype.anchorId = "";

        /**
         * SkillChatBroadcast caller.
         * @member {UserResult.IUserBase|null|undefined} caller
         * @memberof SkillChatResult.SkillChatBroadcast
         * @instance
         */
        SkillChatBroadcast.prototype.caller = null;

        /**
         * SkillChatBroadcast anchor.
         * @member {UserResult.IUserBase|null|undefined} anchor
         * @memberof SkillChatResult.SkillChatBroadcast
         * @instance
         */
        SkillChatBroadcast.prototype.anchor = null;

        /**
         * SkillChatBroadcast roomId.
         * @member {string} roomId
         * @memberof SkillChatResult.SkillChatBroadcast
         * @instance
         */
        SkillChatBroadcast.prototype.roomId = "";

        /**
         * SkillChatBroadcast chatTime.
         * @member {number} chatTime
         * @memberof SkillChatResult.SkillChatBroadcast
         * @instance
         */
        SkillChatBroadcast.prototype.chatTime = 0;

        /**
         * SkillChatBroadcast totalMoney.
         * @member {number} totalMoney
         * @memberof SkillChatResult.SkillChatBroadcast
         * @instance
         */
        SkillChatBroadcast.prototype.totalMoney = 0;

        /**
         * SkillChatBroadcast anchorMoney.
         * @member {number} anchorMoney
         * @memberof SkillChatResult.SkillChatBroadcast
         * @instance
         */
        SkillChatBroadcast.prototype.anchorMoney = 0;

        /**
         * SkillChatBroadcast ltMinute.
         * @member {number} ltMinute
         * @memberof SkillChatResult.SkillChatBroadcast
         * @instance
         */
        SkillChatBroadcast.prototype.ltMinute = 0;

        /**
         * Decodes a SkillChatBroadcast message from the specified reader or buffer.
         * @function decode
         * @memberof SkillChatResult.SkillChatBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SkillChatResult.SkillChatBroadcast} SkillChatBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillChatBroadcast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SkillChatResult.SkillChatBroadcast();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.callerId = reader.string();
                    break;
                case 3:
                    message.anchorId = reader.string();
                    break;
                case 4:
                    message.caller = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.anchor = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.roomId = reader.string();
                    break;
                case 7:
                    message.chatTime = reader.int32();
                    break;
                case 8:
                    message.totalMoney = reader.int32();
                    break;
                case 9:
                    message.anchorMoney = reader.int32();
                    break;
                case 10:
                    message.ltMinute = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes a SkillChatBroadcast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SkillChatResult.SkillChatBroadcast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SkillChatResult.SkillChatBroadcast} SkillChatBroadcast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillChatBroadcast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SkillChatBroadcast;
    })();

    SkillChatResult.LiveChatList = (function() {

        /**
         * Properties of a LiveChatList.
         * @memberof SkillChatResult
         * @interface ILiveChatList
         * @property {Array.<SkillChatResult.ILiveChatLog>|null} [logInfo] LiveChatList logInfo
         */

        /**
         * Constructs a new LiveChatList.
         * @memberof SkillChatResult
         * @classdesc Represents a LiveChatList.
         * @implements ILiveChatList
         * @constructor
         * @param {SkillChatResult.ILiveChatList=} [properties] Properties to set
         */
        function LiveChatList(properties) {
            this.logInfo = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveChatList logInfo.
         * @member {Array.<SkillChatResult.ILiveChatLog>} logInfo
         * @memberof SkillChatResult.LiveChatList
         * @instance
         */
        LiveChatList.prototype.logInfo = $util.emptyArray;

        /**
         * Decodes a LiveChatList message from the specified reader or buffer.
         * @function decode
         * @memberof SkillChatResult.LiveChatList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SkillChatResult.LiveChatList} LiveChatList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveChatList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SkillChatResult.LiveChatList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logInfo && message.logInfo.length))
                        message.logInfo = [];
                    message.logInfo.push($root.SkillChatResult.LiveChatLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LiveChatList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SkillChatResult.LiveChatList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SkillChatResult.LiveChatList} LiveChatList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveChatList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveChatList;
    })();

    SkillChatResult.LiveChatLog = (function() {

        /**
         * Properties of a LiveChatLog.
         * @memberof SkillChatResult
         * @interface ILiveChatLog
         * @property {string} id LiveChatLog id
         * @property {UserResult.IUserBase|null} [anchor] LiveChatLog anchor
         * @property {UserResult.IUserBase|null} [caller] LiveChatLog caller
         * @property {number|null} [chatTime] LiveChatLog chatTime
         * @property {number|null} [totalMoney] LiveChatLog totalMoney
         * @property {number|null} [anchorMoney] LiveChatLog anchorMoney
         * @property {string|null} [logTime] LiveChatLog logTime
         */

        /**
         * Constructs a new LiveChatLog.
         * @memberof SkillChatResult
         * @classdesc Represents a LiveChatLog.
         * @implements ILiveChatLog
         * @constructor
         * @param {SkillChatResult.ILiveChatLog=} [properties] Properties to set
         */
        function LiveChatLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveChatLog id.
         * @member {string} id
         * @memberof SkillChatResult.LiveChatLog
         * @instance
         */
        LiveChatLog.prototype.id = "";

        /**
         * LiveChatLog anchor.
         * @member {UserResult.IUserBase|null|undefined} anchor
         * @memberof SkillChatResult.LiveChatLog
         * @instance
         */
        LiveChatLog.prototype.anchor = null;

        /**
         * LiveChatLog caller.
         * @member {UserResult.IUserBase|null|undefined} caller
         * @memberof SkillChatResult.LiveChatLog
         * @instance
         */
        LiveChatLog.prototype.caller = null;

        /**
         * LiveChatLog chatTime.
         * @member {number} chatTime
         * @memberof SkillChatResult.LiveChatLog
         * @instance
         */
        LiveChatLog.prototype.chatTime = 0;

        /**
         * LiveChatLog totalMoney.
         * @member {number} totalMoney
         * @memberof SkillChatResult.LiveChatLog
         * @instance
         */
        LiveChatLog.prototype.totalMoney = 0;

        /**
         * LiveChatLog anchorMoney.
         * @member {number} anchorMoney
         * @memberof SkillChatResult.LiveChatLog
         * @instance
         */
        LiveChatLog.prototype.anchorMoney = 0;

        /**
         * LiveChatLog logTime.
         * @member {string} logTime
         * @memberof SkillChatResult.LiveChatLog
         * @instance
         */
        LiveChatLog.prototype.logTime = "";

        /**
         * Decodes a LiveChatLog message from the specified reader or buffer.
         * @function decode
         * @memberof SkillChatResult.LiveChatLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SkillChatResult.LiveChatLog} LiveChatLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveChatLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SkillChatResult.LiveChatLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.anchor = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.caller = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.chatTime = reader.int32();
                    break;
                case 5:
                    message.totalMoney = reader.int32();
                    break;
                case 6:
                    message.anchorMoney = reader.int32();
                    break;
                case 7:
                    message.logTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a LiveChatLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SkillChatResult.LiveChatLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SkillChatResult.LiveChatLog} LiveChatLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveChatLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return LiveChatLog;
    })();

    return SkillChatResult;
})();

export const SkillResult = $root.SkillResult = (() => {

    /**
     * Namespace SkillResult.
     * @exports SkillResult
     * @namespace
     */
    const SkillResult = {};

    SkillResult.UserSkillList = (function() {

        /**
         * Properties of a UserSkillList.
         * @memberof SkillResult
         * @interface IUserSkillList
         * @property {Array.<SkillResult.IUserSkillInfo>|null} [userSkills] UserSkillList userSkills
         */

        /**
         * Constructs a new UserSkillList.
         * @memberof SkillResult
         * @classdesc Represents a UserSkillList.
         * @implements IUserSkillList
         * @constructor
         * @param {SkillResult.IUserSkillList=} [properties] Properties to set
         */
        function UserSkillList(properties) {
            this.userSkills = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSkillList userSkills.
         * @member {Array.<SkillResult.IUserSkillInfo>} userSkills
         * @memberof SkillResult.UserSkillList
         * @instance
         */
        UserSkillList.prototype.userSkills = $util.emptyArray;

        /**
         * Decodes a UserSkillList message from the specified reader or buffer.
         * @function decode
         * @memberof SkillResult.UserSkillList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SkillResult.UserSkillList} UserSkillList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSkillList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SkillResult.UserSkillList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.userSkills && message.userSkills.length))
                        message.userSkills = [];
                    message.userSkills.push($root.SkillResult.UserSkillInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSkillList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SkillResult.UserSkillList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SkillResult.UserSkillList} UserSkillList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSkillList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserSkillList;
    })();

    SkillResult.UserSkillInfo = (function() {

        /**
         * Properties of a UserSkillInfo.
         * @memberof SkillResult
         * @interface IUserSkillInfo
         * @property {string|null} [userId] UserSkillInfo userId
         * @property {string|null} [name] UserSkillInfo name
         * @property {number|null} [type] UserSkillInfo type
         * @property {number|null} [status] UserSkillInfo status
         * @property {string|null} [picInfoTime] UserSkillInfo picInfoTime
         * @property {string|null} [videoInfoTime] UserSkillInfo videoInfoTime
         * @property {string|null} [voiceInfoTime] UserSkillInfo voiceInfoTime
         * @property {number|null} [level] UserSkillInfo level
         * @property {string|null} [levelDesc] UserSkillInfo levelDesc
         * @property {number|null} [price] UserSkillInfo price
         * @property {string|null} [note] UserSkillInfo note
         * @property {number|null} [avgScore] UserSkillInfo avgScore
         * @property {number|null} [orderNum] UserSkillInfo orderNum
         * @property {number|null} [updateTime] UserSkillInfo updateTime
         * @property {boolean|null} [noDisturbMode] UserSkillInfo noDisturbMode
         * @property {string|null} [labelIds] UserSkillInfo labelIds
         * @property {boolean|null} [online] UserSkillInfo online
         * @property {boolean|null} [oncall] UserSkillInfo oncall
         * @property {UserResult.IUserBase|null} [userBase] UserSkillInfo userBase
         * @property {number|null} [voiceTimeSpan] UserSkillInfo voiceTimeSpan
         * @property {string|null} [evalLabelIds] UserSkillInfo evalLabelIds
         * @property {UserResult.IUserInfo|null} [userInfo] UserSkillInfo userInfo
         * @property {UserResult.IUserDetail|null} [userDetail] UserSkillInfo userDetail
         */

        /**
         * Constructs a new UserSkillInfo.
         * @memberof SkillResult
         * @classdesc Represents a UserSkillInfo.
         * @implements IUserSkillInfo
         * @constructor
         * @param {SkillResult.IUserSkillInfo=} [properties] Properties to set
         */
        function UserSkillInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSkillInfo userId.
         * @member {string} userId
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.userId = "";

        /**
         * UserSkillInfo name.
         * @member {string} name
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.name = "";

        /**
         * UserSkillInfo type.
         * @member {number} type
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.type = 0;

        /**
         * UserSkillInfo status.
         * @member {number} status
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.status = 0;

        /**
         * UserSkillInfo picInfoTime.
         * @member {string} picInfoTime
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.picInfoTime = "";

        /**
         * UserSkillInfo videoInfoTime.
         * @member {string} videoInfoTime
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.videoInfoTime = "";

        /**
         * UserSkillInfo voiceInfoTime.
         * @member {string} voiceInfoTime
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.voiceInfoTime = "";

        /**
         * UserSkillInfo level.
         * @member {number} level
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.level = 0;

        /**
         * UserSkillInfo levelDesc.
         * @member {string} levelDesc
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.levelDesc = "";

        /**
         * UserSkillInfo price.
         * @member {number} price
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.price = 0;

        /**
         * UserSkillInfo note.
         * @member {string} note
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.note = "";

        /**
         * UserSkillInfo avgScore.
         * @member {number} avgScore
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.avgScore = 0;

        /**
         * UserSkillInfo orderNum.
         * @member {number} orderNum
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.orderNum = 0;

        /**
         * UserSkillInfo updateTime.
         * @member {number} updateTime
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.updateTime = 0;

        /**
         * UserSkillInfo noDisturbMode.
         * @member {boolean} noDisturbMode
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.noDisturbMode = false;

        /**
         * UserSkillInfo labelIds.
         * @member {string} labelIds
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.labelIds = "";

        /**
         * UserSkillInfo online.
         * @member {boolean} online
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.online = false;

        /**
         * UserSkillInfo oncall.
         * @member {boolean} oncall
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.oncall = false;

        /**
         * UserSkillInfo userBase.
         * @member {UserResult.IUserBase|null|undefined} userBase
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.userBase = null;

        /**
         * UserSkillInfo voiceTimeSpan.
         * @member {number} voiceTimeSpan
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.voiceTimeSpan = 0;

        /**
         * UserSkillInfo evalLabelIds.
         * @member {string} evalLabelIds
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.evalLabelIds = "";

        /**
         * UserSkillInfo userInfo.
         * @member {UserResult.IUserInfo|null|undefined} userInfo
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.userInfo = null;

        /**
         * UserSkillInfo userDetail.
         * @member {UserResult.IUserDetail|null|undefined} userDetail
         * @memberof SkillResult.UserSkillInfo
         * @instance
         */
        UserSkillInfo.prototype.userDetail = null;

        /**
         * Decodes a UserSkillInfo message from the specified reader or buffer.
         * @function decode
         * @memberof SkillResult.UserSkillInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SkillResult.UserSkillInfo} UserSkillInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSkillInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SkillResult.UserSkillInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.status = reader.int32();
                    break;
                case 5:
                    message.picInfoTime = reader.string();
                    break;
                case 6:
                    message.videoInfoTime = reader.string();
                    break;
                case 7:
                    message.voiceInfoTime = reader.string();
                    break;
                case 8:
                    message.level = reader.int32();
                    break;
                case 9:
                    message.levelDesc = reader.string();
                    break;
                case 10:
                    message.price = reader.int32();
                    break;
                case 11:
                    message.note = reader.string();
                    break;
                case 12:
                    message.avgScore = reader.double();
                    break;
                case 13:
                    message.orderNum = reader.int32();
                    break;
                case 14:
                    message.updateTime = reader.int32();
                    break;
                case 15:
                    message.noDisturbMode = reader.bool();
                    break;
                case 16:
                    message.labelIds = reader.string();
                    break;
                case 17:
                    message.online = reader.bool();
                    break;
                case 18:
                    message.oncall = reader.bool();
                    break;
                case 19:
                    message.userBase = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.voiceTimeSpan = reader.int32();
                    break;
                case 21:
                    message.evalLabelIds = reader.string();
                    break;
                case 22:
                    message.userInfo = $root.UserResult.UserInfo.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.userDetail = $root.UserResult.UserDetail.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSkillInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SkillResult.UserSkillInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SkillResult.UserSkillInfo} UserSkillInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSkillInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserSkillInfo;
    })();

    SkillResult.SkillList = (function() {

        /**
         * Properties of a SkillList.
         * @memberof SkillResult
         * @interface ISkillList
         * @property {Array.<SkillResult.ISkillInfo>|null} [skills] SkillList skills
         */

        /**
         * Constructs a new SkillList.
         * @memberof SkillResult
         * @classdesc Represents a SkillList.
         * @implements ISkillList
         * @constructor
         * @param {SkillResult.ISkillList=} [properties] Properties to set
         */
        function SkillList(properties) {
            this.skills = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SkillList skills.
         * @member {Array.<SkillResult.ISkillInfo>} skills
         * @memberof SkillResult.SkillList
         * @instance
         */
        SkillList.prototype.skills = $util.emptyArray;

        /**
         * Decodes a SkillList message from the specified reader or buffer.
         * @function decode
         * @memberof SkillResult.SkillList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SkillResult.SkillList} SkillList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SkillResult.SkillList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.skills && message.skills.length))
                        message.skills = [];
                    message.skills.push($root.SkillResult.SkillInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SkillList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SkillResult.SkillList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SkillResult.SkillList} SkillList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SkillList;
    })();

    SkillResult.SkillInfo = (function() {

        /**
         * Properties of a SkillInfo.
         * @memberof SkillResult
         * @interface ISkillInfo
         * @property {string|null} [name] SkillInfo name
         * @property {number|null} [type] SkillInfo type
         * @property {string|null} [coverName] SkillInfo coverName
         * @property {string|null} [picInfoName] SkillInfo picInfoName
         * @property {string|null} [levelStr] SkillInfo levelStr
         * @property {number|null} [sequencing] SkillInfo sequencing
         * @property {string|null} [unit] SkillInfo unit
         */

        /**
         * Constructs a new SkillInfo.
         * @memberof SkillResult
         * @classdesc Represents a SkillInfo.
         * @implements ISkillInfo
         * @constructor
         * @param {SkillResult.ISkillInfo=} [properties] Properties to set
         */
        function SkillInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SkillInfo name.
         * @member {string} name
         * @memberof SkillResult.SkillInfo
         * @instance
         */
        SkillInfo.prototype.name = "";

        /**
         * SkillInfo type.
         * @member {number} type
         * @memberof SkillResult.SkillInfo
         * @instance
         */
        SkillInfo.prototype.type = 0;

        /**
         * SkillInfo coverName.
         * @member {string} coverName
         * @memberof SkillResult.SkillInfo
         * @instance
         */
        SkillInfo.prototype.coverName = "";

        /**
         * SkillInfo picInfoName.
         * @member {string} picInfoName
         * @memberof SkillResult.SkillInfo
         * @instance
         */
        SkillInfo.prototype.picInfoName = "";

        /**
         * SkillInfo levelStr.
         * @member {string} levelStr
         * @memberof SkillResult.SkillInfo
         * @instance
         */
        SkillInfo.prototype.levelStr = "";

        /**
         * SkillInfo sequencing.
         * @member {number} sequencing
         * @memberof SkillResult.SkillInfo
         * @instance
         */
        SkillInfo.prototype.sequencing = 0;

        /**
         * SkillInfo unit.
         * @member {string} unit
         * @memberof SkillResult.SkillInfo
         * @instance
         */
        SkillInfo.prototype.unit = "";

        /**
         * Decodes a SkillInfo message from the specified reader or buffer.
         * @function decode
         * @memberof SkillResult.SkillInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SkillResult.SkillInfo} SkillInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SkillResult.SkillInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.coverName = reader.string();
                    break;
                case 4:
                    message.picInfoName = reader.string();
                    break;
                case 5:
                    message.levelStr = reader.string();
                    break;
                case 6:
                    message.sequencing = reader.int32();
                    break;
                case 7:
                    message.unit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SkillInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SkillResult.SkillInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SkillResult.SkillInfo} SkillInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SkillInfo;
    })();

    SkillResult.SendDataCardInfo = (function() {

        /**
         * Properties of a SendDataCardInfo.
         * @memberof SkillResult
         * @interface ISendDataCardInfo
         * @property {boolean} canSendDataCard SendDataCardInfo canSendDataCard
         * @property {string} lastSendTime SendDataCardInfo lastSendTime
         */

        /**
         * Constructs a new SendDataCardInfo.
         * @memberof SkillResult
         * @classdesc Represents a SendDataCardInfo.
         * @implements ISendDataCardInfo
         * @constructor
         * @param {SkillResult.ISendDataCardInfo=} [properties] Properties to set
         */
        function SendDataCardInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendDataCardInfo canSendDataCard.
         * @member {boolean} canSendDataCard
         * @memberof SkillResult.SendDataCardInfo
         * @instance
         */
        SendDataCardInfo.prototype.canSendDataCard = false;

        /**
         * SendDataCardInfo lastSendTime.
         * @member {string} lastSendTime
         * @memberof SkillResult.SendDataCardInfo
         * @instance
         */
        SendDataCardInfo.prototype.lastSendTime = "";

        /**
         * Decodes a SendDataCardInfo message from the specified reader or buffer.
         * @function decode
         * @memberof SkillResult.SendDataCardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SkillResult.SendDataCardInfo} SendDataCardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendDataCardInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SkillResult.SendDataCardInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.canSendDataCard = reader.bool();
                    break;
                case 2:
                    message.lastSendTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("canSendDataCard"))
                throw $util.ProtocolError("missing required 'canSendDataCard'", { instance: message });
            if (!message.hasOwnProperty("lastSendTime"))
                throw $util.ProtocolError("missing required 'lastSendTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a SendDataCardInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SkillResult.SendDataCardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SkillResult.SendDataCardInfo} SendDataCardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendDataCardInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SendDataCardInfo;
    })();

    return SkillResult;
})();

export const SmashEggResult = $root.SmashEggResult = (() => {

    /**
     * Namespace SmashEggResult.
     * @exports SmashEggResult
     * @namespace
     */
    const SmashEggResult = {};

    SmashEggResult.SmashEggGift = (function() {

        /**
         * Properties of a SmashEggGift.
         * @memberof SmashEggResult
         * @interface ISmashEggGift
         * @property {string} giftId SmashEggGift giftId
         * @property {string|null} [name] SmashEggGift name
         * @property {number|null} [price] SmashEggGift price
         * @property {number|null} [amount] SmashEggGift amount
         * @property {string|null} [activityMode] SmashEggGift activityMode
         * @property {number|null} [activityGiftType] SmashEggGift activityGiftType
         */

        /**
         * Constructs a new SmashEggGift.
         * @memberof SmashEggResult
         * @classdesc Represents a SmashEggGift.
         * @implements ISmashEggGift
         * @constructor
         * @param {SmashEggResult.ISmashEggGift=} [properties] Properties to set
         */
        function SmashEggGift(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmashEggGift giftId.
         * @member {string} giftId
         * @memberof SmashEggResult.SmashEggGift
         * @instance
         */
        SmashEggGift.prototype.giftId = "";

        /**
         * SmashEggGift name.
         * @member {string} name
         * @memberof SmashEggResult.SmashEggGift
         * @instance
         */
        SmashEggGift.prototype.name = "";

        /**
         * SmashEggGift price.
         * @member {number} price
         * @memberof SmashEggResult.SmashEggGift
         * @instance
         */
        SmashEggGift.prototype.price = 0;

        /**
         * SmashEggGift amount.
         * @member {number} amount
         * @memberof SmashEggResult.SmashEggGift
         * @instance
         */
        SmashEggGift.prototype.amount = 0;

        /**
         * SmashEggGift activityMode.
         * @member {string} activityMode
         * @memberof SmashEggResult.SmashEggGift
         * @instance
         */
        SmashEggGift.prototype.activityMode = "";

        /**
         * SmashEggGift activityGiftType.
         * @member {number} activityGiftType
         * @memberof SmashEggResult.SmashEggGift
         * @instance
         */
        SmashEggGift.prototype.activityGiftType = 0;

        /**
         * Decodes a SmashEggGift message from the specified reader or buffer.
         * @function decode
         * @memberof SmashEggResult.SmashEggGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SmashEggResult.SmashEggGift} SmashEggGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashEggGift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SmashEggResult.SmashEggGift();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.giftId = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.price = reader.int32();
                    break;
                case 4:
                    message.amount = reader.int32();
                    break;
                case 5:
                    message.activityMode = reader.string();
                    break;
                case 6:
                    message.activityGiftType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("giftId"))
                throw $util.ProtocolError("missing required 'giftId'", { instance: message });
            return message;
        };

        /**
         * Decodes a SmashEggGift message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SmashEggResult.SmashEggGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SmashEggResult.SmashEggGift} SmashEggGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashEggGift.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SmashEggGift;
    })();

    SmashEggResult.SmashResult = (function() {

        /**
         * Properties of a SmashResult.
         * @memberof SmashEggResult
         * @interface ISmashResult
         * @property {number} result SmashResult result
         * @property {number|null} [giftValue] SmashResult giftValue
         * @property {number|null} [gshBalance] SmashResult gshBalance
         * @property {number|null} [hmrBalance] SmashResult hmrBalance
         * @property {Array.<SmashEggResult.ISmashEggGift>|null} [giftList] SmashResult giftList
         * @property {string|null} [toastMsg] SmashResult toastMsg
         */

        /**
         * Constructs a new SmashResult.
         * @memberof SmashEggResult
         * @classdesc Represents a SmashResult.
         * @implements ISmashResult
         * @constructor
         * @param {SmashEggResult.ISmashResult=} [properties] Properties to set
         */
        function SmashResult(properties) {
            this.giftList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmashResult result.
         * @member {number} result
         * @memberof SmashEggResult.SmashResult
         * @instance
         */
        SmashResult.prototype.result = 0;

        /**
         * SmashResult giftValue.
         * @member {number} giftValue
         * @memberof SmashEggResult.SmashResult
         * @instance
         */
        SmashResult.prototype.giftValue = 0;

        /**
         * SmashResult gshBalance.
         * @member {number} gshBalance
         * @memberof SmashEggResult.SmashResult
         * @instance
         */
        SmashResult.prototype.gshBalance = 0;

        /**
         * SmashResult hmrBalance.
         * @member {number} hmrBalance
         * @memberof SmashEggResult.SmashResult
         * @instance
         */
        SmashResult.prototype.hmrBalance = 0;

        /**
         * SmashResult giftList.
         * @member {Array.<SmashEggResult.ISmashEggGift>} giftList
         * @memberof SmashEggResult.SmashResult
         * @instance
         */
        SmashResult.prototype.giftList = $util.emptyArray;

        /**
         * SmashResult toastMsg.
         * @member {string} toastMsg
         * @memberof SmashEggResult.SmashResult
         * @instance
         */
        SmashResult.prototype.toastMsg = "";

        /**
         * Decodes a SmashResult message from the specified reader or buffer.
         * @function decode
         * @memberof SmashEggResult.SmashResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SmashEggResult.SmashResult} SmashResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SmashEggResult.SmashResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.giftValue = reader.int32();
                    break;
                case 3:
                    message.gshBalance = reader.int32();
                    break;
                case 4:
                    message.hmrBalance = reader.int32();
                    break;
                case 5:
                    if (!(message.giftList && message.giftList.length))
                        message.giftList = [];
                    message.giftList.push($root.SmashEggResult.SmashEggGift.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.toastMsg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            return message;
        };

        /**
         * Decodes a SmashResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SmashEggResult.SmashResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SmashEggResult.SmashResult} SmashResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SmashResult;
    })();

    SmashEggResult.SmashEggLog = (function() {

        /**
         * Properties of a SmashEggLog.
         * @memberof SmashEggResult
         * @interface ISmashEggLog
         * @property {string|null} [logTime] SmashEggLog logTime
         * @property {string|null} [userId] SmashEggLog userId
         * @property {string|null} [nickName] SmashEggLog nickName
         * @property {string|null} [logoTime] SmashEggLog logoTime
         * @property {string|null} [thirdIconurl] SmashEggLog thirdIconurl
         * @property {SmashEggResult.ISmashEggGift|null} [gift] SmashEggLog gift
         * @property {string|null} [timeStr] SmashEggLog timeStr
         * @property {boolean|null} [isInRoom] SmashEggLog isInRoom
         * @property {number|null} [action] SmashEggLog action
         * @property {string|null} [eggType] SmashEggLog eggType
         * @property {string|null} [roomId] SmashEggLog roomId
         * @property {UserResult.IUserBase|null} [base] SmashEggLog base
         */

        /**
         * Constructs a new SmashEggLog.
         * @memberof SmashEggResult
         * @classdesc Represents a SmashEggLog.
         * @implements ISmashEggLog
         * @constructor
         * @param {SmashEggResult.ISmashEggLog=} [properties] Properties to set
         */
        function SmashEggLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmashEggLog logTime.
         * @member {string} logTime
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.logTime = "";

        /**
         * SmashEggLog userId.
         * @member {string} userId
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.userId = "";

        /**
         * SmashEggLog nickName.
         * @member {string} nickName
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.nickName = "";

        /**
         * SmashEggLog logoTime.
         * @member {string} logoTime
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.logoTime = "";

        /**
         * SmashEggLog thirdIconurl.
         * @member {string} thirdIconurl
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.thirdIconurl = "";

        /**
         * SmashEggLog gift.
         * @member {SmashEggResult.ISmashEggGift|null|undefined} gift
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.gift = null;

        /**
         * SmashEggLog timeStr.
         * @member {string} timeStr
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.timeStr = "";

        /**
         * SmashEggLog isInRoom.
         * @member {boolean} isInRoom
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.isInRoom = false;

        /**
         * SmashEggLog action.
         * @member {number} action
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.action = 0;

        /**
         * SmashEggLog eggType.
         * @member {string} eggType
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.eggType = "";

        /**
         * SmashEggLog roomId.
         * @member {string} roomId
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.roomId = "";

        /**
         * SmashEggLog base.
         * @member {UserResult.IUserBase|null|undefined} base
         * @memberof SmashEggResult.SmashEggLog
         * @instance
         */
        SmashEggLog.prototype.base = null;

        /**
         * Decodes a SmashEggLog message from the specified reader or buffer.
         * @function decode
         * @memberof SmashEggResult.SmashEggLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SmashEggResult.SmashEggLog} SmashEggLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashEggLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SmashEggResult.SmashEggLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logTime = reader.string();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.nickName = reader.string();
                    break;
                case 4:
                    message.logoTime = reader.string();
                    break;
                case 5:
                    message.thirdIconurl = reader.string();
                    break;
                case 6:
                    message.gift = $root.SmashEggResult.SmashEggGift.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.timeStr = reader.string();
                    break;
                case 8:
                    message.isInRoom = reader.bool();
                    break;
                case 9:
                    message.action = reader.int32();
                    break;
                case 10:
                    message.eggType = reader.string();
                    break;
                case 11:
                    message.roomId = reader.string();
                    break;
                case 12:
                    message.base = $root.UserResult.UserBase.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SmashEggLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SmashEggResult.SmashEggLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SmashEggResult.SmashEggLog} SmashEggLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashEggLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SmashEggLog;
    })();

    SmashEggResult.SmashEggLogs = (function() {

        /**
         * Properties of a SmashEggLogs.
         * @memberof SmashEggResult
         * @interface ISmashEggLogs
         * @property {Array.<SmashEggResult.ISmashEggLog>|null} [list] SmashEggLogs list
         */

        /**
         * Constructs a new SmashEggLogs.
         * @memberof SmashEggResult
         * @classdesc Represents a SmashEggLogs.
         * @implements ISmashEggLogs
         * @constructor
         * @param {SmashEggResult.ISmashEggLogs=} [properties] Properties to set
         */
        function SmashEggLogs(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmashEggLogs list.
         * @member {Array.<SmashEggResult.ISmashEggLog>} list
         * @memberof SmashEggResult.SmashEggLogs
         * @instance
         */
        SmashEggLogs.prototype.list = $util.emptyArray;

        /**
         * Decodes a SmashEggLogs message from the specified reader or buffer.
         * @function decode
         * @memberof SmashEggResult.SmashEggLogs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SmashEggResult.SmashEggLogs} SmashEggLogs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashEggLogs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SmashEggResult.SmashEggLogs();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.SmashEggResult.SmashEggLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SmashEggLogs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SmashEggResult.SmashEggLogs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SmashEggResult.SmashEggLogs} SmashEggLogs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmashEggLogs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return SmashEggLogs;
    })();

    SmashEggResult.ListGiftResult = (function() {

        /**
         * Properties of a ListGiftResult.
         * @memberof SmashEggResult
         * @interface IListGiftResult
         * @property {Array.<SmashEggResult.ISmashEggGift>|null} [list] ListGiftResult list
         */

        /**
         * Constructs a new ListGiftResult.
         * @memberof SmashEggResult
         * @classdesc Represents a ListGiftResult.
         * @implements IListGiftResult
         * @constructor
         * @param {SmashEggResult.IListGiftResult=} [properties] Properties to set
         */
        function ListGiftResult(properties) {
            this.list = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListGiftResult list.
         * @member {Array.<SmashEggResult.ISmashEggGift>} list
         * @memberof SmashEggResult.ListGiftResult
         * @instance
         */
        ListGiftResult.prototype.list = $util.emptyArray;

        /**
         * Decodes a ListGiftResult message from the specified reader or buffer.
         * @function decode
         * @memberof SmashEggResult.ListGiftResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SmashEggResult.ListGiftResult} ListGiftResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListGiftResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SmashEggResult.ListGiftResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.SmashEggResult.SmashEggGift.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListGiftResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SmashEggResult.ListGiftResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SmashEggResult.ListGiftResult} ListGiftResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListGiftResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return ListGiftResult;
    })();

    return SmashEggResult;
})();

export const TestResult = $root.TestResult = (() => {

    /**
     * Namespace TestResult.
     * @exports TestResult
     * @namespace
     */
    const TestResult = {};

    TestResult.Test = (function() {

        /**
         * Properties of a Test.
         * @memberof TestResult
         * @interface ITest
         * @property {string} playerId Test playerId
         * @property {string} name Test name
         * @property {number|null} [hp] Test hp
         */

        /**
         * Constructs a new Test.
         * @memberof TestResult
         * @classdesc Represents a Test.
         * @implements ITest
         * @constructor
         * @param {TestResult.ITest=} [properties] Properties to set
         */
        function Test(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Test playerId.
         * @member {string} playerId
         * @memberof TestResult.Test
         * @instance
         */
        Test.prototype.playerId = "";

        /**
         * Test name.
         * @member {string} name
         * @memberof TestResult.Test
         * @instance
         */
        Test.prototype.name = "";

        /**
         * Test hp.
         * @member {number} hp
         * @memberof TestResult.Test
         * @instance
         */
        Test.prototype.hp = 0;

        /**
         * Decodes a Test message from the specified reader or buffer.
         * @function decode
         * @memberof TestResult.Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TestResult.Test} Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestResult.Test();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerId = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.hp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("playerId"))
                throw $util.ProtocolError("missing required 'playerId'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };

        /**
         * Decodes a Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TestResult.Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TestResult.Test} Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Test;
    })();

    TestResult.Test1 = (function() {

        /**
         * Properties of a Test1.
         * @memberof TestResult
         * @interface ITest1
         * @property {string} key Test1 key
         * @property {number} value Test1 value
         */

        /**
         * Constructs a new Test1.
         * @memberof TestResult
         * @classdesc Represents a Test1.
         * @implements ITest1
         * @constructor
         * @param {TestResult.ITest1=} [properties] Properties to set
         */
        function Test1(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Test1 key.
         * @member {string} key
         * @memberof TestResult.Test1
         * @instance
         */
        Test1.prototype.key = "";

        /**
         * Test1 value.
         * @member {number} value
         * @memberof TestResult.Test1
         * @instance
         */
        Test1.prototype.value = 0;

        /**
         * Decodes a Test1 message from the specified reader or buffer.
         * @function decode
         * @memberof TestResult.Test1
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TestResult.Test1} Test1
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test1.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestResult.Test1();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes a Test1 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TestResult.Test1
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TestResult.Test1} Test1
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test1.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return Test1;
    })();

    return TestResult;
})();

export const UserCertificationResult = $root.UserCertificationResult = (() => {

    /**
     * Namespace UserCertificationResult.
     * @exports UserCertificationResult
     * @namespace
     */
    const UserCertificationResult = {};

    UserCertificationResult.UserCertification = (function() {

        /**
         * Properties of a UserCertification.
         * @memberof UserCertificationResult
         * @interface IUserCertification
         * @property {number} status UserCertification status
         * @property {string|null} [userId] UserCertification userId
         * @property {string|null} [idCard] UserCertification idCard
         * @property {string|null} [realName] UserCertification realName
         * @property {number|null} [coverTime] UserCertification coverTime
         */

        /**
         * Constructs a new UserCertification.
         * @memberof UserCertificationResult
         * @classdesc Represents a UserCertification.
         * @implements IUserCertification
         * @constructor
         * @param {UserCertificationResult.IUserCertification=} [properties] Properties to set
         */
        function UserCertification(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserCertification status.
         * @member {number} status
         * @memberof UserCertificationResult.UserCertification
         * @instance
         */
        UserCertification.prototype.status = 0;

        /**
         * UserCertification userId.
         * @member {string} userId
         * @memberof UserCertificationResult.UserCertification
         * @instance
         */
        UserCertification.prototype.userId = "";

        /**
         * UserCertification idCard.
         * @member {string} idCard
         * @memberof UserCertificationResult.UserCertification
         * @instance
         */
        UserCertification.prototype.idCard = "";

        /**
         * UserCertification realName.
         * @member {string} realName
         * @memberof UserCertificationResult.UserCertification
         * @instance
         */
        UserCertification.prototype.realName = "";

        /**
         * UserCertification coverTime.
         * @member {number} coverTime
         * @memberof UserCertificationResult.UserCertification
         * @instance
         */
        UserCertification.prototype.coverTime = 0;

        /**
         * Decodes a UserCertification message from the specified reader or buffer.
         * @function decode
         * @memberof UserCertificationResult.UserCertification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UserCertificationResult.UserCertification} UserCertification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCertification.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserCertificationResult.UserCertification();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.userId = reader.string();
                    break;
                case 3:
                    message.idCard = reader.string();
                    break;
                case 4:
                    message.realName = reader.string();
                    break;
                case 5:
                    message.coverTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };

        /**
         * Decodes a UserCertification message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UserCertificationResult.UserCertification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UserCertificationResult.UserCertification} UserCertification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCertification.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        return UserCertification;
    })();

    return UserCertificationResult;
})();

export { $root as default };
